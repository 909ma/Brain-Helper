[
  {
    "question": "Question 1.\n소프트웨어를 개발하기 위한 설계, 운용, 유지보수 등의 과정을 각 단계별로 나눈 것은?\n소프트웨어 개발 단계와 각 단계별 주요 활동 그리고 활동의 결과에 대한 산출물로 표현한다.",
    "answer": "Answer 1 : 소프트웨어 생명 주기\nAnswer 2 : Software Life Cycle"
  },
  {
    "question": "Question 2.\n이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론은?\n가장 오래되고 가장 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형이다.\n고전적 생명 주기 모형이라고도 한다.\n모형을 적용한 경험과 성공 사례가 많다.\n각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 한다.",
    "answer": "Answer 1 : 폭포수 모형\nAnswer 2 : Waterfall Model"
  },
  {
    "question": "Question 3.\n사용자의 요구사항을 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품(Prototype)을 만들어 최종 결과물을 예측하는 모형은?\n견본품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발한다.",
    "answer": "Answer 1 : 프로토타입 모형\nAnswer 2 : Prototype Model"
  },
  {
    "question": "Question 4.\n나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 모형은?\n보헴(Boehm)이 제안하였다.\n폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형이다.\n누락되거나 추가된 요구사항을 첨가할 수 있다.\n유지보수 과정이 필요없다.\n계획 수립 - > 위험 분석 - > 개발 및 검증 - > 고객 평가 - > 계획 수립의 사이클을 가진다.",
    "answer": "Answer 1 : 나선형 모형\nAnswer 2 : Spiral Model\nAnswer 3 : 점진적 모형"
  },
  {
    "question": "Question 5.\n○○○은 '민첩한', '기민한'이라는 의미로, 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형은?\n어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭한다.\n폭포수 모형과 대조적이다.\n기업 활동 전반에 걸쳐 사용된다.\n대표적인 개발 모형으로 스크럼(Scrum), XP(eXtreme Programming), 칸반(kanban), Lean, 기능 중심 개발(FDD; Feature Driven Development)이 있다.",
    "answer": "Answer 1 : 애자일 모형\nAnswer 2 : Agile Model"
  },
  {
    "question": "Question 6.\n○○○ 개발 네 가지 핵심 가치.\n① 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.\n② 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.\n③ 계약 협상보다는 고객과 협업에 더 가치를 둔다.\n④계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다.",
    "answer": "Answer 1 : 애자일"
  },
  {
    "question": "Question 7.\n소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문은?\n여러 가지 방법론과 도구, 관리 기법들을 통하여 소프트웨어의 품질과 생산성 향상을 목적으로 한다.\n○○○의 기본 원칙.\n① 현대적인 프로그래밍 기술을 계속적으로 적용해야 한다.\n② 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 한다.\n③ 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다.",
    "answer": "Answer 1 : 소프트웨어 공학\nAnswer 2 : SE\nAnswer 3 : Software Engineering"
  },
  {
    "question": "Question 8.\n팀이 중심이 되어 개발의 효율성을 높이는 기법은?\n팀원 스스로가 ○○○ 팀을 구성하고 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 한다.",
    "answer": "Answer 1 : 스크럼\nAnswer 2 : Scrum"
  },
  {
    "question": "Question 9.\n다음은 스크럼 팀을 이루는 세 가지의 구성원 중 하나에 대한 설명이다.\n① 요구사항이 담긴 백로그(Backlog)를 작성하는 주체.\n② 이해관계자들 중 개발될 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사를 결정할 사람으로 선정.",
    "answer": "Answer 1 : 제품 책임자\nAnswer 2 : PO\nAnswer 3 : Product Owner"
  },
  {
    "question": "Question 10.\n다음은 스크럼 팀을 이루는 세 가지의 구성원 중 하나에 대한 설명이다.\n스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할을 수행함.",
    "answer": "Answer 1 : 스크럼 마스터\nAnswer 2 : SM\nAnswer 3 : Scrum Master"
  },
  {
    "question": "Question 11.\n다음은 스크럼 팀을 이루는 세 가지의 구성원 중 하나에 대한 설명이다.\n제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로 제품 개발을 수행함.",
    "answer": "Answer 1 : 개발팀\nAnswer 2 : DT\nAnswer 3 : Development Team"
  },
  {
    "question": "Question 12.\n다음은 스크럼 개발 프로세스의 다섯 단계 중 하나에 대한 설명이다.\n제품 백로그 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립하는 회의.",
    "answer": "Answer 1 : 스프린트 계획 회의\nAnswer 2 : Sprint Planning Meeting"
  },
  {
    "question": "Question 13.\n다음은 스크럼 개발 프로세스의 다섯 단계 중 하나에 대한 설명이다.\n실제 개발 작업을 진행하는 과정으로, 보통 2~4주 정도의 기간 내에서 진행함.",
    "answer": "Answer 1 : 스프린트\nAnswer 2 : Sprint"
  },
  {
    "question": "Question 14.\n다음은 스크럼 개발 프로세스의 다섯 단계 중 하나에 대한 설명이다.\n① 모든 팀원이 매일 약속된 시간에 약 15분 동안 진행 상황을 점검하는 회의.\n② 남은 작업 시간은 소멸 차트(Burn- down Chart)에 표시함.",
    "answer": "Answer 1 : 일일 스크럼 회의\nAnswer 2 : Daily Scrum Meeting"
  },
  {
    "question": "Question 15.\n다음은 스크럼 개발 프로세스의 다섯 단계 중 하나에 대한 설명이다.\n부분 또는 전체 완성 제품이 요구사항에 잘 부합하는지 테스팅하는 회의.",
    "answer": "Answer 1 : 스프린트 검토 회의\nAnswer 2 : Sprint Review"
  },
  {
    "question": "Question 16.\n다음은 스크럼 개발 프로세스의 다섯 단계 중 하나에 대한 설명이다.\n정해놓은 규칙 준수 여부 및 개선할 점을 확인하고 기록하는 것.",
    "answer": "Answer 1 : 스프린트 회고\nAnswer 2 : Sprint Retrospective"
  },
  {
    "question": "Question 17.\n수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법은?\n짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.\n릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높인다.\n○○○의 다섯 가지 핵심 가치.\n① 의사소통(Communication).\n② 단순성(Simplicity).\n③ 용기(Courage).\n④존중(Respect).\n⑤ 피드백(Feedback).",
    "answer": "Answer 1 : XP\nAnswer 2 : eXtreme Programming"
  },
  {
    "question": "Question 18.\n다음은 XP 개발 프로세스의 네 종류 프로세스 중 하나에 대한 설명이다.\n① 부분 혹은 전체 개발 완료 시점에 대한 일정을 수립하는 것.\n② 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것을 릴리즈라고 함.",
    "answer": "Answer 1 : 릴리즈 계획 수립\nAnswer 2 : Release Planning"
  },
  {
    "question": "Question 19.\n다음은 XP 개발 프로세스의 네 종류 프로세스 중 하나에 대한 설명이다.\n실제 개발 작업을 진행하는 과정으로, 보통 1~3주 정도의 기간으로 진행됨.",
    "answer": "Answer 1 : 이터레이션\nAnswer 2 : Iteration\nAnswer 3 : 주기"
  },
  {
    "question": "Question 20.\n다음은 XP 개발 프로세스의 네 종류 프로세스 중 하나에 대한 설명이다.\n하나의 이터레이션 안에서 부분 완료 제품이 구현되면 수행하는 테스트",
    "answer": "Answer 1 : 승인 검사\nAnswer 2 : Acceptance Test\nAnswer 3 : 인수 테스트"
  },
  {
    "question": "Question 21.\n다음은 XP 개발 프로세스의 네 종류 프로세스 중 하나에 대한 설명이다.\n요구사항에 유연하게 대응할 수 있도록 릴리즈의 규모를 축소한 것.",
    "answer": "Answer 1 : 소규모 릴리즈\nAnswer 2 : Small Release"
  },
  {
    "question": "Question 22.\n다음은 XP의 주요 실천 방법(Practice)의 일곱 가지 방법 중 하나에 대한 설명이다.\n다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성함.",
    "answer": "Answer 1 : Pair Programming\nAnswer 2 : 짝 프로그래밍"
  },
  {
    "question": "Question 23.\n다음은 XP의 주요 실천 방법(Practice)의 일곱 가지 방법 중 하나에 대한 설명이다.\n개발 코드에 대한 권한과 책임을 공동으로 소유함.",
    "answer": "Answer 1 : Collective Ownership\nAnswer 2 : 공동 코드 소유"
  },
  {
    "question": "Question 24.\n다음은 XP의 주요 실천 방법(Practice)의 일곱 가지 방법 중 하나에 대한 설명이다.\n① 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지를 정확히 파악함.\n② 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구(구조, 프레임워크)를 사용함.",
    "answer": "Answer 1 : Test- Driven Development\nAnswer 2 : 테스트 주도 개발"
  },
  {
    "question": "Question 25.\n다음은 XP의 주요 실천 방법(Practice)의 일곱 가지 방법 중 하나에 대한 설명이다.\n개발에 참여하는 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 함.",
    "answer": "Answer 1 : Whole Team\nAnswer 2 : 전체 팀"
  },
  {
    "question": "Question 26.\n다음은 XP의 주요 실천 방법(Practice)의 일곱 가지 방법 중 하나에 대한 설명이다.\n모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리 될 때마다 지속적으로 통합됨.",
    "answer": "Answer 1 : Continous Integration\nAnswer 2 : 계속적인 통합"
  },
  {
    "question": "Question 27.\n다음은 XP의 주요 실천 방법(Practice)의 일곱 가지 방법 중 하나에 대한 설명이다.\n① 프로그램 기능의 변경 없이 시스템을 재구성함.\n② 목적 : 프로그램을 쉽게 이해하고 쉽게 구정하여 빠르게 개발할 수 있도록 하기 위함.",
    "answer": "Answer 1 : Refactoring\nAnswer 2 : 리팩토링"
  },
  {
    "question": "Question 28.\n다음은 XP의 주요 실천 방법(Practice)의 일곱 가지 방법 중 하나에 대한 설명이다.\n릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있음.",
    "answer": "Answer 1 : Small Releases\nAnswer 2 : 소규모 릴리즈"
  },
  {
    "question": "Question 29.\n컴퓨터 시스템의 자원을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어는?\n컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종이다.\n다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공한다.\n○○○ 관련 요구사항 식별 시 고려사항.\n① 가용성.\n② 성능.\n③ 기술 지원.\n④주변기기.\n⑤ 구축비용.",
    "answer": "Answer 1 : 운영체제\nAnswer 2 : OS\nAnswer 3 : Operating System"
  },
  {
    "question": "Question 30.\n사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고, 데이터베이스를 관리해 주는 소프트웨어는?\n기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템이다.\n모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리한다.\n○○○ 관련 요구사항 식별 시 고려사항.\n① 가용성.\n② 성능.\n③ 기술 지원.\n④상호 호환성.\n⑤ 구축 비용.",
    "answer": "Answer 1 : 데이터베이스 관리 시스템\nAnswer 2 : DBMS\nAnswer 3 : DataBase Manegement System"
  },
  {
    "question": "Question 31.\n사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어는?\n데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리를 제공한다.\n주로 데이터베이스 서버와 연동해서 사용한다.\n○○○ 관련 요구사항 식별 시 고려사항.\n① 가용성.\n② 성능.\n③ 기술지원.\n④구축비용.",
    "answer": "Answer 1 : 웹 애플리케이션 서버\nAnswer 2 : WAS\nAnswer 3 : Web Application Server"
  },
  {
    "question": "Question 32.\n누구나 별다른 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어는?\n○○○ 라이선스를 만족한다.\n○○○ 관련 요구사항 식별 시 고려사항.\n① 라이선스의 종류.\n② 사용자 수.\n③ 기술의 지속 가능성.",
    "answer": "Answer 1 : 오픈 소스\nAnswer 2 : Open Source"
  },
  {
    "question": "Question 33.\n소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건은?\n소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공한다.\n개발에 참여하는 이해관계자들 간의 의사소통을 원활하게 하는 데 도움을 준다.\n○○○의 유형.\n① 기능 ○○○(Functional ○○○).\n② 비기능 ○○○(Non- Functional ○○○).\n③ 사용자 ○○○(User ○○○).\n④시스템 ○○○(System ○○○).",
    "answer": "Answer 1 : 요구사항\nAnswer 2 : Requirements"
  },
  {
    "question": "Question 34.\n시스템이 무엇을 하는지, 어떤 기능을 하는지 등의 기능이나 수행과 관련된 요구사항은?\n시스템의 입력이나 출력으로 무엇이 포함되어야 하는지에 대한 사항.\n시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사랑.\n시스템이 반드시 수행해야 하는 기능.\n사용자가 시스템을 통해 제공받기를 원하는 기능.",
    "answer": "Answer 1 : 기능 요구사항\nAnswer 2 : Functional requirements"
  },
  {
    "question": "Question 35.\n품질이나 제약사항과 관련된 요구사항은?\n시스템 장비 구성 요구사항.\n성능 요구사항.\n인터페이스 요구사항.\n데이터를 구축하기 위해 필요한 요구사항.\n데이터를 구축하기 위해 필요한 요구사항.\n테스트 요구사항.\n보안 요구사항.\n품질 요구사항 : 가용성, 정합성, 상호 호환성, 대응성, 이식성, 확장성, 보안성 등.\n제약사항.\n프로젝트 관리 요구사항.\n프로젝트 자원 요구사항.",
    "answer": "Answer 1 : 비기능 요구사항\nAnswer 2 : Non- functional requirements"
  },
  {
    "question": "Question 36.\n사용자 관점에서 본 시스템이 제공해야 할 요구사항은?\n사용자를 위한 것으로, 친숙한 표현으로 이해하기 쉽게 작성된다.",
    "answer": "Answer 1 : 사용자 요구사항\nAnswer 2 : User requirements"
  },
  {
    "question": "Question 37.\n개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항은?\n사용자 요구사항에 비해 전문적이고 기술적인 용어로 표현된다.\n소프트웨어 요구사항이라고도 한다.",
    "answer": "Answer 1 : 시스템 요구사항\nAnswer 2 : System requirements"
  },
  {
    "question": "Question 38.\n개발 대상에 대한 요구사항을 체게적으로 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 일련의 구조화된 활동은?\n○○○가 진행되기 전에 타당성 조사(Feasibility Study)가 선행되어야 한다.\n요구공학(Requirement Engineeing)의 한 요소이다.\n단계는 도출(Elicitation) - > 분석(Analysis) - > 명세(Specification) - > 확인(Validation)을 거친다.",
    "answer": "Answer 1 : 요구사항 개발 프로세스"
  },
  {
    "question": "Question 39.\n시스템, 사용자, 개발자 등 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 어떻게 수집할 것인지를 식별하고 이해하는 과정은?\n개발자와 고객 사이의 관계가 만들어지고 이해관계자(Stakeholder)가 식별된다.\n소프트웨어 개발 생명 주기(SDLC) 동안 지속적으로 반복된다.\n○○○ 주요 기법.\n① 청취와 인터뷰.\n② 설문.\n③ 브레인스토밍.\n④워크샵.\n⑤ 프로토타이핑.\n⑥ 유스케이스.",
    "answer": "Answer 1 : 요구사항 도출\nAnswer 2 : Requirement Elicitation\nAnswer 3 : 요구사항 수집"
  },
  {
    "question": "Question 40.\n개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정은?\n요구사항의 타당성을 조사하고 비용과 일정에 대한 제약을 설정한다.\n서로 상충되는 요구사항이 있으면 이를 중재하는 과정이다.\n○○○에 사용되는 대표적인 도구.\n① 자료 흐름도(DFD).\n② 자료 사전(DD).",
    "answer": "Answer 1 : 요구사항 분석\nAnswer 2 : Requirement Analysis"
  },
  {
    "question": "Question 41.\n분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것을 의미하는 것은?\n기능 요구사항을 빠짐없이 기술한다.\n비기능 요구사항은 필요한 것만 기술한다.\n구체적인 명세를 위해 소단위 명세서(Mini- Spec)가 사용될 수 있다.",
    "answer": "Answer 1 : 요구사항 명세\nAnswer 2 : Requirement Specification"
  },
  {
    "question": "Question 42.\n개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동은?\n이해관계자들이 검토해야 한다.\n요구사항 관리 도구를 이용하여 요구사항 정의 문서들에 대해 형상 관리(SCM)를 수행한다.",
    "answer": "Answer 1 : 요구사항 확인\nAnswer 2 : Reqiurement Validation\nAnswer 3 : 요구사항 검증"
  },
  {
    "question": "Question 43.\n무엇을 개발해야 하는지 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문은?\n요구사항 변경의 원인과 처리 방법을 이해하고 요구사항 관리 프로세스의 품질을 개선하여 소프트웨어 프로젝트 실패를 최소화하는 것을 목표로 한다.",
    "answer": "Answer 1 : 요구공학\nAnswer 2 : Reqiurements Engineering"
  },
  {
    "question": "Question 44.\n다음은 요구사항 명세 기법의 두 가지 중 하나에 대한 설명이다.\n기법 : 수학적 원리 기반, 모델 기반.\n작성 방법 : 수학적 기호, 정형화된 표기법.\n특징 : .\n① 요구사항을 정확하고 간결하게 표현할 수 있음.\n② 요구사항에 대한 결과가 작성자에 관계없이 일관성이 있으므로 완전성 검증이 가능함.\n③ 표기법이 어려워 사용자가 이해하기 어려움.\n종류 : VDM, Z, Petri- net, CSP 등.",
    "answer": "Answer 1 : 정형 명세 기법"
  },
  {
    "question": "Question 45.\n기법 : 상태/기능/객체 중심.\n작성 방법 : 일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성.\n특징 : .\n① 자연어의 사용으로 인해 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고, 해석이 달라질 수 있음.\n② 내용의 이해가 쉬워 의사소통이 용이함.\n종류 : FSM, Decision Tavle, ER모델링, State Chart(SADT) 등.",
    "answer": "Answer 1 : 비정형 명세 기법"
  },
  {
    "question": "Question 46.\n소프트웨어 개발의 실제적인 첫 단계로, 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화하는 활동을 의미하는 것은?\n사용자 요구의 타당성을 조사하고 비용과 일정에 대한 제약을 설정한다.\n사용자의 요구를 정확하게 추출하여 목표를 정한다.",
    "answer": "Answer 1 : 요구사항 분석\nAnswer 2 : Requirement Anlysis"
  },
  {
    "question": "Question 47.\n자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법은?\n도형 중심의 분석용 도구와 분석 절차를 이용하여 사용자의 요구사항을 파악하고 문서화한다.\n하향식 방법을 사용하여 시스템을 세분화할 수 있다.\n분석의 중복을 배제할 수 있다.\n주요 ○○○ 도구.\n① 자료 흐름도(DFD).\n② 자료 사전(DD).\n③ 소단위 명세서(Mini- Spec).\n④개체 관계도(ERD).\n⑤ 상태 전이도(STD).\n⑥ 제어 명세서.",
    "answer": "Answer 1 : 구조적 분석 기법"
  },
  {
    "question": "Question 48.\n요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법은?\n자료 흐름 그래프, 버블 차트라고도 한다.\n자료 흐름과 처리를 중심으로 하는 구조적 분석 기법에 이용된다.",
    "answer": "Answer 1 : 자료 흐름도\nAnswer 2 : DFD\nAnswer 3 : Data Flow Diagram"
  },
  {
    "question": "Question 49.\n자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것은?\n데이터를 설명하는 데이터로, 데이터의 데이터 또는 메타 데이터(Meta Data)라고도 한다.",
    "answer": "Answer 1 : 자료 사전\nAnswer 2 : DD\nAnswer 3 : Data Dictionary"
  },
  {
    "question": "Question 50.\n요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구를 의미하는 것은?\n대표적인 ○○○.\n⑴ SADT : .\n① 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위한 도구.\n② SoftTech 사에서 개발.\n③ 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구.\n⑵ SREM = RSL/REVS : .\n① TRW 사가 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 도구.\n② RSL과 REVS를 사용하는 자동화 도구.\n⑶ PSL/PSA : .\n① PSL과 PSA를 사용하는 자동화 도구.\n② 미시간 대학에서 개발.\n⑷ TAGS : .\n① 시스템 공학 방법 응용에 대한 자동 접근 방법.\n② 개발 주기의 전 과정에 이용할 수있는 통합 자동화 도구.",
    "answer": "Answer 1 : 요구사항 분석용 CASE\nAnswer 2 : 자동화 도구"
  },
  {
    "question": "Question 51.\n시스템의 분석 및 설계, 또는 문서화에 사용되는 기법으로, 시스템 실행 과정인 입력·처리·출력의 기능을 표현한 것은?\n하향식 소프트웨어 개발을 위한 문서화 도구이다.\n기능과 자료의 의존 관계를 동시에 표현할 수 있다.\n기호, 도표 등을 사용하므로 보기 쉽고 이해하기도 쉽다.\n시스템의 기능을 여러 개의 고유 모듈로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것을 ○○○ Chart라고 한다.\n○○○ Chart의 종류.\n① 가시적 도표(Visual Table of Contents, 도식목차).\n② 총체적 도표(Overview Diagram, 총괄 도표, 개요 도표), ③ 세부적 도표(Detail Diagram, 상세도표).",
    "answer": "Answer 1 : HIPO\nAnswer 2 : Hirarchy Input Process Output"
  },
  {
    "question": "Question 52.\n시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어는?\nRumbaugh(OMT), Booch, Jacobson 등의 객체지향 방법론의 장점을 통합하였다.\nOMG(Object Managemonet Group)에서 표쥰으로 지정하였다.\n○○○의 구성 요소.\n① 사물(Thing).\n② 관계(Relationship).\n③ 다이어그램(Diagram).",
    "answer": "Answer 1 : UML\nAnswer 2 : Unified Modeling Language"
  },
  {
    "question": "Question 53.\n다이어그램 안에서 관계가 형성될 수 있는 대상들을 말하는 것은?\n모델을 구성하는 가장 중요한 기본 요소이다.",
    "answer": "Answer 1 : 사물\nAnswer 2 : Thing"
  },
  {
    "question": "Question 54.\n다음은 사물의 네 가지 종류 중 하나에 대한 설명이다.\n① 시스템의 개념적, 물리적 요소를 표현.\n② 클래스(Class), 유스케이스(Use Case), 컴포넌트(Component), 인터페이스(Interface), 노드(Node)등.",
    "answer": "Answer 1 : 구조 사물\nAnswer 2 : Structural Thing"
  },
  {
    "question": "Question 55.\n다음은 사물의 네 가지 종류 중 하나에 대한 설명이다.\n① 시간과 공간에 따른 요소들의 행위를 표현.\n② 상호작용(Interaction), 상태 머신(State Machine) 등.",
    "answer": "Answer 1 : 행동 사물\nAnswer 2 : Behavioral Thing"
  },
  {
    "question": "Question 56.\n다음은 사물의 네 가지 종류 중 하나에 대한 설명이다.\n① 요소들을 그룹으로 묶어서 표현.\n② 패키지(Package).",
    "answer": "Answer 1 : 그룹 사물\nAnswer 2 : Grouping Thing"
  },
  {
    "question": "Question 57.\n다음은 사물의 네 가지 종류 중 하나에 대한 설명이다.\n부가적인 설명이나 제약 조건 등을 표현.\n노트(Note).",
    "answer": "Answer 1 : 주해 사물\nAnswer 2 : Annotation Thing"
  },
  {
    "question": "Question 58.\n사물과 사물 사이의 연관성을 표현한 것은?",
    "answer": "Answer 1 : 관계\nAnswer 2 : Relationship"
  },
  {
    "question": "Question 59.\n관계의 종류에는 여섯 가지가 있다.\n다음은 그 중 하나에 대한 설명이다.\n2개 이상의 사물이 서로 관련되어 있는 관계는?\n사물 사이를 실선으로 연결하여 표현한다.\n방향성은 화살표로 표현한다.\n양방향 관계의 경우 화살표를 생략하고 실선으로만 연결한다.\n다중도를 선 위에 표기한다.",
    "answer": "Answer 1 : 연관 관계\nAnswer 2 : Association"
  },
  {
    "question": "Question 60.\n관계의 종류에는 여섯 가지가 있다.\n다음은 그 중 하나에 대한 설명이다.\n하나의 사물이 다른 사물에 포함되어 있는 관계는?\n포함하는 쪽(전체, Whole)과 포함되는 쪽(부분, Part)은 서로 독립적이다.\n포함되는 쪽(부분, Part)에서 포함하는 쪽(전체, Whole)으로 속이 빈 마름모를 연결하여 표현한다.",
    "answer": "Answer 1 : 집합 관계\nAnswer 2 : Aggregation"
  },
  {
    "question": "Question 61.\n관계의 종류에는 여섯 가지가 있다.\n다음은 그 중 하나에 대한 설명이다.\n집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계는?\n포함하는 쪽(전체, Whole)과 포함되는 쪽(부분, Part)은 서로 독립될 수 없고 생명주기를 함께한다.\n포함되는 쪽(부분, Part)에서 포함하는 쪽(전체, Whole)으로 속이 채워진 마음모를 연결하여 표현한다.",
    "answer": "Answer 1 : 포함 관계\nAnswer 2 : Composition"
  },
  {
    "question": "Question 62.\n관계의 종류에는 여섯 가지가 있다.\n다음은 그 중 하나에 대한 설명이다.\n하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계는?\n보다 일반적인 개념을 상위(부모), 보다 구체적인 개념을 하위(자식)라고 부른다.\n구체적(하위)인 사물에서 일반적(상위)인 사물쪽으로 속이 빈 화살표를 연결하여 표현한다.",
    "answer": "Answer 1 : 일반화 관계\nAnswer 2 : Generalization"
  },
  {
    "question": "Question 63.\n연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계는?\n하나의 사물과 다른 사물이 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계이다.\n영향을 주는 사물(이용자)이 영향을 받는 사물(제공자) 쪽으로 점선 화살표를 연결하여 표현한다.",
    "answer": "Answer 1 : 의존 관계\nAnswer 2 : Dependency"
  },
  {
    "question": "Question 64.\n사물이 할 수 있거나 해야 하는 기능으로, 서로를 그룹화 할 수 있는 관계는?\n사물에서 기능 쪽으로 속이 빈 점선 화살표를 연결하여 표현한다.",
    "answer": "Answer 1 : 실체화 관계\nAnswer 2 : Realization"
  },
  {
    "question": "Question 65.\n사물과 관계를 도형으로 표현한 것은?\n여러 관점에서 시스템을 가시화한 뷰(View)를 제공함으로써 의사소통에 도움을 준다.\n정적 모델링에서는 주로 구조적 ○○○을 사용한다.\n동적 모델링에서는 주로 행위 ○○○을 사용한다.",
    "answer": "Answer 1 : 다이어그램\nAnswer 2 : Diagram"
  },
  {
    "question": "Question 66.\n다음은 구조적(Structural) 다이어그램의 여섯 가지 종류 중 하나에 대한 설명이다.\n클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현함.",
    "answer": "Answer 1 : 클래스 다이어그램\nAnswer 2 : Class Diagram"
  },
  {
    "question": "Question 67.\n다음은 구조적(Structural) 다이어그램의 여섯 가지 종류 중 하나에 대한 설명이다.\n① 클래스에 속한 사물(객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객체 사이의 관계로 표현함.\n② 럼바우(Rumbaugh) 객체지향 분석 기법에서 객체 모델링에 활용됨.",
    "answer": "Answer 1 : 객체 다이어그램\nAnswer 2 : Object Diagram"
  },
  {
    "question": "Question 68.\n다음은 구조적(Structural) 다이어그램의 여섯 가지 종류 중 하나에 대한 설명이다.\n① 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현함.\n② 구현 단계에서 사용됨.",
    "answer": "Answer 1 : 컴포넌트 다이어그램\nAnswer 2 : Component Diagram"
  },
  {
    "question": "Question 69.\n다음은 구조적(Structural) 다이어그램의 여섯 가지 종류 중 하나에 대한 설명이다.\n① 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현함.\n② 구현 단계에서 사용됨.",
    "answer": "Answer 1 : 배치 다이어그램\nAnswer 2 : Deployment Diagram"
  },
  {
    "question": "Question 70.\n다음은 구조적(Structural) 다이어그램의 여섯 가지 종류 중 하나에 대한 설명이다.\n클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현함.",
    "answer": "Answer 1 : 복합체 구조 다이어그램\nAnswer 2 : Composite Structure Diagram"
  },
  {
    "question": "Question 71.\n다음은 구조적(Structural) 다이어그램의 여섯 가지 종류 중 하나에 대한 설명이다.\n유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현함.",
    "answer": "Answer 1 : 패키지 다이어그램\nAnswer 2 : Package Diagram"
  },
  {
    "question": "Question 72.\n다음은 행위(Behavioral) 다이어그램의 일곱 가지 종류 중 하나에 대한 설명이다.\n① 사용자의 요구를 분석하는 것으로, 기능 모델링 작업에 사용함.\n② 사용자(Actor)와 사용 사례(Use Case)로 구성됨.",
    "answer": "Answer 1 : 유스케이스 다이어그램\nAnswer 2 : Use Case Diagram"
  },
  {
    "question": "Question 73.\n다음은 행위(Behavioral) 다이어그램의 일곱 가지 종류 중 하나에 대한 설명이다.\n상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현함.",
    "answer": "Answer 1 : 순차 다이어그램\nAnswer 2 : Sequence Diagram"
  },
  {
    "question": "Question 74.\n다음은 행위(Behavioral) 다이어그램의 일곱 가지 종류 중 하나에 대한 설명이다.\n동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관 관계를 표현함.",
    "answer": "Answer 1 : 커뮤니케이션 다이어그램\nAnswer 2 : Communication Diagram"
  },
  {
    "question": "Question 75.\n다음은 행위(Behavioral) 다이어그램의 일곱 가지 종류 중 하나에 대한 설명이다.\n① 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현함.\n② 럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용됨.",
    "answer": "Answer 1 : 상태 다이어그램\nAnswer 2 : State Diagram"
  },
  {
    "question": "Question 76.\n다음은 행위(Behavioral) 다이어그램의 일곱 가지 종류 중 하나에 대한 설명이다.\n시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현함.",
    "answer": "Answer 1 : 활동 다이어그램\nAnswer 2 : Activity Diagram"
  },
  {
    "question": "Question 77.\n다음은 행위(Behavioral) 다이어그램의 일곱 가지 종류 중 하나에 대한 설명이다.\n상호 작용 다이어그램 간의 제어 흐름을 표현함.",
    "answer": "Answer 1 : 상호작용 개요 다이어그램\nAnswer 2 : Interaction Overview Diagram"
  },
  {
    "question": "Question 78.\n다음은 행위(Behavioral) 다이어그램의 일곱 가지 종류 중 하나에 대한 설명이다.\n객체 상태 변화와 시간 제약을 명시적으로 표현함.",
    "answer": "Answer 1 : 타이밍 다이어그램\nAnswer 2 : Timing Diagram"
  },
  {
    "question": "Question 79.\nUML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것은?\n길러멧(Guilemet)이라고 부르는 겹화살괄호(《》) 사이에 표현할 형태를 기술한다.\n주로 표현되는 형태.\n《include》 : 연결된 다른 UML 요소에 대해 포함 관계에 있는 경우.\n《extend》 : 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우.\n《interface》 : 인터페이스를 정의하는 경우.\n《exception》 : 예외를 정의하는 경우.\n《constructor》 : 생성자 역할을 수행하는 경우.",
    "answer": "Answer 1 : 스테레오 타입\nAnswer 2 : Stereotype"
  },
  {
    "question": "Question 80.\n사용자의 요구사항을 분석하여 개발될 시스템이 갖춰야 할 기능을 정리한 후 사용자와 함께 정리된 내용을 공유하기 위해 그림으로 표현하는 것은?\n개발될 시스템의 전반적인 형태를 기능에 초점을 맞춰 표현한다.",
    "answer": "Answer 1 : 기능 모델링"
  },
  {
    "question": "Question 81.\n사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한 것은?\n외부 요소와 시스템 간의 상호 작용을 확인할 수 있다.\n사용자의 요구사항을 분석하기 위한 도구로 사용된다.\n시스템의 범위를 파악할 수 있다.",
    "answer": "Answer 1 : 유스케이스 다이어그램\nAnswer 2 : Use Case Diagram"
  },
  {
    "question": "Question 82.\n사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것은?\n하나의 유스케이스 안에서 혹은 유스케이스 사이에 발생하는 복잡한 처리의 흐름을 명확하게 표현할 수 있다.\n자료 흐름도와 유사하다.",
    "answer": "Answer 1 : 활동 다이어그램\nAnswer 2 : Activity Diagram"
  },
  {
    "question": "Question 83.\n사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것은?\n시스템에 의해 처리되거나 생성될 객체들 사이에 어떤 관련이 있는지를 구조적인 관점(View)에서 표현한다.\n정적 모델링은 객체(Object)들을 클래스(Class)로 추상화하여 표현한다.\nUML을 아용한 정적 모델링의 대표적인 것이 클래스 다이어그램이다.",
    "answer": "Answer 1 : 정적 모델링"
  },
  {
    "question": "Question 84.\n클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 것은?\n시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램이다.\n시스템 구성 요소를 문서화하는 데 사용된다.",
    "answer": "Answer 1 : 클래스 다이어그램\nAnswer 2 : Class Diagram"
  },
  {
    "question": "Question 85.\n연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스는?\n두 클래스의 연관 관계를 나타내는 선의 가운데로부터 점선을 연관 클래스로 이어 표시한다.\n○○○의 이름은 연관 관계의 이름을 이용해 지정한다.",
    "answer": "Answer 1 : 연관 클래스"
  },
  {
    "question": "Question 86.\n시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현한 것은?\n시스템 내부 구성 요소들 간에 이루어지는 동작이라는 관점(View)에서 표현한다.\n시스템이 실행될 때 구성 요소들 간의 메시지 호출, 즉 오퍼레이션을 통한 상호 작용에 초점을 둔다.\n○○○의 종류.\n① 순차 다이어그램.\n② 커뮤니케이션 다이어그램.\n③ 상태 다이어그램.",
    "answer": "Answer 1 : 동적 모델링"
  },
  {
    "question": "Question 87.\n시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현한 것은?\n시스템이나 객체들의 상호 작용 과정에서 주고받는 메시지를 표현한다.\n각 동작에 참여하는 시스템이나 객체들의 수행 기간을 확인할 수 있다.\n클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호 작용을 표현한다.",
    "answer": "Answer 1 : 순차 다이어그램\nAnswer 2 : Sequence Diagram"
  },
  {
    "question": "Question 88.\n시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정과 객체들 간의 연관을 그림으로 표현한 것은?\n동작에 참여하는 객체들 사이의 관계를 파악하는 데 사용된다.\n클래스 다이어그램에서 관계가 제대로 표현됐는지 점검하는 용도로도 사용된다.\n초기에는 협업(Collaboration) 다이어그램이라고 불렸다.",
    "answer": "Answer 1 : 커뮤니케이션 다이어그램\nAnswer 2 : Communication Diagram"
  },
  {
    "question": "Question 89.\n객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현한 것은?\n객채의 상태란 객체가 갖는 속성 값의 변화를 의미한다.\n특정 객체가 어떤 이벤트에 의해 상태 변환 과정이 진행되는지 확인하는 데 사용된다.\n시스템에서 상태 변환 이벤트를 확인할 필요가 있는 객체만을 대상으로 그린다.",
    "answer": "Answer 1 : 상태 다이어그램\nAnswer 2 : State Diagram"
  },
  {
    "question": "Question 90.\n유스케이스나 클래스 등의 요소들을 그룹화한 패키지 간의 의존 관계를 표현한 것은?\n패키지는 또 다른 패키지의 요소가 될 수 있다.\n대규모 시스템에서 주요 요소 간의 종속성을 파악하는 데 사용한다.",
    "answer": "Answer 1 : 패키지 다이어그램\nAnswer 2 : Package Diagram"
  },
  {
    "question": "Question 91.\n소프트웨어 개발, 유지보수 등에 필요한 여러 가지 일들의 수행 방법과 이러한 일들을 효율적으로 수행하려는 과정에서 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것은?\n○○○의 목적은 소프트웨어의 생산성과 품질 향상이다.",
    "answer": "Answer 1 : 소프트웨어 개발 방법론"
  },
  {
    "question": "Question 92.\n정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리(Process) 중심의 방법론은?\n1960년대까지 가장 많이 적용되었던 소프트웨어 개발 방법론이다.\n쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적이다.\n복잡한 문제를 다루기 위해 분할과 정복(Divide and Conquer) 원리를 적용한다.\n○○○의 개발 절차.\n타당성 검토 단계 - > 계획 단계 - > 요구사항 단계 - > 설계 단계 - > 구현 단계 - > 시험 단계 - > 운용/유지보수 단계.",
    "answer": "Answer 1 : 구조적 방법론"
  },
  {
    "question": "Question 93.\n정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료(Data) 중심의 방법론은?\n정보 시스템 개발 주기를 이용하여 대규모 정보 시스템을 구축하는데 적합하다.\n○○○의 개발 절차.\n정보 전략 계획 수립 단계 - > 업무 영역 분석 단계 - > 업무 시스템 설계 단계 - > 업무 시스템 구축 단계.",
    "answer": "Answer 1 : 정보공학 방법론"
  },
  {
    "question": "Question 94.\n현실세계의 개체(Entoty)를 기계의 부품처럼 하나의 객체(Object)로 만들어 소프트웨어를 개발할 때 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론은?\n구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되었다.\n구성요소로는 객체, 클래스, 메시지 등이 있다.\n기본 원칙에는 캡슐화, 정보 은닉, 추상화, 상속성, 다형성 등이 있다.\n개발 절차는 요구 분석 단계 - > 설계 단계 - > 구현 단계 - > 테스트 및 검증 단계 - > 인도 단계를 거친다.",
    "answer": "Answer 1 : 객체지향 방법론"
  },
  {
    "question": "Question 95.\n기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론이다.\n컴포넌트의 재사용(Reusability)이 가능하여 시간과 노력을 절감할 수 있다.\n새로운 기능을 추가하는 것이 간단하여 확장성이 보장된다.\n유지 보수 비용을 최소화하고 생산성 및 품질을 향상 시킬 수 있다.\n이 방법론의 개발 절차는 개발 준비 단계 - 분석 단계 - 설계 단계 - 구현 단계 - 테스트 단계 - 전개 단계 - 인도 단계를 거친다.",
    "answer": "Answer 1 : 컴포넌트 기반 방법론\nAnswer 2 : CBD\nAnswer 3 : Component Based Design"
  },
  {
    "question": "Question 96.\n특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론이다.\n임베디드 소프트웨어를 만드는데 적합하다.\n영역공학과 응용공학으로 구분된다.\n영역공학 : 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역이다.\n응용공학 : 제품 요구 분석, 제품 설계, 제품을 구현하는 영역이다.\n영역 공학과 응용공학의 연계를 위해 제품의 요구사항, 아키텍처, 조립 생산이 필요하다.",
    "answer": "Answer 1 : 제품 계열 방법론"
  },
  {
    "question": "Question 97.\n이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것으로 소프트웨어 개발의 품질과 생산성을 높이기 위한 방법이다.\n또한 기존에 기발된 소프트웨어와 경험/지식 등을 새로운 소프트웨어에 적용한다.",
    "answer": "Answer 1 : 소프트웨어 재사용\nAnswer 2 : Software Reuse"
  },
  {
    "question": "Question 98.\n다음은 소프트웨어 재사용 방법의 두 가지 방법 중 하나에 대한 설명이다.\n전자 칩과 같은 소프트웨어 부품, 즉 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법으로, 블록 구성 방법이라고도 함.",
    "answer": "Answer 1 : 합성 중심\nAnswer 2 : Composition- Based"
  },
  {
    "question": "Question 99.\n다음은 소프트웨어 재사용 방법의 두 가지 방법 중 하나에 대한 설명이다.\n추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법으로, 패턴 구성 방법이라고도 함.",
    "answer": "Answer 1 : 생성 중심\nAnswer 2 : Generation- Based"
  },
  {
    "question": "Question 100.\n새로운 요구에 맞도록 기존 시스템을 이용하여 보다 나은 시스템을 구축하고 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 방법으로 유지보수 비용이 소프트웨어 개발 비용의 대부분을 차지하기 때문에 유지보수의 생산성 향상을 통해 소프트웨어 위기를 해결하는 방법이다.\n기존 소프트웨어의 데이터와 기능들의 개조 및 개선을 통해 유지보수성과 품질을 향상시키는 특징이 있다.\n또한 다음 네 가지의 이점을 가진다.\n① 소프트웨어의 품질 향상.\n② 소프트웨어의 생산성 증가.\n③ 소프트웨어의 수명 연장.\n④소프트웨어의 오류 감소.",
    "answer": "Answer 1 : 소프트웨어 재공학\nAnswer 2 : Software Reengineering"
  },
  {
    "question": "Question 101.\n소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 방법으로 객체지향 시스템, 구조적 시스템 등 다양한 시스템에서 활용되는 이 자동화 도구는 소프트웨어 생명 주기의 전체 단계를 연결하고 자동화하는 통합된 도구를 제공하는 것은?\n소프트웨어 개발 도구와 방법론이 결합되었으며 정형화된 구조 및 방법을 소프트웨어 개발에 적용하여 생산성 향상을 구현하였으며 다음 세 가지의 주요 기능을 가진다.\n① 소프트웨어 생명 주기 전 단계의 연결.\n② 다양한 소프트웨어 개발 모형 지원.\n③ 그래픽 지원.",
    "answer": "Answer 1 : CASE\nAnswer 2 : Computer Aided Software Engieering"
  },
  {
    "question": "Question 102.\n과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 비과학적인 방법은?",
    "answer": "Answer 1 : 하향식 비용 산정 기법"
  },
  {
    "question": "Question 103.\n조직 내에 있는 경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법으로, 가장 편리하고 신속하게 비용을 산정할 수 있으며, 의뢰자로부터 믿음을 얻을 수 있지만 개인적이고 주관적일 수 있는 기법은?",
    "answer": "Answer 1 : 전문가 감정 기법"
  },
  {
    "question": "Question 104.\n소프트웨어 비용 산정 기법 중 전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가들의 의견을 조합하여 산정하는 기법은?",
    "answer": "Answer 1 : 델파이 기법"
  },
  {
    "question": "Question 105.\n프로젝트의 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법은?",
    "answer": "Answer 1 : 상향식 비용 산정 기법"
  },
  {
    "question": "Question 106.\n소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?",
    "answer": "Answer 1 : LOC 기법\nAnswer 2 : source Line of Code 기법\nAnswer 3 : 원시 코드 라인 수 기법"
  },
  {
    "question": "Question 107.\nLOC 기법을 보완하기 위한 기법으로, 각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정한 기법은?",
    "answer": "Answer 1 : 개발 단계별 인월수 기법\nAnswer 2 : Effort Per Task 기법"
  },
  {
    "question": "Question 108.\n원시 프로그램의 규모인 LOC(원시 코드 라인 수)에 의한 비용 산정 기법이며, 개발할 소프트웨어의 규모(LOC)를 예측한 후 이를 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 비용을 산정하고, 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력(Man-Month)으로 나타낸다.\n보헴(Boehm)이 제안한 모형은?",
    "answer": "Answer 1 : COCOMO 모형\nAnswer 2 : COnstructive COst MOdel 모형"
  },
  {
    "question": "Question 109.\nCOCOMO의 소프트웨어 개발 유형 중 하나에 대한 설명이다.\n① 기관 내부에서 개발된 중, 소 규모의 소프트웨어.\n② 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용 등의 5만(50KDSI) 라인 이하의 소프트웨어를 개발하는 유형.\n③ 사무 처리용, 업무용, 과학용 응용 소프트웨어 개발에 적합하다는 세 가지 특징을 가지는 유형은?",
    "answer": "Answer 1 : 조직형\nAnswer 2 : Organic Mode"
  },
  {
    "question": "Question 110.\nCOCOMO의 소프트웨어 개발 유형 중 하나에 대한 설명이다.\n① 조직형과 내장형의 중간형 소프트웨어.\n② 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등의 30만(30KDSI) 라인 이하의 소프트웨어를 개발하는 유형.\n③ 컴파일러, 인터프리터와 같은 유틸리티 개발에 적합하다는 세 가지 특징을 가지는 유형은?",
    "answer": "Answer 1 : 반분리형\nAnswer 2 : Semi-Detached Mode"
  },
  {
    "question": "Question 111.\nCOCOMO의 소프트웨어 개발 유형 중 하나에 대한 설명이다.\n① 초대형 규모의 소프트웨어.\n② 트랜잭션 처리 시스템이나 운영체제 등의 30만(300KDSI) 라인 이사으이 소프트웨어를 개발하는 유형.\n③ 신호기 제어 시스템, 미사일 유도 시스템, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적합한 유형은?",
    "answer": "Answer 1 : 내장형\nAnswer 2 : Embedded Mode"
  },
  {
    "question": "Question 112.\nCOCOMO 모형의 종류 중 하나에 대한 설명이다.\n소프트웨어의 크기와 개발 유형만을 이용하여 비용을 산정하는 것은?",
    "answer": "Answer 1 : 기본형 COCOMO\nAnswer 2 : Basic COCOMO"
  },
  {
    "question": "Question 113.\nCOCOMO 모형의 종류 중 하나에 대한 설명이다.\n기본형 COCOMO의 공식을 토대로 사용하나, 다음 4가지 특성에 의해 비용을 산정하는 것은?\n① 제품의 특성, ② 컴퓨터의 특성, ③ 개발 요원 특성, ④프로젝트 특성",
    "answer": "Answer 1 : 중간형 COCOMO\nAnswer 2 : Intermediate COCOMO"
  },
  {
    "question": "Question 114.\nCOCOMO 모형의 종류 중 하나에 대한 설명이다.\n① 중간형 COCOMO를 보완하여 만들어진 모형.\n② 개발 공정별로 보다 자세하고 정확하게 노력을 산출하여 비용 산정.\n③ 소프트웨어 환경과구성 요소가 사전에 정의되어 있어야 하며, 개발 과정의 후반부에 주로 적용함 이라는 세 가지 특징을 가지는 COCOMO 모형의 종류는?",
    "answer": "Answer 1 : 발전형 COCOMO\nAnswer 2 : Detailed COCOMO"
  },
  {
    "question": "Question 115.\n소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형으로, 푸트남이 제안한 모형이다.\n생명 주기 예측 모형이라고도 한다.\n시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 하며, 대형 프로젝트의 노력 분포 산정이 이용되고, 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감소하는 모형은?",
    "answer": "Answer 1 : Putnam 모형"
  },
  {
    "question": "Question 116.\n소프트웨어의 기능을 증대시키는 요인(① 자료 입력(입력 양식), ② 정보 출력(출력 보고서), ③ 명령어(사용자 질의수), ④데이터 파일, ⑤ 필요한 외부 루틴과의 인터페이스)별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능 점수를 산출하며, 총 기능 점수와 영향도를 이용하여 기능 점수(FP)를 구한 후 이를 이용해서 비용을 산정하는 기법으로 알브레히트(Albrecht)가 제안한 모형은?",
    "answer": "Answer 1 : 기능 점수 모형\nAnswer 2 : FP 모형\nAnswer 3 : Function Point 모형"
  },
  {
    "question": "Question 117.\n비용 산정 자동화 추정 도구 중 하나로, Rayleigh- Norden 곡선과 putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구는?",
    "answer": "Answer 1 : SLIM"
  },
  {
    "question": "Question 118.\n비용 산정 자동화 추정 도구 중 하나로, 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구는?",
    "answer": "Answer 1 : ESTIMACS"
  },
  {
    "question": "Question 119.\n프로젝트의 프로세서를 이루는 소작업을 파악하고 예측된 노력을 각 소작업에 분배하여 소작업의 순서와 일정을 정하는 것으로, 여기에 사용되는 기능의 예시로는 WBS, PERT/CPM, 간트 차트 등이 있다.",
    "answer": "Answer 1 : 프로젝트 일정 계획\nAnswer 2 : Scheduling 계획"
  },
  {
    "question": "Question 120.\n프로젝트에 필요한 전체 작업의 상호 관계를 표시하는 네트워크를 말하며, 각 작업별로 ① 낙관적인 경우, ② 가능성이 있는 경우, ③ 비관적인 경우와 같이 단계를 나누어 종료 시기를 결정한다.\n개발 경험이 없어 소요 기간 예측이 어려운 프로젝트 일정 계획에 사용한다.",
    "answer": "Answer 1 : PERT\nAnswer 2 : Program Evaluation and Review Technique\nAnswer 3 : 프로그램 평가 및 검토 기술"
  },
  {
    "question": "Question 121.\n프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법이다.\n이 기법은 노드와 간선으로 구성된 네트워크로 노드는 작업을, 간선은 작업 사이의 전후 의존 관계를 나타낸다.",
    "answer": "Answer 1 : CPM\nAnswer 2 : Critical Path Method\nAnswer 3 : 임계 경로 기법"
  },
  {
    "question": "Question 122.\n프로젝트의 각 작업들이 언제 시작하고 언제 종료되는지에 대한 작업 일정을 막대 도표를 이용하려 표시하는 프로젝트 일정표를 말하는 것은?\n시간선(Time-Line) 차트라고도 한다.",
    "answer": "Answer 1 : 간트 차트\nAnswer 2 : Gantt Chart"
  },
  {
    "question": "Question 123.\n프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영하고, 확정된 소프트웨어 생명 주기와 개발 방법론에 맞춰 소프트웨어 개발 단계, 활동 작업, 절차 등을 정의하는 것은?\n절차는 다음의 세 단계를 거친다.\n① 프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영한다.\n② 개발 단계별 작업 및 절차를 소프트웨어 생명 주기에 맞춰 수립한다.\n③ 결정된 소프트웨어 개발 방법론의 개발 단계별 활동 목적, 작업 내용, 산출물에 대한 매뉴얼을 작성한다.",
    "answer": "Answer 1 : 소프트웨어 개발 방법론 결정"
  },
  {
    "question": "Question 124.\n주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발하기 위한 전반적은 활동을 일컷는 말이며, 다섯 가지의 관리 유형이 있다.\n① 일정 관리.\n② 비용 관리.\n③ 인력 관리.\n④위험 관리.\n⑤ 품질 관리.",
    "answer": "Answer 1 : 프로젝트 관리\nAnswer 2 : Project Management"
  },
  {
    "question": "Question 125.\n소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준을 의미하는 말로 주요 소프트웨어 개발 표준은 세 가지가 있다.\n① ISO/IEC 12207.\n② CMMI(능력 성숙도 통합 모델).\n③ SPICE(소프트웨어 처리 개선 및 능력 평가 기준).",
    "answer": "Answer 1 : 소프트웨어 개발 표준"
  },
  {
    "question": "Question 126.\nISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스를 의미하며, 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준을 제공한다.\n그리고 이것은 세 가지로 구분될 수 있다.\n① 기본 생명 주기 프로세스(획득, 공급, 개발, 운영, 유지보수 프로세스).\n② 지원 생명 주기 프로세스(품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결 프로세스).\n③ 조직 생명 주기 프로세스(관리, 기반 구조, 훈련, 개선 프로세스).",
    "answer": "Answer 1 : ISO/IEC 12207"
  },
  {
    "question": "Question 127.\n소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델로, 미국 카네기멜론 대학교의 소프트웨어 공학연구소(SEI)에서 개발하였다.\n이 모델은 다섯 가지의 단계를 가진다.\n① 초기(Initial) : 정의된 프로세스 없음(작업자 능력에 따라 성공 여부 결정).\n② 관리(Managed) : 규칙화된 프로세스(특정한 프로젝트 내의 프로세스 정의 및 수행).\n③ 정의(Defined) : 표준화된 프로세스(조직의 표준 프로세스를 활용하여 업무 수행).\n④정량적 관리(Quantitatively Managed) : 예측 가능한 프로세스(프로젝트를 정량적으로 관리 및 통제).\n⑤ 최적화(Optimizing) : 지속적 개선 프로세스(프로세스 역량 향상을 위해 지속적인 프로세스 개선.",
    "answer": "Answer 1 : CMMI\nAnswer 2 : Capability Maturity Model Integration"
  },
  {
    "question": "Question 128.\n정보 시스템 분야에서 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준이다.\n공식 명칭은 ISO/IEC 15504이다.\n이 표준은 다섯 가지의 범주를 가진다.\n① 고객-공급자(Customer-Supplier) 프로세스 : 소프트웨어를 개발하여 고객에게 전달하는 것을 지원하고, 소프트웨어의 정확한 운용 및 사용을 위한 프로세스로 구성된다.\n② 공학(Engineering) 프로세스 : 시스템과 소프트웨어 제품의 명세화, 구현, 유지보수를 하는데 사요오디는 프로세스로 구성됨.\n③ 지원(Support) 프로세스 : 소프트웨어 생명 주기에서 다른 프로세스에 의해 이용되는 프로세스로 구성됨.\n④관리(Management) 프로세스 : 소프트웨어 생명 주기에서 프로젝트 관리자에 의해 사용되는 프로세스로 구성됨.\n⑤ 조직(Organization) 프로세스 : 조직의 업무 목적 수립과 조직의 업무 목표 달성을 위한 프로세스로 구성됨.",
    "answer": "Answer 1 : SPICE\nAnswer 2 : Software Process Improvement and Capability dEtermination"
  },
  {
    "question": "Question 129.\n정보 시스템 분야에서 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준이다.\n공식 명칭은 ISO/IEC 15504이다.\n이 프로세스의 수행 능력 단계는 여섯 가지로 나뉜다.\n① 불완전(Incomplete) : 프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계.\n② 수행(Performed) : 프로세스가 수행되고 목적이 달성된 단계.\n③ 관리(Managed) : 정의된 자원 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계.\n④확립(Established) : 소프트웨어 공학 원칙에 기반하여 정의된 프로세스가 수행되는 단계.\n⑤ 예측(Predictable) : 프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해서 일관되게 수행되는 단계.\n⑥ 최적화(Optimizing) : 프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계.",
    "answer": "Answer 1 : SPICE\nAnswer 2 : Software Process Improvement and Capability dEtermination"
  },
  {
    "question": "Question 130.\n프로젝트 상황 및 특성에 맞도록 정의된 소프트웨어 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업을 말하며, 수행 절차는 다음의 다섯 단계를 거친다.\n① 프로젝트 특징 정의 - > ② 표준 프로세스 선정 및 검증 - > ③ 상위 수준의 커스텀마이징 - > ④세부 커스터마이징 - > ⑤ 테일러링 문서화.",
    "answer": "Answer 1 : 소프트웨어 개발 방법론 테일러링"
  },
  {
    "question": "Question 131.\n다음은 소프트웨어 개발 방법론 테일러링에서 어떤 기준에서 고려할 사항인지 서술하라.\n① 목표환경 : 시스템의 개발 환경과 유형이 서로 다른 경우 테일러링이 필요함.\n② 요구사항 : 프로젝트의 생명 주기 활동에서 개발, 운영, 유지보수 등 프로젝트에서 우선적으로 고려할 요구사항이 서로 다른 경우 테일러링이 필요함.\n③ 프로젝트 규모 : 비용, 인력, 기간 등 프로젝트의 규모가 서로 다른 경우 테일러링이 필요함.\n④보유 기술 : 프로세스, 개발 방법론, 산출물, 구성원의 능력 등이 서로 다른 경우 테일러링이 필요함.",
    "answer": "Answer 1 : 내부적 기준"
  },
  {
    "question": "Question 132.\n다음은 소프트웨어 개발 방법론 테일러링에서 어떤 기준에서 고려할 사항인지 서술하라.\n① 법적 제약사항 : 프로젝트별로 적용될 IT Compliance가 서로 다른 경우 테일러링이 필요함.\n② 표준 품질 기준 : 금융, 제도 등 분야별 표준 품질 기준이 서로 다른 경우 테일러링이 필요함.",
    "answer": "Answer 1 : 외부적 기준"
  },
  {
    "question": "Question 133.\n소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 손쉽게 구현할 수 있도록 여러 가지 기능들을 제공해주는 반제품 형태의 소프트웨어 시스템을 일컷는 것으로, 선행 사업자의 기술에 의존하지 않는 표준화된 개발 기반으로 인해 사업자 종속성이 해소된다.\n이 것의 주요 기능으로 예외 처리, 트랜잭션 처리, 메모리 공유, 데이터 소스 관리, 서비스 관리, 쿼리 서비스, 로깅 서비스, 사용자 인증 서비스가 있으며, 종류는 스프링 ○○○, 전자정부 ○○○, 닷넷 ○○○ 이 있다.",
    "answer": "Answer 1 : 소프트웨어 개발 프레임워크\nAnswer 2 : Framework"
  },
  {
    "question": "Question 134.\n자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크를 일컷는 말이며, 동적인 웹 사이트의 개발을 위해 다양한 서비스를 제공하고, 전자정보 표준 프레임워크의 기반 기술로 사용되고 있다.",
    "answer": "Answer 1 : 스프링 프레임워크\nAnswer 2 : Spring Framework"
  },
  {
    "question": "Question 135.\n대한민국의 공공부문 정보화 사업 시 효율적인 정보 시스템의 구축을 지원하기 위해 필요한 기능 및 아키텍처를 제공하는 프레임워크를 말하며, 공개된 기술을 활용함으로써 특정 업체의 종속성을 배제하고 사업별 공통 컴포넌트의 중복 개발을 방지한다.",
    "answer": "Answer 1 : 전자정부 프레임워크"
  },
  {
    "question": "Question 136.\nWindows 프로그램의 개발 및 실행환경을 제공하는 프레임워크를 말하며, Microsoft 사에서 통합 인터넷 전략을 위해 개발하였다.\n코드 실행을 관리하는 CLR(Common Language Runtime, 공용 언어 런타임)이라는 이름의 가상머신 상에서 작동한다.",
    "answer": "Answer 1 : 닷넷 프레임워크\nAnswer 2 : . NET Framework"
  },
  {
    "question": "Question 137.\n다음은 소프트웨어 개발 프레임워크의 네 가지 특성 중 하나의 내용이다.\n① 프레임워크는 캡술화를 통해 ○○○를 강화하고 설계 및 구현의 변경에 따른 영향을 최소화함으로써 소프트웨어의 품질을 향상시킴.\n② 프레임워크는 개발 표준에 의한 모듈화로 인해 유지 보수가 용이함.",
    "answer": "Answer 1 : 모듈화\nAnswer 2 : Modularity"
  },
  {
    "question": "Question 138.\n다음은 소프트웨어 개발 프레임워크의 네 가지 특성 중 하나의 내용이다.\n① 프레임워크는 재사용 가능한 모듈들을 제공함으로써 예산 절감, 생산성 향상, 품질 보증이 가능함.",
    "answer": "Answer 1 : 재사용성\nAnswer 2 : Reusability"
  },
  {
    "question": "Question 139.\n프레임워크는 다형성(Polymorphism)을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능함.",
    "answer": "Answer 1 : 확장성\nAnswer 2 : Extensibility"
  },
  {
    "question": "Question 140.\n개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생산성을 향상시킴.",
    "answer": "Answer 1 : 제어의 역흐름\nAnswer 2 : Inversion of control"
  },
  {
    "question": "Question 141.\n데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것을 의미하는 것은?",
    "answer": "Answer 1 : 데이터 저장소"
  },
  {
    "question": "Question 142.\n데이터 저장소 유형 중 하나로, 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화한 것은?",
    "answer": "Answer 1 : 논리 데이터 저장소"
  },
  {
    "question": "Question 143.\n데이터 저장소 유형 중 하나로, 논리 데이터저장소를 소프트웨어가 운용될 환경의 물리적 특성을 고려하여 실제 저장장치에 저장한 것을 의미하는 것은?",
    "answer": "Answer 1 : 물리 데이터저장소"
  },
  {
    "question": "Question 144.\n여러 사람에 의해 공동으로 사용될 데이터를 중복을 배제하여 통합하고, 쉽게 접근하여 처리할 수 있도록 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터를 말하는 것으로 다음 네 가지로 구분지어 정의할 수 있다.\n① 통합된 데이터(Integrated Data) : 자료의 중복을 배제한 데이터의 모임.\n② 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료.\n③ 운영 데이터(Operational Data) : 조직의 고유한 업무를 수행하는 데 반드시 필요한 자료.\n④공용 데이터(Shared Data) : 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료",
    "answer": "Answer 1 : 데이터베이스\nAnswer 2 : Database"
  },
  {
    "question": "Question 145.\n사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어를 말하는 것으로, 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템이다.",
    "answer": "Answer 1 : DBMS\nAnswer 2 : DataBase Manegement System\nAnswer 3 : 데이터베이스 관리 시스템"
  },
  {
    "question": "Question 146.\n다음은 DBMS의 필수 기능 세 가지 중 하나의 내용이다.\n데이터의 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능.",
    "answer": "Answer 1 : 정의 기능\nAnswer 2 : Definition 기능"
  },
  {
    "question": "Question 147.\n다음은 DBMS의 필수 기능 세 가지 중 하나의 내용이다.\n데이터 검색, 색인, 삽입, 삭제 등을 위해 인터페이스 수단을 제공하는 기능.",
    "answer": "Answer 1 : 조작 기능\nAnswer 2 : Manipulation 기능"
  },
  {
    "question": "Question 148.\n다음은 DBMS의 필수 기능 세 가지 중 하나의 내용이다.\n데이터의 무결성, 보안, 권한 검사, 병행 제어를 제공하는 기능.",
    "answer": "Answer 1 : 제어 기능\nAnswer 2 : Control 기능"
  },
  {
    "question": "Question 149.\n다음은 데이터의 독립성 중 하나로, 응용 프로그램과 데이터베이스를 독립시킴으로써, 데이터의 논리적 구조를 변경시키더라도 응용 프로그램은 영향을 받지 않음 이라는 특성을 가지는 것은?",
    "answer": "Answer 1 : 논리적 독립성"
  },
  {
    "question": "Question 150.\n다음은 데이터의 독립성 중 하나로, 응용 프로그램과 보조기억장치 같은 물리적 장치를 독립시킴으로써, 디스크를 추가/변경하더라도 응용 프로그램은 영향을 받지 않음.",
    "answer": "Answer 1 : 물리적 독립성"
  },
  {
    "question": "Question 151.\n데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것은?",
    "answer": "Answer 1 : 스키마\nAnswer 2 : Schema"
  },
  {
    "question": "Question 152.\n다음은 스키마의 세 가지 종류 중 하나의 내용이다.\n사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것은?",
    "answer": "Answer 1 : 외부 스키마"
  },
  {
    "question": "Question 153.\n다음은 스키마의 세 가지 종류 중 하나의 내용이다.\n① 데이터 베이스의 전체적인 논리적 구조.\n② 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로, 하나만 존재함.",
    "answer": "Answer 1 : 개념 스키마"
  },
  {
    "question": "Question 154.\n다음은 스키마의 세 가지 종류 중 하나의 내용이다.\n① 물리적 저장장치의 입장에서 본 데이터베이스 구조.\n② 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄.",
    "answer": "Answer 1 : 내부 스키마"
  },
  {
    "question": "Question 155.\n사용자의 요구를 분석하여 그것들을 컴퓨터에 저장할 수 있는 데이터베이스의 구조에 맞게 변형한 후 DBMS로 데이터베이스를 구현하여 일반 사용자들이 사용하게 하는 것은?",
    "answer": "Answer 1 : 데이터베이스 설계"
  },
  {
    "question": "Question 156.\n다음은 데이터베이스 설계 시 고려해야 되는 여섯 가지 사항 중 한 가지의 내용이다.\n삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 함.",
    "answer": "Answer 1 : 무결성"
  },
  {
    "question": "Question 157.\n다음은 데이터베이스 설계 시 고려해야 되는 여섯 가지 사항 중 한 가지의 내용이다.\n데이터베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 함.",
    "answer": "Answer 1 : 일관성"
  },
  {
    "question": "Question 158.\n다음은 데이터베이스 설계 시 고려해야 되는 여섯 가지 사항 중 한 가지의 내용이다.\n시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 함.",
    "answer": "Answer 1 : 회복"
  },
  {
    "question": "Question 159.\n다음은 데이터베이스 설계 시 고려해야 되는 여섯 가지 사항 중 한 가지의 내용이다.\n불법적인 데이터의 노출 또는 변경이나 손실로부터 보호할 수 있어야 함.",
    "answer": "Answer 1 : 보안"
  },
  {
    "question": "Question 160.\n다음은 데이터베이스 설계 시 고려해야 되는 여섯 가지 사항 중 한 가지의 내용이다.\n응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함.",
    "answer": "Answer 1 : 효율성"
  },
  {
    "question": "Question 161.\n다음은 데이터베이스 설계 시 고려해야 되는 여섯 가지 사항 중 한 가지의 내용이다.\n데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 함.",
    "answer": "Answer 1 : 데이터베이스 확장"
  },
  {
    "question": "Question 162.\n다음은 데이터베이스 설계 순서의 다섯 단계 중 하나이다.\n○○○ - 개념석 설계 - 논리적 설계 - 물리적 설계 - 구현.\n요구 조건 명세서 작성하는 단계는?",
    "answer": "Answer 1 : 요구 조건 분석"
  },
  {
    "question": "Question 163.\n다음은 데이터베이스 설계 순서의 다섯 단계 중 하나이다.\n요구 조건 분석 - ○○○ - 논리적 설계 - 물리적 설계 - 구현.\n개념 스키마, 트랜잭션 모델링, E- R 모델 단계는?",
    "answer": "Answer 1 : 개념적 설계"
  },
  {
    "question": "Question 164.\n다음은 데이터베이스 설계 순서의 다섯 단계 중 하나이다.\n요구 조건 분석 - 개념석 설계 - ○○○ - 물리적 설계 - 구현.\n목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계 단계는?",
    "answer": "Answer 1 : 논리적 설계"
  },
  {
    "question": "Question 165.\n다음은 데이터베이스 설계 순서의 다섯 단계 중 하나이다.\n요구 조건 분석 - 개념석 설계 - 논리적 설계 - ○○○ - 구현.\n목표 DBMS에 맞는 물리적 구조의 데이터로 변환.",
    "answer": "Answer 1 : 물리적 설계"
  },
  {
    "question": "Question 166.\n다음은 데이터베이스 설계 순서의 다섯 단계 중 하나이다.\n요구 조건 분석 - 개념석 설계 - 논리적 설계 - 물리적 설계 - ○○○.\n목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성.",
    "answer": "Answer 1 : 구현"
  },
  {
    "question": "Question 167.\n데이터베이스를 사용할 사람들로부터 필요한 용도를 파악하는 것으로, 데이터베이스 사용자에 따른 수행 업무와 필요한 데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건 등을 수집하고, 수집된 정보를 바탕으로 요구 조건 명세를 작성하는 것은?",
    "answer": "Answer 1 : 요구 조건 분석"
  },
  {
    "question": "Question 168.\n정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하려 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정은?",
    "answer": "Answer 1 : 개념적 설계\nAnswer 2 : 정보 모델링\nAnswer 3 : 개념화"
  },
  {
    "question": "Question 169.\n현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환(mapping)시키는 과정을 말하며, 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화한다.",
    "answer": "Answer 1 : 논리적 설계\nAnswer 2 : 데이터 모델링"
  },
  {
    "question": "Question 170.\n논리적 설계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정을 말하며, 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다.\n또한 저장 레코드의 형식, 순서, 접근 경로, 조회 집중 레코드 등의 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사한다.",
    "answer": "Answer 1 : 물리적 설계\nAnswer 2 : 데이터 구조화"
  },
  {
    "question": "Question 171.\n논리적 설계와 물리적 설계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정을 말하며, 사용하려는 특정 DBMS의 DDL(데이터 정의어)을 이용하여 데이터베이스 스키마를 기술한 후 컴파일하여 빈 데이터베이스 파일을 생성하고, 응용 프로그램을 위한 트랜잭션을 작성하거나 데이터베이스 접근을 위한 응용 프로그램을 작성하는 것은?",
    "answer": "Answer 1 : 데이터베이스 구현"
  },
  {
    "question": "Question 172.\n현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형이며, 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적 도구들로 구성되어 있다.\n또한 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위한 지능적 도구로 사용된다.\n이것의 구성 요소로 개체, 속성, 관계가 있다.",
    "answer": "Answer 1 : 데이터 모델"
  },
  {
    "question": "Question 173.\n현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정을 말하며, 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현하는 것은?\n또 다른 특징으로 현실 세계에 존재하는 개체를 인간이 이해할 수 잇는 정보 구조로 표현하기 때문에 정보 모델이라고도 한다.\n대표적인 모델로는 E-R 모델이 있다.",
    "answer": "Answer 1 : 개념적 데이터 모델"
  },
  {
    "question": "Question 174.\n개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정은?\n필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용하여 현실세계를 표현하며, 단순히 데이터 모델이라고 하면 이 모델을 의미한다.\n또한 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분한다.",
    "answer": "Answer 1 : 논리적 데이터 모델"
  },
  {
    "question": "Question 175.\n다음은 데이터 모델에 표시할 요소 세 가지 중 하나에 대한 설명이다.\n논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현.",
    "answer": "Answer 1 : 구조\nAnswer 2 : Structure"
  },
  {
    "question": "Question 176.\n다음은 데이터 모델에 표시할 요소 세 가지 중 하나에 대한 설명이다.\n데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구.",
    "answer": "Answer 1 : 연산\nAnswer 2 : Operation"
  },
  {
    "question": "Question 177.\n다음은 데이터 모델에 표시할 요소 세 가지 중 하나에 대한 설명이다.\n데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건.",
    "answer": "Answer 1 : 제약 조건\nAnswer 2 : Constraint"
  },
  {
    "question": "Question 178.\n데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체를 말한다.\n실세계에 독립적으로 존재하는 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 구성된다.\n독립적으로 존재하거나 그 자체로서도 구별이 가능하며, 유일한 식별자(Unique Identifier)에 의해 식별된다.",
    "answer": "Answer 1 : 개체\nAnswer 2 : Entity"
  },
  {
    "question": "Question 179.\n데이터베이스를 구성하는 가장 작은 논리적 단위는?\n파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다.\n속성은 개체를 구성하는 항목으로 개체의 특성을 기술한다.\n○○○의 수를 디그리(Degree) 또는 차수라고 한다.",
    "answer": "Answer 1 : 속성\nAnswer 2 : Attribute"
  },
  {
    "question": "Question 180.\n속성은 세 가지로 분류된다.\n① 업무 분석을 통해 정의한 속성.\n② 속성 중 가장 많고 일반적임.\n③ 업무로부터 분석한 속성이라도 업무상 코드로 정의한 속성은 ○○○에서 제외됨.",
    "answer": "Answer 1 : 기본 속성\nAnswer 2 : Basic Attribute"
  },
  {
    "question": "Question 181.\n속성은 세 가지로 분류된다.\n① 원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성.\n② 업무에 필요한 데이터 외에 데이터 모델링을 위해 업무를 규칙화하려고 속성을 새로 만들거나 변형하여 정의하는 속성.",
    "answer": "Answer 1 : 설계 속성\nAnswer 2 : Designed Attribute"
  },
  {
    "question": "Question 182.\n속성은 세 가지로 분류된다.\n① 다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성.\n② ○○○ 속성은 되도록 적은 수를 정의하는 것이 좋음.",
    "answer": "Answer 1 : 파생 속성\nAnswer 2 : Derived Attribute"
  },
  {
    "question": "Question 183.\n속성의 개체 구성 방식에 따라 세 가지로 분류된다.\n개체를 유일하게 식별할 수 있는 속성.",
    "answer": "Answer 1 : 기본키 속성\nAnswer 2 : Primary Ket Attribute"
  },
  {
    "question": "Question 184.\n속성의 개체 구성 방식에 따라 세 가지로 분류된다.\n다른 개체와의 관계에서 포함된 속성.",
    "answer": "Answer 1 : 외래키 속성\nAnswer 2 : Foreign Key Attribute"
  },
  {
    "question": "Question 185.\n속성의 개체 구성 방식에 따라 세 가지로 분류된다.\n개체에 포함되어 있고 기본키, 외래키에 포함되지 않은 속성.",
    "answer": "Answer 1 : 일반 속성"
  },
  {
    "question": "Question 186.\n개체와 개체 사이의 논리적인 연결을 의미하는 것은?",
    "answer": "Answer 1 : 관계\nAnswer 2 : Relationship"
  },
  {
    "question": "Question 187.\n관계의 종류에는 네 가지가 있다.\n① 두 개체 사이의 주·종 관계를 표현한 것.\n② 식별 관계와 비식별 관계가 있음.",
    "answer": "Answer 1 : 종속 관계\nAnswer 2 : Dependent Relationship"
  },
  {
    "question": "Question 188.\n관계의 종류에는 네 가지가 있다.\n두 개체 사이에 2번 이상의 종속 관계가 발생하는 관계.",
    "answer": "Answer 1 : 중복 관계\nAnswer 2 : Redundant Relationship"
  },
  {
    "question": "Question 189.\n관계의 종류에는 네 가지가 있다.\n개체가 자기 자신과 관계를 갖는 것으로, 순환 관계(Recursive Relationship)라고도 함.",
    "answer": "Answer 1 : 재귀 관계\nAnswer 2 : Recursive Relationship"
  },
  {
    "question": "Question 190.\n관계의 종류에는 네 가지가 있다.\n개체의 속성이나 구분자를 기준으로 개체의 특성을 분할하는 관계로, 배타 AND 관계와 배타 OP 관계로 구분함.",
    "answer": "Answer 1 : 배타 관계\nAnswer 2 : Exclusive Relationship"
  },
  {
    "question": "Question 191.\n개체와 개체 간의 관계를 기본 요소로 이용하여 현실 세계의 무질서한 데이터를 개념적인 논리 데이터로 표현하기 위한 방법은?\n이것은 1976년 피터 첸(Peter Chen)에 의해 제안되고 기본적인 구성 요소가 정립되었다.\n이것은 개념적 데이터 모델의 가장 대표적인 것이다.\n이것은 개체 타입(Entity Type)과 이들 간의 관계 타입(Relationship Type)을 이용해 현실 세계를 개념적으로 표현한다.\n이것은 데이터를 개체(Entity), 관계(Relatuinship), 속성(Attribute)로 묘사한다.",
    "answer": "Answer 1 : E-R 모델\nAnswer 2 : Entity-Relationship 모델\nAnswer 3 : 개체-관계 모델"
  },
  {
    "question": "Question 192.\n2차원적인 표(Table)를 이용해서 데이터 상호 관계를 정의하는 데이터베이스는?\n1970년 IBM에 근무하던 코드(E F。 Codd)에 의해 처음 제안되었다.\n개체(Entity)와 관계(Relationship)를 모두 릴레이션(Relation)이라는 표(Table)로 표현하기 때문에 개체를 표현하는 개체 릴레이션과 관계를 표현하는 관계 릴레이션이 존재한다.\n장점 : 간결하고 보기 편리하며, 다른 데이터베이스로의 변환이 용이하다.\n단점 : 성능이 다소 떨어진다.",
    "answer": "Answer 1 : 관계형 데이터베이스"
  },
  {
    "question": "Question 193.\n릴레이션을 구성하는 각각의 행을 말하는 것은?\n○○○은 속성의 모임으로 구성된다.\n파일 구조에서 레코드와 같은 의미이다.\n○○○의 수를 카디널리티(Cardnality) 또는 기수, 대응수라고 한다.",
    "answer": "Answer 1 : 튜플\nAnswer 2 : Tuple"
  },
  {
    "question": "Question 194.\n데이터베이스를 구성하는 가장 작은 논리적 단위는?\n파일 구조상의 데이터 항목 또는 데이터 필드에 해당된다.\n○○○은 개체의 특성을 기술한다.\n○○○의 수를 디그리(Degree) 또는 차수라고 한다.",
    "answer": "Answer 1 : 속성\nAnswer 2 : Attribute"
  },
  {
    "question": "Question 195.\n하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합을 말하는 것은?\n○○○은 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에도 이용된다.",
    "answer": "Answer 1 : 도메인\nAnswer 2 : Domain"
  },
  {
    "question": "Question 196.\n다음은 무엇의 특징인가?\n한 ○○○에는 똑같은 튜플이 포함될 수 없으므로 ○○○에 포함된 튜플들은 모두 상이하다.\n한 ○○○에 포함된 튜플 사이에는 순서가 없다.\n튜플들의 삽입, 삭제 등의 작업으로 인해 ○○○은 시간에 따라 변한다.\n○○○ 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.\n속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다.\n○○○을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 설정한다.\n속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다.",
    "answer": "Answer 1 : 릴레이션"
  },
  {
    "question": "Question 197.\n2차원적인 표(Table)를 이용해서 데이터 상호 관계를 정의하는 DB 구조를 말하는 것은?\n가장 널리 사용되는 데이터 모델이다.\n파일 구조처럼 구성한 테이블들을 하나의 DB로 묶어서 테이블 내에 있는 속성들 간의 관계(Relationship)를 설정하거나 테이블 간의 관계를 설정하여 이용한다.\n기본키(Primary Key)와 이를 참조하는 외래키(Foreign Key)로 데이터 간의 관계를 표현한다.\n게층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델이다.\n○○○의 대표적인 언어는 SQL이다.",
    "answer": "Answer 1 : 관계형 데이터 모델\nAnswer 2 : Relational Data Model"
  },
  {
    "question": "Question 198.\n데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말하는 것은?",
    "answer": "Answer 1 : 키\nAnswer 2 : Key"
  },
  {
    "question": "Question 199.\n릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합은?\n기본키로 사용할 수 있는 속성들을 말한다.\n○○○은 유일성(Unique)과 최소성(Minimality)을 모두 만족시켜야 한다.",
    "answer": "Answer 1 : 후보키\nAnswer 2 : Candidate Key"
  },
  {
    "question": "Question 200.\n후보키 중에서 특별히 선정된 주키(Main Key)를 말하는 것은?\n○○○는 중복된 값을 가질 수 없다.\n한 일레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다.\nNULL값을 가질 수 없다.",
    "answer": "Answer 1 : 기본키\nAnswer 2 : Primary Key"
  },
  {
    "question": "Question 201.\n후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미하는 것은?\n보조키라고도한다.",
    "answer": "Answer 1 : 대체키\nAnswer 2 : Alternate Key"
  },
  {
    "question": "Question 202.\n한 릴레이션 내에 있는 속성들의 집합으로 구성된 키를 말하는 것은?\n릴레이션을 구성하는 모든 튜플 중 ○○○로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.\n릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못한다.",
    "answer": "Answer 1 : 슈퍼키\nAnswer 2 : Super Key"
  },
  {
    "question": "Question 203.\n다른 릴레이션의 기본키를 참조하는 속성 도는 속성들의 집합을 의미하는 것은?\n한 릴레이션에 속상 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 ○○○라고 한다.\n○○○로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.",
    "answer": "Answer 1 : 외래키\nAnswer 2 : Foreign Key"
  },
  {
    "question": "Question 204.\n데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미하는 것은?",
    "answer": "Answer 1 : 무결성\nAnswer 2 : integrity"
  },
  {
    "question": "Question 205.\n데이터베이스에 들어 있는 데이터의 정확성을 보장하기 위해 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지하기 위한 제약 조건을 말하는 것은?",
    "answer": "Answer 1 : 무결성 제약 조건"
  },
  {
    "question": "Question 206.\n다음은 무결성의 8가지 종류 중 하나에 대한 설명이다.\n기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정.",
    "answer": "Answer 1 : 개체 무결성"
  },
  {
    "question": "Question 207.\n다음은 무결성의 8가지 종류 중 하나에 대한 설명이다.\n외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함.\n즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정.",
    "answer": "Answer 1 : 참조 무결성"
  },
  {
    "question": "Question 208.\n다음은 무결성의 8가지 종류 중 하나에 대한 설명이다.\n주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정.",
    "answer": "Answer 1 : 도메인 무결성"
  },
  {
    "question": "Question 209.\n다음은 무결성의 8가지 종류 중 하나에 대한 설명이다.\n속성 값들이 사용자가 정의한 제약조건에 만족되어야 한다는 규정.",
    "answer": "Answer 1 : 사용자 정의 무결성"
  },
  {
    "question": "Question 210.\n다음은 무결성의 8가지 종류 중 하나에 대한 설명이다.\n릴레이션의 특정 속성 값이 NULL이 될 수 없도록 하는 규정.",
    "answer": "Answer 1 : NULL 무결성"
  },
  {
    "question": "Question 211.\n다음은 무결성의 8가지 종류 중 하나에 대한 설명이다.\n릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 한다는 규정.",
    "answer": "Answer 1 : 고유 무결성"
  },
  {
    "question": "Question 212.\n다음은 무결성의 8가지 종류 중 하나에 대한 설명이다.\n하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다는 규정.",
    "answer": "Answer 1 : 키 무결성"
  },
  {
    "question": "Question 213.\n다음은 무결성의 8가지 종류 중 하나에 대한 설명이다.\n릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정.",
    "answer": "Answer 1 : 관계 무결성"
  },
  {
    "question": "Question 214.\n다음은 데이터 무결성을 강화하는 세 가지 방법 중 하나에 대한 설명이다.\n데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 프로그램 내에 추가함.",
    "answer": "Answer 1 : 애플리케이션"
  },
  {
    "question": "Question 215.\n다음은 데이터 무결성을 강화하는 세 가지 방법 중 하나에 대한 설명이다.\n트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가함.",
    "answer": "Answer 1 : 데이터베이스 트리거"
  },
  {
    "question": "Question 216.\n다음은 데이터 무결성을 강화하는 세 가지 방법 중 하나에 대한 설명이다.\n데이터베이스에 제약 조건을 설정하여 무결성을 유지함.",
    "answer": "Answer 1 : 제약 조건"
  },
  {
    "question": "Question 217.\n관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어는?\n릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하여, 피연산자와 연산 결과가 모두 릴레이션이다.\n질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.\n관계 데이터베이스에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있다.",
    "answer": "Answer 1 : 관계대수"
  },
  {
    "question": "Question 218.\n다음은 네 가지 순수 관계 연산자 중 하나에 대한 설명이다.\n① 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산.\n② 릴레이션의 행에 해당하는 튜플(Tuple)을 구하는 것으로 수평 연산이라고도 함.",
    "answer": "Answer 1 : Select"
  },
  {
    "question": "Question 219.\n다음은 네 가지 순수 관계 연산자 중 하나에 대한 설명이다.\n① 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산.\n② 연산 결과에 중복이 발생하면 중복이 제거됨.\n③ 릴레이션의 열에 해당하는 속성을 추출하는 것이므로 수직 연산자라고도 함.",
    "answer": "Answer 1 : Project"
  },
  {
    "question": "Question 220.\n다음은 네 가지 순수 관계 연산자 중 하나에 대한 설명이다.\n① 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산.\n② ○○○의 결과는 Cartesian Product(교차곱)를 수행한 다음 Select를 수행한 것과 같음.",
    "answer": "Answer 1 : Join"
  },
  {
    "question": "Question 221.\n다음은 네 가지 순수 관계 연산자 중 하나에 대한 설명이다.\nX⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산.",
    "answer": "Answer 1 : Division"
  },
  {
    "question": "Question 222.\n수학적 입합 이론에서 사용하는 연산자로, 합집합(UNION), 교집합(INTERSRCTION), 차집합(DIFFERENCE) 등이 속해있는 것은?",
    "answer": "Answer 1 : 일반 집합 연산자"
  },
  {
    "question": "Question 223.\n관계 데이터 연산을 표현하는 방법은?\n관계 데이터 모델의 제안자인 코드(E F。 Codd)가 수학의 Predicate Calculus(술어 해석)에 기반을 두고 관계 데이터베이스를 위해 제안했다.\n원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지닌다.\n원하는 정보를 정의할 때는 계산 수식을 사용한다.",
    "answer": "Answer 1 : 관계해석\nAnswer 2 : Relational Calculus"
  },
  {
    "question": "Question 224.\n테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복(Redundancy)으로 인해 테이블 조작 시 문제가 발생하는 현상을 의미하는 것은?",
    "answer": "Answer 1 : 이상\nAnswer 2 : Anomaly"
  },
  {
    "question": "Question 225.\n이상의 종류 중 하나로, 테이블에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상은?",
    "answer": "Answer 1 : 삽입 이상\nAnswer 2 : Insertion Anomaly"
  },
  {
    "question": "Question 226.\n이상의 종류 중 하나로, 테이블에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상은?",
    "answer": "Answer 1 : 삭제 이상\nAnswer 2 : Deletion Anomaly"
  },
  {
    "question": "Question 227.\n테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성(Inconsistency)이 생기는 현상은?",
    "answer": "Answer 1 : 갱신 이상\nAnswer 2 : Update Anomaly"
  },
  {
    "question": "Question 228.\n어떤 데이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라고 했을 때, 속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 ○○○ 또는 X가 Y를 함수적으로 결정한다고 하고, X→Y로 표기한다라고 할 때, ○○○에 들어갈 말은?",
    "answer": "Answer 1 : 함수적 종속\nAnswer 2 : Functional Dependency"
  },
  {
    "question": "Question 229.\nX→Y의 관계를 갖는 속성 X와 Y에서 X를 ○○○라 하고, Y를 종속자(Dependent)라고 할 때, ○○○에 들어갈 말은?",
    "answer": "Answer 1 : 결정자\nAnswer 2 : Determinant"
  },
  {
    "question": "Question 230.\nX→Y의 관계를 갖는 속성 X와 Y에서 X를 결정자(Determinant)라 하고, Y를 ○○○라고 할 때, ○○○에 들어갈 말은?",
    "answer": "Answer 1 : 종속자\nAnswer 2 : Dependent"
  },
  {
    "question": "Question 231.\n테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정을 말하는 것은?\n이것의 목적은 가능한 한 죽복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것이다.",
    "answer": "Answer 1 : 정규화\nAnswer 2 : Nomalization"
  },
  {
    "question": "Question 232.\n테이블 R에 속한 모든 속성의 도메인(Domain)이 원자 값(Atomic Value)만으로 되어 있는 정규형을 말하는 것은?\n테이블의 모든 속성 값이 원자 값으로만 되어 있는 정규형이다.",
    "answer": "Answer 1 : 제 1정규형"
  },
  {
    "question": "Question 233.\n테이블 R이 제 1정규형이고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형은?",
    "answer": "Answer 1 : 제 2정규형"
  },
  {
    "question": "Question 234.\n테이블 R이 제 2정규형이고 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속(Transitive Functional Dependency)을 만족하지 않는 정규형은?",
    "answer": "Answer 1 : 제 3정규형"
  },
  {
    "question": "Question 235.\n테이블 R에서 모든 결정자가 후보키(Candidate Key)인 정규형은?",
    "answer": "Answer 1 : BCNF"
  },
  {
    "question": "Question 236.\n테이블 R에 다중 값 종속(MVD; Multi Valued Dependancy) A→→B가 존재할 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형은?",
    "answer": "Answer 1 : 제 4정규형"
  },
  {
    "question": "Question 237.\n테이블 R의 모든 조인 종속(JD; Join Dependency)이 R의 후보키를 통해서만 성립되는 정규형은?",
    "answer": "Answer 1 : 제 5정규형"
  },
  {
    "question": "Question 238.\n시스템의 성능을 향상하고 개발 및 운영의 편의성 등을 높이기 위해 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위는?\n○○○를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다.\n과도한 ○○○는 오히려 성능을 저하시킬 수 있다.",
    "answer": "Answer 1 : 반정규화\nAnswer 2 : 비정규화\nAnswer 3 : Denormalization"
  },
  {
    "question": "Question 239.\n두 개의 테이블이 조인(Join)되어 사용되는 경우가 많을 경우 성능 향상을 위해 아예 하나의 테이블로 만들어 사용하는 것은?\n○○○을 고려하는 경우.\n① 두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우.\n② 항상 두 개의 테이블을 이용하여 조회를 수행하는 경우.",
    "answer": "Answer 1 : 테이블 통합"
  },
  {
    "question": "Question 240.\n테이블을 수직 또는 수평으로 분할하는 것은?\n수평 분할.\n① 레코드(Record)를 기준으로 테이블을 분할하는 것.\n② 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할함.\n수직 분할.\n① 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할하는 것.\n② 종류 : 갱신 위주의 속성 분할, 자주 조회되는 속성 분할, 크기가 큰 속성 분할, 보안을 적용해야 하는 속성 분할.",
    "answer": "Answer 1 : 테이블 분할"
  },
  {
    "question": "Question 241.\n작업의 효율성을 향상시키기 위해 테이블을 추가하는 것은?\n○○○를 하는 경우.\n① 여러 테이블에서 데이터를 추출해서 사용해야 할 경우.\n② 다른 서버에 저장된 테이블을 이용해야 하는 경우.\n○○○ 방법.\n① 집계 테이블의 추가 : 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거(Trigger)를 설정하여 사용하는 것.\n② 진행 테이블의 추가 : 이력 관리 등의 목적으로 추가하는 테이블.\n③ 특정 부분만을 포함하는 테이블의 추가 : 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성.",
    "answer": "Answer 1 : 중복 테이블 추가"
  },
  {
    "question": "Question 242.\n조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것은?\n○○○하면 데이터의 무결성 확보가 어렵고, 디스크 공간이 추가로 필요하다.\n○○○하는 경우.\n① 조인이 자주 발생하는 속성인 경우.\n② 접근 경로가 복잡한 속성인 경우.\n③ 액세스의 조건으로 자주 사용되는 속성인 경우.\n④기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우.",
    "answer": "Answer 1 : 중복 속성 추가"
  },
  {
    "question": "Question 243.\n시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스는?\n○○○ 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블이다.\n○○○가 생성되면 데이터 사전(data Dictionary)에 저장되기 때문에 좁은 의미로는 ○○○를 데이터 사전이라고 한다.",
    "answer": "Answer 1 : 시스템 카탈로그\nAnswer 2 : System Catalog"
  },
  {
    "question": "Question 244.\n시스템 카탈로그에 저장된 정보를 의미하는 것은?\n○○○의 유형에는 네 가지가 있다.\n① 데이터베이스 객체 정보 : 테이블(Table), 인덱스(Index), 뷰(View) 등의 구조 및 통계 정보.\n② 사용자 정보 : 아이디, 패스워드, 접근 권한 등.\n③ 테이블의 무결성 제약 조건 정보 : 기본키, 외래키, NULL 값 허용 여부 등.\n④함수, 프로시저, 트리거 등에 대한 정보.",
    "answer": "Answer 1 : 메타 데이터\nAnswer 2 : Meta-Data"
  },
  {
    "question": "Question 245.\n데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템은?\n시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있지만 ○○○는 시스템만 접근할 수 있다.",
    "answer": "Answer 1 : 데이터 디렉터리\nAnswer 2 : Data Directory"
  },
  {
    "question": "Question 246.\n데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미하는 것은?\n데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용된다.\n사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용된다.",
    "answer": "Answer 1 : 트랜잭션\nAnswer 2 : Transaction"
  },
  {
    "question": "Question 247.\n다음은 트랜잭션의 네 가지 특성 중 하나에 대한 설명이다.\n트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 한다.",
    "answer": "Answer 1 : 원자성\nAnswer 2 : Atomicity"
  },
  {
    "question": "Question 248.\n다음은 트랜잭션의 네 가지 특성 중 하나에 대한 설명이다.\n트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.",
    "answer": "Answer 1 : 일관성\nAnswer 2 : Consistency"
  },
  {
    "question": "Question 249.\n다음은 트랜잭션의 네 가지 특성 중 하나에 대한 설명이다.\n둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.",
    "answer": "Answer 1 : 독립성\nAnswer 2 : Isolation\nAnswer 3 : 격리성, 순차성"
  },
  {
    "question": "Question 250.\n다음은 트랜잭션의 네 가지 특성 중 하나에 대한 설명이다.\n성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.",
    "answer": "Answer 1 : 영속성\nAnswer 2 : Durability\nAnswer 3 : 지속성"
  },
  {
    "question": "Question 251.\n프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석하는 것은?\n○○○을 통해 많은 트랜잭션이 몰리는 테이블을 파악할 수 있으므로 디스크 구성 시 유용한 자료로 활용할 수 있다.",
    "answer": "Answer 1 : CRUD 분석"
  },
  {
    "question": "Question 252.\nCRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하여 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB의 용량 산정 및 구조의 최적화를 목적으로 하는 것은?\n○○○은 업무 개발 담당자가 수행한다.\n○○○을 통해 프로세스가 과도하게 접근하는 테이블을 확인할 수 있으며, 이러한 집중 접근 테이블을 여러 디스크에 분산 배치함으로써 디스크 입·출력 향상을 통한 성능 향상을 가져올 수 있다.",
    "answer": "Answer 1 : 트랜잭션 분석"
  },
  {
    "question": "Question 253.\n단위 프로세스와 CRUD 매트릭스를 이용하여 작성하는 것은?\n구성요소로는 단위 프로세스, CRUD 연산, 테이블명, 컬럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등이 있다.",
    "answer": "Answer 1 : 트랜잭션 분석서"
  },
  {
    "question": "Question 254.\n데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조는?\n레코드가 저장된 물리적 구조에 접근하는 방법을 제공한다.\n○○○를 통해서 파일의 레코드에 빠르게 액세스 할 수 있다.\n레코드의 삽입과 삭제가 수시로 일어나는 경우에는 ○○○의 개수를 최소로 하는 것이 효율적이다.",
    "answer": "Answer 1 : 인덱스\nAnswer 2 : Index"
  },
  {
    "question": "Question 255.\n다음은 인덱스(Index)의 다섯 가지 종류 중 하나에 대한 설명이다.\n인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것.",
    "answer": "Answer 1 : 트리 기반 인덱스"
  },
  {
    "question": "Question 256.\n다음은 인덱스(Index)의 다섯 가지 종류 중 하나에 대한 설명이다.\n인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법.",
    "answer": "Answer 1 : 비트맵 인덱스"
  },
  {
    "question": "Question 257.\n다음은 인덱스(Index)의 다섯 가지 종류 중 하나에 대한 설명이다.\n컬럼의 값 대신 컬럼에 특정 함수(Function)나 수식(Expression)을 적용하여 산출된 값을 사용하는 것.",
    "answer": "Answer 1 : 함수 기반 인덱스"
  },
  {
    "question": "Question 258.\n다음은 인덱스(Index)의 다섯 가지 종류 중 하나에 대한 설명이다.\n개발자가 필요한 인덱스를 직접 만들어 사용하는 것.",
    "answer": "Answer 1 : 도메인 인덱스"
  },
  {
    "question": "Question 259.\n다음은 특별한 두 방식의 인덱스 중 하나에 대한 설명이다.\n① 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식.\n② 실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있음.",
    "answer": "Answer 1 : 클러스터드 인덱스\nAnswer 2 : Clustered Index"
  },
  {
    "question": "Question 260.\n다음은 특별한 두 방식의 인덱스 중 하나에 대한 설명이다.\n① 인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식.\n② 데이터 삽입, 삭제 발생 시 순서 유지를 위한 데이터 재정렬이 필요없어 속도가 빠름.",
    "answer": "Answer 1 : 넌클러스터드 인덱스\nAnswer 2 : Non-Clustered Index"
  },
  {
    "question": "Question 261.\n사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블을 말하는 것은?\n저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주된다.\n○○○를 통해서만 데이터에 접근하게 하면 ○○○에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다.\n○○○가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 ○○○를 기초로 정의된 다른 ○○○도 자동으로 삭제된다.\n○○○를 정의할 때는 CREATE문, 제거할 때는 DROP문을 사용한다.\n○○○의 장점 : 논리적 데이터 독립성을 제공함, 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해줌, 사용자의 데이터 관리를 간단하게 해줌, 접근 제어를 통한 자동 보안이 제공됨.\n단점 : 독립적인 인덱스를 가질 수 없음, ○○○의 정의를 변경할 수 없음, ○○○로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름.",
    "answer": "Answer 1 : 뷰\nAnswer 2 : View"
  },
  {
    "question": "Question 262.\n데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법은?\n○○○ 된 테이블은 데이터 조회 속도를 향상시키지만 입력, 수정, 삭제에 대한 작업 성능을 저하시킨다.\n○○○는 데이터의 분포도가 넓을수록 유리하다.\n데이터 분포도가 넓은 테이블을 ○○○ 하면 저장 공간을 절약할 수 있다.\n처리 범위가 넓은 경우에는 단일 테이블 ○○○을, 조인이 많이 발생하는 경우에는 다중 테이블 ○○○을 사용한다.",
    "answer": "Answer 1 : 클러스터\nAnswer 2 : Cluster ○○○안에는 클러스터링"
  },
  {
    "question": "Question 263.\n데이터베이스에서 ○○○은 대용량의 테이블이나 인덱스를 작은 논리적 단위인 ○○○으로 나누는 것을 말한다.\n대용량 DB의 경우 몇 개의 중요한 테이블에만 집중되어 데이터가 증가되므로, 이런 테이블들을 작은 단위로 나눠 분산시키면 성능 저하를 방지할 뿐만 아니라 데이터 관리도 쉬워진다.\n데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 ○○○별로 수행된다.",
    "answer": "Answer 1 : 파티션\nAnswer 2 : Partition"
  },
  {
    "question": "Question 264.\n다음은 ○○○의 여섯 가지 장점이다.\n① 데이터 접근 시 액세스 범위를 줄여 쿼리 성능이 향상됨.\n② ○○○별로 데이터가 분산되어 저장되므로 디스크의 성능이 향상됨.\n③ ○○○별로 백업 및 복구를 수행하므로 속도가 빠름.\n④시스템 장애 시 데이터 손상 정도를 최소화할 수 있음.\n⑤ 데이터 가용성이 향상됨.\n⑥ ○○○ 단위로 입·출력을 분산시킬 수 있음.",
    "answer": "Answer 1 : 파티션\nAnswer 2 : Partition"
  },
  {
    "question": "Question 265.\n다음은 ○○○의 세 가지 단점이다.\n① 하나의 테이블을 세분화하여 관리하므로 세심한 관리가 요구됨.\n② 테이블간 조인에 대한 비용이 증가함.\n③ 용량이 작은 테이블에 ○○○을 수행하면 오히려 성능이 저하됨.",
    "answer": "Answer 1 : 파티션\nAnswer 2 : Partition"
  },
  {
    "question": "Question 266.\n다음은 파티션의 세 가지 종류 중 하나에 대한 설명이다.\n지정한 열의 값을 기준으로 분할함.",
    "answer": "Answer 1 : 범위 분할\nAnswer 2 : Range Partitioning"
  },
  {
    "question": "Question 267.\n다음은 파티션의 세 가지 종류 중 하나에 대한 설명이다.\n① 해시 함수를 적용한 결과 값에 따라 데이터를 분할함.\n② 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로, 데이터를 고르게 분산할 때 유용함.\n③ 고객번호, 주민번호 등과 같이 데이터가 고른 컬럼에 효과적임.",
    "answer": "Answer 1 : 해시 분할\nAnswer 2 : Hash Partitioning"
  },
  {
    "question": "Question 268.\n다음은 파티션의 세 가지 종류 중 하나에 대한 설명이다.\n① 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식.\n② 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용함.",
    "answer": "Answer 1 : 조합 분할\nAnswer 2 : Composite Partitioning"
  },
  {
    "question": "Question 269.\n데이터가 저장될 공간을 정의하는 것은?\n○○○ 할 때는 테이블에 저장될 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영해야 한다.\n○○○의 목적.\n① 데이터베이스의 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높인다.\n② 디스크의 특성을 고려하여 설계함으로써 디스크의 입·출력 부하를 분산시키고 채널의 병목 현상을 최소화한다.",
    "answer": "Answer 1 : 데이터베이스 용량 설계"
  },
  {
    "question": "Question 270.\n논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 사이트(Site)에 분산된 데이터베이스를 말하는 것은?\n데이터의 처리나 이용이 많은 지역에 데이터베이스를 위치시킴으로써 데이터의 처리가 가능한 해당 지역에서 해결될 수 있도록 한다.\n애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적으로 한다.",
    "answer": "Answer 1 : 분산 데이터베이스 설계"
  },
  {
    "question": "Question 271.\n다음은 분산 데이터베이스의 네 가지 목표 중 하나에 대한 설명이다.\n액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있다.",
    "answer": "Answer 1 : 위치 투명성\nAnswer 2 : Location Transparency"
  },
  {
    "question": "Question 272.\n다음은 분산 데이터베이스의 네 가지 목표 중 하나에 대한 설명이다.\n동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행한다.",
    "answer": "Answer 1 : 중복 투명성\nAnswer 2 : Replication Transparency"
  },
  {
    "question": "Question 273.\n다음은 분산 데이터베이스의 네 가지 목표 중 하나에 대한 설명이다.\n분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다.",
    "answer": "Answer 1 : 병행 투명성\nAnswer 2 : Concurrency Transparency"
  },
  {
    "question": "Question 274.\n다음은 분산 데이터베이스의 네 가지 목표 중 하나에 대한 설명이다.\n트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다.",
    "answer": "Answer 1 : 장애 투명성\nAnswer 2 : Tailure Transparency"
  },
  {
    "question": "Question 275.\n다음은 분산 설계 방법의 세 가지 방법 중 하나에 대한 설명이다.\n데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치하는 방법.",
    "answer": "Answer 1 : 테이블 위치 분산"
  },
  {
    "question": "Question 276.\n다음은 분산 설계 방법의 세 가지 방법 중 하나에 대한 설명이다.\n① 테이블의 데이터를 분할하여 분산시키는 것.\n② 분할 규칙 : 완전성(Completeness), 재구성(Reconstruction), 상호 중첩 배제(Disjointness).\n③ 주요 분할 방법.\n- 수평 분할 : 특정 속성의 값을 기준으로 행(Row) 단위로 분할.\n- 수직 분할 : 데이터 컬럼(속성) 단위로 분할.",
    "answer": "Answer 1 : 분할\nAnswer 2 : Fragmentation"
  },
  {
    "question": "Question 277.\n다음은 분산 설계 방법의 세 가지 방법 중 하나에 대한 설명이다.\n① 동일한 분할을 여러 개의 서버에 생성하는 분산 방법.\n② 중복이 없는 ○○○과 중복이 있는 ○○○으로 나뉨.",
    "answer": "Answer 1 : 할당\nAnswer 2 : Allocation"
  },
  {
    "question": "Question 278.\n시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것은?\n○○○를 수행하면 하나 이상의 데이터베이스가 항상 같은 상태를 유지하므로 데이터베이스에 문제가 발생하면 복제된 데이터베이스를 이용하여 즉시 문제를 해결할 수 있다.\n여러 개의 데이터베이스를 동시에 관리하므로 사용자가 수행하는 작업은 데이터베이스 이중화 시스템에 연결된 다른 데이터베이스에도 동일하게 적용된다.\n애플리케이션을 여러 개의 데이터베이스에서 분산 처리하므로 데이터베이스의 부하를 줄일 수 있다.\n○○○를 이용하면 손쉽게 백업 서버를 운영할 수 있다.",
    "answer": "Answer 1 : 데이터베이스 이중화\nAnswer 2 : Database Replication"
  },
  {
    "question": "Question 279.\n다음은 데이터베이스 이중화의 두 가지 분류 중 하나에 대한 설명이다.\n트랜잭션 수행 중 데이터 변경이 발생하면 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용되도록 하는 기법.",
    "answer": "Answer 1 : Eager 기법"
  },
  {
    "question": "Question 280.\n다음은 데이터베이스 이중화의 두 가지 분류 중 하나에 대한 설명이다.\n① 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달되는 기법.\n② 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주됨.",
    "answer": "Answer 1 : Lazy 기법"
  },
  {
    "question": "Question 281.\n다음은 데이터베이스 이중화 구성 방법 두 가지 중 하나에 대한 설명이다.\n① 한 DB가 활성 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활성 DB에 장애가 발생하면 대기 상태에 있던 DB가 자동으로 모든 서비스를 대신 수행함.\n② 구성 방법과 관리가 쉬워 많은 기업에서 이용됨.",
    "answer": "Answer 1 : 활동-대기 방법\nAnswer 2 : Active-Standby"
  },
  {
    "question": "Question 282.\n다음은 데이터베이스 이중화 구성 방법 두 가지 중 하나에 대한 설명이다.\n① 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공함.\n② 두 DB가 모두 처리를 하기 때문에 처리율이 높지만 구성 방법 및 설정이 복잡함.",
    "answer": "Answer 1 : 활동-활동 방법\nAnswer 2 : Active-Active"
  },
  {
    "question": "Question 283.\n두 대 이상의 서버를 하나의 서버처럼 운영하는 기술은?\n서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공한다.",
    "answer": "Answer 1 : 클러스터링\nAnswer 2 : Clustering"
  },
  {
    "question": "Question 284.\n다음은 클러스터링의 두 가지 종류 중 하나에 대한 설명이다.\n① 하나의 서버에 장애가 발생하면 다른 노드(서버)가 받아 처리하여 서비스 중단을 방지하는 방식.\n② 일반적으로 언급되는 클러스터링이 ○○○임.",
    "answer": "Answer 1 : 고가용성 클러스터링"
  },
  {
    "question": "Question 285.\n다음은 클러스터링의 두 가지 종류 중 하나에 대한 설명이다.\n전체 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리하는 방식.",
    "answer": "Answer 1 : 병렬 처리 클러스터링"
  },
  {
    "question": "Question 286.\n비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미하는 것은?\n예) 장애 발생 후 6시간 내 복구 가능.",
    "answer": "Answer 1 : RTO\nAnswer 2 : Recovery Time Objective\nAnswer 3 : 목표 복구 시간"
  },
  {
    "question": "Question 287.\n비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점을 의미하는 것은?\n예) 장애 발생 전인 지난 주 금요일에 백업시켜 둔 복원 시점으로 복구 가능.",
    "answer": "Answer 1 : RPO\nAnswer 2 : Recovery Point Objective\nAnswer 3 : 목표 복구 시점"
  },
  {
    "question": "Question 288.\n데이터베이스의 일부 또는 전체에 대해서 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술은?\n보안을 위한 데이터 단위는 테이블 전체로부터 특정 테이블의 특정 행과 열에 있는 데이터 값에 이르기까지 다양하다.",
    "answer": "Answer 1 : 데이터베이스 보안"
  },
  {
    "question": "Question 289.\n데이터를 보낼 때 송신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것은?",
    "answer": "Answer 1 : 암호화\nAnswer 2 : Encryption"
  },
  {
    "question": "Question 290.\n암호문을 원래의 평문으로 바꾸는 과정은?",
    "answer": "Answer 1 : 복호화\nAnswer 2 : Decryption"
  },
  {
    "question": "Question 291.\n데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것은?\n○○○ 3요소.\n① ○○○ 정책.\n② ○○○ 메커니즘.\n③ ○○○ 보안모델.",
    "answer": "Answer 1 : 접근통제"
  },
  {
    "question": "Question 292.\n다음은 접근통제 기술의 세 가지 정책 중 하나에 대한 설명이다.\n① 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식.\n② 데이터 소유자가 접근통제 권한을 지정하고 제어함.\n③ 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있음.",
    "answer": "Answer 1 : 임의 접근통제\nAnswer 2 : DAC\nAnswer 3 : Discretionary Access Control"
  },
  {
    "question": "Question 293.\n다음은 접근통제 기술의 세 가지 정책 중 하나에 대한 설명이다.\n① 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식.\n② 시스템이 접근 통제 권한을 지정함.\n③ 데이터베이스 객체별로 보안 등급을 부여할 수 있음.\n④사용자별로 인가 등급을 부여할 수 있음.",
    "answer": "Answer 1 : 강제 접근통제\nAnswer 2 : MAC\nAnswer 3 : Mandatory Access Control"
  },
  {
    "question": "Question 294.\n다음은 접근통제 기술의 세 가지 정책 중 하나에 대한 설명이다.\n① 사용자의 역할에 따라 접근 권한을 부여하는 방식.\n② 중앙관리자가 접근통제 권한을 지정함.\n③ 임의 접근통제와 강제 접근통제의 단점을 보완하였음.\n④다중 프로그래밍 환경에 최적화된 방식.",
    "answer": "Answer 1 : 역할기반 접근통제\nAnswer 2 : RBAC\nAnswer 3 : Role Based Access Control"
  },
  {
    "question": "Question 295.\n어떤 주체가(Who)가 언제(When), 어디서(Where), 어떤 객체(What)에게, 어떤 행위(How)에 대한 허용 여부를 정의하는 것은?",
    "answer": "Answer 1 : 접근통제 정책"
  },
  {
    "question": "Question 296.\n다음은 접근 통제 정책의 세 가지 종류 중 하나에 대한 설명이다.\n① 주체나 그룹의 신분에 근거하여 객체의 접근을 제한하는 방법으로 IBP와 GBP가 있음.\n② IBP(Individaul-Based Policy) : 최소 권한 정책으로, 단일 주체에게 하나의 객체에 대한 허가를 부여함.\n③ GBP(Group-Based Policy) : 복수 주체에 하나의 객체에 대한 허가를 부여함.",
    "answer": "Answer 1 : 신분 기반 정책"
  },
  {
    "question": "Question 297.\n다음은 접근 통제 정책의 세 가지 종류 중 하나에 대한 설명이다.\n① 주체가 갖는 권한에 근거하여 객체의 접근을 제한하는 방법으로, MLP와 CBP가 있음.\n② MLP(Multi-Level Policy) : 사용자나 객체별로 지정된 기밀 분류에 따른 정책.\n③ CBP(Compartment-Based Policy) : 집단별로 지정된 기밀 허가에 따른 정책.",
    "answer": "Answer 1 : 규칙 기반 정책"
  },
  {
    "question": "Question 298.\n다음은 접근 통제 정책의 세 가지 종류 중 하나에 대한 설명이다.\nGBP의 변형된 정책으로, 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한하는 방법.",
    "answer": "Answer 1 : 역할 기반 정책"
  },
  {
    "question": "Question 299.\n정의된 접근통제 정책을 구현하는 기술적인 방법은?\n○○○에는 접근통제 목록, 능력 리스트, 보안 등급, 패스워드, 암호화 등이 있다.",
    "answer": "Answer 1 : 접근통제 매커니즘"
  },
  {
    "question": "Question 300.\n보안 정책을 구현하기 위한 정형화된 모델은?",
    "answer": "Answer 1 : 접근통제 보안 모델"
  },
  {
    "question": "Question 301.\n다음은 접근통제 보안 모델의 세 가지 종류 중 하나에 대한 설명이다.\n① 군사적인 목적으로 개발된 최초의 수학적 모델.\n② 기밀성 보장이 최우선임.\n③ 군대 시스템 등 특수 환경에서 주로 사용됨.",
    "answer": "Answer 1 : 기밀성 모델"
  },
  {
    "question": "Question 302.\n다음은 접근통제 보안 모델의 세 가지 중류 중 하나에 대한 설명이다.\n기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델.",
    "answer": "Answer 1 : 무결성 모델"
  },
  {
    "question": "Question 303.\n다음은 접근통제 보안 모델의 세 가지 중류 중 하나에 대한 설명이다.\n① 접근통제 매커니즘을 보안 모델로 발전시킨 것.\n② 대표적으로 접근통제 행렬(Access Control Matrix)이 있음.\n③ 접근통제 행렬 : 임의적인 접근통제를 관리하기 위한 보안 모델로, 행은 주체, 열은 객체 즉, 행과 열로 주체와 객체의 권한 유형을 나타냄.",
    "answer": "Answer 1 : 접근통제 모델"
  },
  {
    "question": "Question 304.\n접근통제 매커니즘의 취약점을 보완하기 위해 접근통제 정책에 부가하여 적용할 수 있는 조건은?",
    "answer": "Answer 1 : 접근통제 조건"
  },
  {
    "question": "Question 305.\n다음은 접근통제 조건의 세 가지 종류 중 하나에 대한 설명이다.\n일반적으로는 객체에 저장된 값에 상관없이 접근통제를 동일하게 허용하지만, 값 종속 통제는 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우에 사용한다.",
    "answer": "Answer 1 : 값 종속 통제\nAnswer 2 : Value-Dependent Control"
  },
  {
    "question": "Question 306.\n다음은 접근통제 조건의 세 가지 종류 중 하나에 대한 설명이다.\n지정된 객체에 다수의 사용자가 동시에 접근을 요구하는 경우에 사용된다.",
    "answer": "Answer 1 : 다중 사용자 통제\nAnswer 2 : Multi-User Control"
  },
  {
    "question": "Question 307.\n다음은 접근통제 조건의 세 가지 종류 중 하나에 대한 설명이다.\n① 특정 시간, 네트워크 주소, 접근 경로, 인증 수준 등에 근거하여 접근을 제어하는 방법이다.\n② 다른 보안 정책과 결합하여 보안 시스템의 취약점을 보완할 때 사용한다.",
    "answer": "Answer 1 : 컨텍스트 기반 통제\nAnswer 2 : Context-Based Control"
  },
  {
    "question": "Question 308.\n사용자나 애플리케이션이 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 기능은?\n오류가 발생한 데이터베이스를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용된다.",
    "answer": "Answer 1 : 감사 추적"
  },
  {
    "question": "Question 309.\n전산 장비의 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업은?\n치명적인 데이터 손실을 막기 위해서 해야 한다.",
    "answer": "Answer 1 : 데이터베이스 백업"
  },
  {
    "question": "Question 310.\n데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 모두 기록한 파일은?\n데이터베이스의 복구를 위해 필요한 가장 기본적인 자료이다.\n○○○을 기반으로 데이터베이스를 과거 상태로 복귀(UNDO) 시키거나 현재 상태로 재생(REDO) 시켜 데이터베이스 상태를 일관성 있게 유지할 수 있다.\n○○○은 트랜잭션 시작 시점, Rollback 시점, 데이터 입력, 수정, 삭제 시점 등에서 기록된다.",
    "answer": "Answer 1 : 로그파일"
  },
  {
    "question": "Question 311.\n다음은 데이터베이스 복구 알고리즘의 네 가지 종류 중 하나에 대한 설명이다.\n데이터베이스 버퍼의 내용을 비동기적으로 갱신한 경우의 복구 알고리즘.",
    "answer": "Answer 1 : NO-UNDO/REDO\nAnswer 2 : NO-UNDO : 트랜잭션 완료 전에는 변경 내용이 데이터베이스에 기록되지 않으므로 취소할 필요가 없음.\nAnswer 3 : REDO : 트랜잭션 완료 후 데이터베이스 버퍼에는 기록되어 있고, 저장매체에는 기록되지 않았으므로 트랜잭션 내용을 다시 실행해야 함."
  },
  {
    "question": "Question 312.\n다음은 데이터베이스 복구 알고리즘의 네 가지 종류 중 하나에 대한 설명이다.\n데이터베이스 버퍼의 내용을 동기적으로 갱신한 경우의 복구 알고리즘.",
    "answer": "Answer 1 : UNDO/NO-REDO\nAnswer 2 : UNDO : 트랜잭션 완료 전에 시스템이 파손되었다면 변경된 내용을 취소함.\nAnswer 3 : NO-REDO : 트랜잭션 완료 전에 데이터베이스 버퍼 내용을 이미 저장 매체에 기록했으므로 트랜잭션 내용을 다시 실행할 필요가 없음."
  },
  {
    "question": "Question 313.\n다음은 데이터베이스 복구 알고리즘의 네 가지 종류 중 하나에 대한 설명이다.\n① 데이터베이스 버퍼의 내용을 동기/비동기적으로 갱신한 경우의 복구 알고리즘.\n② 데이터베이스 기록 전에 트랜잭션이 완료될 수 있으므로 완료된 트랜잭션이 데이터베이스에 기록되지 못했다면 다시 실행해야 함.",
    "answer": "Answer 1 : UNDO/REDO"
  },
  {
    "question": "Question 314.\n다음은 데이터베이스 복구 알고리즘의 네 가지 종류 중 하나에 대한 설명이다.\n데이터베이스 버퍼의 내용을 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우의 복구 알고리즘.",
    "answer": "Answer 1 : NO-UNDO/NO-REDO\nAnswer 2 : NO-UNDO : 변경 내용은 데이터베이스와 다른 영역에 기록되어 있으므로 취소할 필요가 없음.\nAnswer 3 : NO-REDO : 다른 영역에 이미 기록되어 있으므로 트랜잭션을 다시 실행할 필요가 없음."
  },
  {
    "question": "Question 315.\n백업 종류는 복구 수준에 따라서 운영체제를 이용하는 ○○○과 DBMS 유틸리티를 이용하는 논리 백업으로 나뉜다.\n○○○.\n① 데이터 베이스 파일을 백업하는 방법이다.\n② 백업 속도가 빠르고 작업이 단순하지만 문제 발생 시 원인 파악 및 문제 해결이 어렵다.",
    "answer": "Answer 1 : 물리 백업"
  },
  {
    "question": "Question 316.\n백업 종류는 복구 수준에 따라서 운영체제를 이용하는 물리 백업과 DBMS 유틸리티를 이용하는 ○○○으로 나뉜다.\n○○○.\n① DB 내의 논리적 객체들을 백업하는 방법이다.\n② 복원 시 데이터 손상을 막고 문제 발생 시 원인 파악 및 해결이 수월하지만 백업/복원 시 시간이 많이 소요된다.",
    "answer": "Answer 1 : 논리 백업"
  },
  {
    "question": "Question 317.\n단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술은?\n○○○의 종류에는 DAS, NAS, SAN이 있다.",
    "answer": "Answer 1 : 스토리지\nAnswer 2 : Storage"
  },
  {
    "question": "Question 318.\n서버와 저장장치를 전용 케이블로 직접 연결하는 방식은?\n일반 가정에서 컴퓨터에 외장하드를 연결하는 것이 여기에 해당된다.\n저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉽다.\n초기 구축 비용 및 유지보수 비용이 저렴하다.\n직접 연결 방식이므로 다른 서버에서 접근할 수 없고 파일을 공유할 수 없다.\n확장성 및 유연성이 떨어진다.",
    "answer": "Answer 1 : DAN\nAnswer 2 : Direct Attached Storage"
  },
  {
    "question": "Question 319.\n서버와 저장장치를 네트워크를 통해 연결하는 방식은?\n별도의 파일 관리 기능이 있는 ○○○ Storage가 내장된 저장장치를 직접 관리한다.\nEthernet 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유가 가능하다.\n장소에 구애받지 않고 저장장치에 쉽게 접근할 수 있다.\nDAN에 비해 확장성 및 유연성이 우수하다.",
    "answer": "Answer 1 : NAS\nAnswer 2 : Network Attached Storage"
  },
  {
    "question": "Question 320.\nDAN의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식으로, 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식은?\n광 채널(FC) 스위치를 이용하여 네트워크를 구성한다.\n광 채널 스위치는 서버와 저장장치를 광케이블로 연결하므로 처리 속도가 빠르다.\n저장장치를 공유함으로써 여러 개의 저장장치나 백업 장비를 단일화시킬 수 있다.\n확장성, 유연성, 가용성이 뛰어나다.",
    "answer": "Answer 1 : SAN\nAnswer 2 : Storage Area Network"
  },
  {
    "question": "Question 321.\n서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것은?\n서브타입에 속성이나 관계가 적을 경우에 적용하는 방법이다.\n하나로 통합된 테이블에는 서브타입의 모든 속성이 포함되어야 한다.",
    "answer": "Answer 1 : 슈퍼타입 기준 테이블 변환"
  },
  {
    "question": "Question 322.\n슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 만드는 것은?\n서브타입에 속성이나 관계가 많이 포함된 경우 적용한다.",
    "answer": "Answer 1 : 서브타입 기준 테이블 변환"
  },
  {
    "question": "Question 323.\n슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환하는 것은?\n슈퍼타입과 서브타입 테이블들 사이에는 각각 1:1 관계가 형성된다.",
    "answer": "Answer 1 : 개별타입 기준 테이블 변환"
  },
  {
    "question": "Question 324.\n자료를 기억장치의 공간 내에 저장하는 방법과 자료 간의 관계, 처리 방법 등을 연구 분석하는 활동을 말하는 것은?\n저장 공간의 효율성과 실행시간의 단축을 위해 사용한다.",
    "answer": "Answer 1 : 자료 구조"
  },
  {
    "question": "Question 325.\n크기와 형(Type)이 동일한 자료들이 순서대로 나열된 자료의 집합은?\n반복적인 데이터 처리 작업에 적합한 구조이다.\n정적인 자료 구조로, 기억장소의 추가가 어렵다.\n데이터 삭제 시 기억장소가 빈 공간으로 남아있어 메모리의 낭비가 발생한다.",
    "answer": "Answer 1 : 배열\nAnswer 2 : Array"
  },
  {
    "question": "Question 326.\n배열과 같이 연속되는 기억장소에 저장되는 자료 구조는?\n중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 한다.\n삽입·삭제 시 자료의 이동이 필요하다.",
    "answer": "Answer 1 : 연속 리스트\nAnswer 2 : Contiguous List"
  },
  {
    "question": "Question 327.\n자료들을 임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료구조는?\n연결을 위한 링크(포인터) 부분이 필요하기 때문에 기억 공간의 이용 효율이 좋지 않다.\n접근 속도가 느리고, 연결이 끊어지면 다음 노드를 찾기 어렵다.",
    "answer": "Answer 1 : 연결 리스트\nAnswer 2 : Linked List"
  },
  {
    "question": "Question 328.\n리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조는?\n후입선출(LIFO; Last in First Out) 방식으로 자료를 처리한다.\n저장할 기억 공간이 없는 상태에서 데이터가 삽입되면 오버플로(Overflow)가 발생한다.\n삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다.",
    "answer": "Answer 1 : 스택\nAnswer 2 : Stack"
  },
  {
    "question": "Question 329.\n리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조는?\n선입선출(FIFO; First In First Out) 방식으로 처리한다.\n시작을 표시하는 프런트(Front) 포인터와 끝을 표시하는 리어(Rear) 포인터가 있다.",
    "answer": "Answer 1 : 큐\nAnswer 2 : Queue"
  },
  {
    "question": "Question 330.\n정점(Vertex)과 간선(Edge)의 두 집합으로 이루어지는 자료 구조는?\n사이클이 없는 ○○○(○○○)를 트리(Tree)라 한다.\n간선의 방향성 유무에 따라 방향 ○○○와 무방향 ○○○로 구분된다.",
    "answer": "Answer 1 : 그래프\nAnswer 2 : Graph"
  },
  {
    "question": "Question 331.\n정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프(Graph)의 특수한 형태는?\n하나의 기억 공간을 노드(Node)라고 하며, 노드와 노드를 연결하는 선을 링크(Link)라고 한다.",
    "answer": "Answer 1 : 트리"
  },
  {
    "question": "Question 332.\n차수(Degree)가 2 이하인 노드들로 구성된 트리, 즉 자식이 둘 이하인 노드들로만 구성된 트리를 말하는 것은?\n○○○의 레벨 i에서 최대 노드의 수는 2^(i- 1)이다.\nTerminal Node수가 n0, 차수가 2인 노드 수가 n2라 할 때 n0 = n2 + 1이 된다.",
    "answer": "Answer 1 : 이진 트리"
  },
  {
    "question": "Question 333.\n트리를 구성하는 각 노드들을 찾아가는 방법을 뭐라고 하는가?\n이진 트리를 운행하는 방법은 산술식의 표기법과 연관성을 갖는다.\n이진 트리의 ○○○은 세 가지가 있다.\n① Preorder 운행.\n② Inorder 운행.\n③ Postorder 운행.",
    "answer": "Answer 1 : 운행법\nAnswer 2 : Traversal"
  },
  {
    "question": "Question 334.\n이진 트리를 Root - > Left - > Right 순으로 운행하며 노드들을 찾아가는 방법은?",
    "answer": "Answer 1 : Preorder 운행법"
  },
  {
    "question": "Question 335.\n이진 트리를 Left - > Root - > Right 순으로 운행하며 노드들을 찾아가는 방법은?",
    "answer": "Answer 1 : Inorder 운행법"
  },
  {
    "question": "Question 336.\n이진 트리를 Left - > Right - > Root 순으로 운행하며 노드들을 찾아가는 방법은?",
    "answer": "Answer 1 : Postorder 운행법"
  },
  {
    "question": "Question 337.\n가장 간단한 정렬 방식으로, 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식은?",
    "answer": "Answer 1 : 삽입 정렬\nAnswer 2 : Insert Sort"
  },
  {
    "question": "Question 338.\nn개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n- 1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식은?",
    "answer": "Answer 1 : 선택 정렬\nAnswer 2 : Selection Sort"
  },
  {
    "question": "Question 339.\n주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식은?",
    "answer": "Answer 1 : 버블 정렬\nAnswer 2 : Bubble Sort"
  },
  {
    "question": "Question 340.\n입력 파일을 어떤 매개변수의 값으로 서브파일을 구성하고, 각 서브파일은 Insertion 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬 방식은?\n삽입 정렬(Insertion Sort)을 확장한 개념이다.",
    "answer": "Answer 1 : 쉘 정렬\nAnswer 2 : Shell Sort"
  },
  {
    "question": "Question 341.\n키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 서브 파일에 분해시키는 과정을 반복하는 정렬 방식은?\n레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다.",
    "answer": "Answer 1 : 퀵 정렬\nAnswer 2 : Quick Sort"
  },
  {
    "question": "Question 342.\n전이진 트리를 이용한 정렬 방식은?\n구성된 전이진 트리(Complete Binary Tree)를 Heap Tree로 변환하여 정렬한다.",
    "answer": "Answer 1 : 힙 정렬\nAnswer 2 : Heap Sort"
  },
  {
    "question": "Question 343.\n이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식은?",
    "answer": "Answer 1 : 2- Way 합병 정렬\nAnswer 2 : 2- Way Merge Sort"
  },
  {
    "question": "Question 344.\nQueue를 이용하여 자릿수(Digit)별로 정렬하는 방식은?\n레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내여 정렬한다.",
    "answer": "Answer 1 : 기수 정렬\nAnswer 2 : Radix Sort\nAnswer 3 : Bucket Sort"
  },
  {
    "question": "Question 345.\n사용자의 요구사항에 맞춰 송·수신 모듈과 중계 모듈 간의 연계를 구현하는 것을 의미하는 것은?\n송·수신 방식이나 시스템 아키텍처 구성, 송·수신 모듈 구현 방법 등에 따라 다르므로 사용자의 요구사항과 구축 환경에 적합한 방식을 설계해야 한다.\n일반적인 ○○○은 송·수신 시스템과 모듈, 중계 시스템, 연계 데이터, 네트워크로 구성된다.",
    "answer": "Answer 1 : 통합 구현"
  },
  {
    "question": "Question 346.\n다음은 통합 구현의 일곱 가지 종류 중 하나에 대한 설명이다.\n데이터를 생성 및 변환하여 전송하는 시스템으로, 송신 모듈과 모니터링(Monitoring) 기능으로 구성됨.",
    "answer": "Answer 1 : 송신 시스템"
  },
  {
    "question": "Question 347.\n다음은 통합 구현의 일곱 가지 종류 중 하나에 대한 설명이다.\n전송 데이터를 생성하고 필요에 따라 전송 데이터의 변환 등을 수행함.",
    "answer": "Answer 1 : 송신 모듈"
  },
  {
    "question": "Question 348.\n다음은 통합 구현의 일곱 가지 종류 중 하나에 대한 설명이다.\n수신 받은 데이터를 정제 및 변환하는 시스템으로, 수신 모듈과 모니터링(Monitoring) 기능으로 구성됨.",
    "answer": "Answer 1 : 수신 시스템"
  },
  {
    "question": "Question 349.\n다음은 통합 구현의 일곱 가지 종류 중 하나에 대한 설명이다.\n수신 데이터를 정제하고 애플리케이션이나 데이터베이스(DB) 테이블에 적합한 데이터로 변환하는 작업 등을 수행함.",
    "answer": "Answer 1 : 수신 모듈"
  },
  {
    "question": "Question 350.\n다음은 통합 구현의 일곱 가지 종류 중 하나에 대한 설명이다.\n내·외부 시스템 간 또는 내부 시스템 간의 연계 시 사용되는 아키텍처.",
    "answer": "Answer 1 : 중계 시스템"
  },
  {
    "question": "Question 351.\n다음은 통합 구현의 일곱 가지 종류 중 하나에 대한 설명이다.\n송·수신 시스템 간 송·수신되는 데이터",
    "answer": "Answer 1 : 연계 데이터"
  },
  {
    "question": "Question 352.\n다음은 통합 구현의 일곱 가지 종류 중 하나에 대한 설명이다.\n송신 시스템, 수신 시스템, 중계 시스템을 연결해주는 통신망",
    "answer": "Answer 1 : 네트워크"
  },
  {
    "question": "Question 353.\n통합 구현을 위해 사용자 요구사항을 분석하여 연계 데이터를 식별 및 표준화하여 연계 데이터를 정의하는 것은?\n○○○ 절차.\n① 하드웨어 및 소프트웨어 구성, 네트워크 현황 확인.\n② 테이블 정의서, 코드 정의서 등의 문서 확인.\n③ 체크리스트 작성.\n④관련 문서 공유 및 인터뷰·설문 조사 실시.\n⑤ 요구사항 정의서 작성.",
    "answer": "Answer 1 : 연계 요구사항 분석"
  },
  {
    "question": "Question 354.\n다음은 연계 데이터 식별 및 표준화의 절차 단계 설명이다.\n○○○에 들어갈 말은?\n① ○○○ : 시스템 간 연계할 정보를 상세화하여 정의.\n② 연계 코드 변환 및 매핑 : 연계 정보 중 코드로 관리되어야 할 항목을 찾아 코드로 변환.\n③ 연계 데이터 식별자와 변경 구분 추가 : 연계 정보에 데이터 구분 식별자, 작업 구분 정보, 테이블/파일 관리 정보 등을 추가.\n④연계 데이터 표현 방법 정의 : 연계 대상 범위, 대상 항목, 코드 변환 방식, 매핑 방식을 정의한 후 연계 데이터 구성.\n⑤ 연계 정의서 및 명세서 작성 : 이전 과정에서 정의된 다양한 항목들과 파악된 현황들을 문서화함.",
    "answer": "Answer 1 : 연계 범위 및 항목 정의"
  },
  {
    "question": "Question 355.\n다음은 연계 데이터 식별 및 표준화의 절차 단계 설명이다.\n○○○에 들어갈 말은?\n① 연계 범위 및 항목 정의 : 시스템 간 연계할 정보를 상세화하여 정의.\n② ○○○ : 연계 정보 중 코드로 관리되어야 할 항목을 찾아 코드로 변환.\n③ 연계 데이터 식별자와 변경 구분 추가 : 연계 정보에 데이터 구분 식별자, 작업 구분 정보, 테이블/파일 관리 정보 등을 추가.\n④연계 데이터 표현 방법 정의 : 연계 대상 범위, 대상 항목, 코드 변환 방식, 매핑 방식을 정의한 후 연계 데이터 구성.\n⑤ 연계 정의서 및 명세서 작성 : 이전 과정에서 정의된 다양한 항목들과 파악된 현황들을 문서화함.",
    "answer": "Answer 1 : 연계 코드 변환 및 매핑"
  },
  {
    "question": "Question 356.\n다음은 연계 데이터 식별 및 표준화의 절차 단계 설명이다.\n○○○에 들어갈 말은?\n① 연계 범위 및 항목 정의 : 시스템 간 연계할 정보를 상세화하여 정의.\n② 연계 코드 변환 및 매핑 : 연계 정보 중 코드로 관리되어야 할 항목을 찾아 코드로 변환.\n③ ○○○ : 연계 정보에 데이터 구분 식별자, 작업 구분 정보, 테이블/파일 관리 정보 등을 추가.\n④연계 데이터 표현 방법 정의 : 연계 대상 범위, 대상 항목, 코드 변환 방식, 매핑 방식을 정의한 후 연계 데이터 구성.\n⑤ 연계 정의서 및 명세서 작성 : 이전 과정에서 정의된 다양한 항목들과 파악된 현황들을 문서화함.",
    "answer": "Answer 1 : 연계 데이터 식별자와 변경 구분 추가"
  },
  {
    "question": "Question 357.\n다음은 연계 데이터 식별 및 표준화의 절차 단계 설명이다.\n○○○에 들어갈 말은?\n① 연계 범위 및 항목 정의 : 시스템 간 연계할 정보를 상세화하여 정의.\n② 연계 코드 변환 및 매핑 : 연계 정보 중 코드로 관리되어야 할 항목을 찾아 코드로 변환.\n③ 연계 데이터 식별자와 변경 구분 추가 : 연계 정보에 데이터 구분 식별자, 작업 구분 정보, 테이블/파일 관리 정보 등을 추가.\n④○○○ : 연계 대상 범위, 대상 항목, 코드 변환 방식, 매핑 방식을 정의한 후 연계 데이터 구성.\n⑤ 연계 정의서 및 명세서 작성 : 이전 과정에서 정의된 다양한 항목들과 파악된 현황들을 문서화함.",
    "answer": "Answer 1 : 연계 데이터 표현 방법 정의"
  },
  {
    "question": "Question 358.\n다음은 연계 데이터 식별 및 표준화의 절차 단계 설명이다.\n○○○에 들어갈 말은?\n① 연계 범위 및 항목 정의 : 시스템 간 연계할 정보를 상세화하여 정의.\n② 연계 코드 변환 및 매핑 : 연계 정보 중 코드로 관리되어야 할 항목을 찾아 코드로 변환.\n③ 연계 데이터 식별자와 변경 구분 추가 : 연계 정보에 데이터 구분 식별자, 작업 구분 정보, 테이블/파일 관리 정보 등을 추가.\n④연계 데이터 표현 방법 정의 : 연계 대상 범위, 대상 항목, 코드 변환 방식, 매핑 방식을 정의한 후 연계 데이터 구성.\n⑤ ○○○ : 이전 과정에서 정의된 다양한 항목들과 파악된 현황들을 문서화함.",
    "answer": "Answer 1 : 연계 정의서 및 명세서 작성"
  },
  {
    "question": "Question 359.\n데이터의 생성 및 전송을 담당하는 송신 시스템과 데이터 수신 및 운영 DB 반영을 담당하는 수신 시스템으로 구성되는 것은?\n송·수신 시스템 사이에는 데이터의 송·수신과 송·수신 시스템 현황을 모니터링하는 중계 시스템을 설치할 수 있다.",
    "answer": "Answer 1 : 연계 메커니즘"
  },
  {
    "question": "Question 360.\n다음은 연계 메커니즘의 연계 방식 두 가지 중 하나에 대한 설명이다.\n① 중간 매개체 없이 송·수신 시스템이 직접 연계하는 방식.\n② 종류 : DB Link, API/Open API, DB Connection, JDBC 등",
    "answer": "Answer 1 : 직접 연계 방식"
  },
  {
    "question": "Question 361.\n다음은 연계 메커니즘의 연계 방식 두 가지 중 하나에 대한 설명이다.\n① 송·수신 시스템 사이에 중간 매개체를 두어 연계하는 방식.\n② 종류 : 연계 솔류션, ESB, 소켓(Socket), 웹 서비스(Web Service) 등",
    "answer": "Answer 1 : 간접 연계 방식"
  },
  {
    "question": "Question 362.\n연계 메커니즘에서 오류 발생 시점, 오류 로그 기록 장소, 오류 로그 기록 주체는 크게 세 가지 구간으로 나눌 수 있을 때, 다음은 오류 발생 시점에 대한 설명이다.\n어느 구간에서 발생했는지 쓰시오.\n① 데이터 생성 및 추출 시.\n② 코드 매핑 및 데이터 변환 시.\n③ 인터페이스 테이블 또는 파일 등록 시.",
    "answer": "Answer 1 : 송신 시스템"
  },
  {
    "question": "Question 363.\n연계 메커니즘에서 오류 발생 시점, 오류 로그 기록 장소, 오류 로그 기록 주체는 크게 세 가지 구간으로 나눌 수 있을 때, 다음은 오류 발생 시점에 대한 설명이다.\n어느 구간에서 발생했는지 쓰시오.\n① 연계 데이터 로드(Load) 시.\n② 코드 매핑 및 데이터 변환 시.\n③ 운영 DB에 반영 시.",
    "answer": "Answer 1 : 수신 시스템"
  },
  {
    "question": "Question 364.\n연계 메커니즘에서 오류 발생 시점, 오류 로그 기록 장소, 오류 로그 기록 주체는 크게 세 가지 구간으로 나눌 수 있을 때, 다음은 오류 발생 시점에 대한 설명이다.\n어느 구간에서 발생했는지 쓰시오.\n① 연계 데이터 로드(Load) 및 전송 형식으로 변환 시.\n② 연계 데이터 송·수신 시.\n③ 수신 시스템의 데이터 형식으로 변환 및 로드(Load) 시.",
    "answer": "Answer 1 : 연계 서버"
  },
  {
    "question": "Question 365.\n다음은 장애 및 오류 현황의 기록과 확인을 위해서 정의 및 설계되는 네 가지 항목 중 하나에 대한 설명이다.\n송·수신 시스템의 연계 프로그램에서 관리하는 장애 및 오류를 관리 대상으로 정의함.",
    "answer": "Answer 1 : 장애 및 오류 관리 대상"
  },
  {
    "question": "Question 366.\n다음은 장애 및 오류 현황의 기록과 확인을 위해서 정의 및 설계되는 네 가지 항목 중 하나에 대한 설명이다.\n관리 대상에서 식별한 오류 내용을 주제별로 분류한 후 각 오류 내용에 오류 코드를 부여하고 오류 메시지를 정의함.",
    "answer": "Answer 1 : 관리 대상의 장애 및 오류 코드와 메시지"
  },
  {
    "question": "Question 367.\n다음은 장애 및 오류 현황의 기록과 확인을 위해서 정의 및 설계되는 네 가지 항목 중 하나에 대한 설명이다.\n관리 대상 오류 코드와 오류 메시지가 많은 경우에는 테이블 관리 방식을, 적은 경우에는 파일 관리 방식을 선택함.",
    "answer": "Answer 1 : 장애 및 오류 코드와 메시지 관리 방식"
  },
  {
    "question": "Question 368.\n다음은 장애 및 오류 현황의 기록과 확인을 위해서 정의 및 설계되는 네 가지 항목 중 하나에 대한 설명이다.\n오류 로그 테이블이나 파일은 기록 단위에 따라 인터페이스 테이블이나 파일에 대한 로그, 연계 데이터에 대한 로그로 설계함.",
    "answer": "Answer 1 : 장애 및 오류 기록 방식"
  },
  {
    "question": "Question 369.\n송신 시스템에서 수신 시스템으로 전송되는 연계 데이터는 보안에 취약할 수 있으므로 데이터의 중요성을 고려하여 보안을 적용해야 된다는 말은?\n일반적인 ○○○ 방식.\n① 전송 구간 보안.\n② 데이터 보안.",
    "answer": "Answer 1 : 연계 데이터 보안"
  },
  {
    "question": "Question 370.\n전송되는 데이터나 패킷(Packet)을 쉽게 가로챌 수 없도록 암호화 기능이 포함된 프로토콜을 사용하는 것은?\n데이터나 패킷을 가로채더라도 내용을 확인할 수 없게 데이터나 패킷을 암호화한다.",
    "answer": "Answer 1 : 전송 구간 보안"
  },
  {
    "question": "Question 371.\n송신 시스템에서 연계 데이터를 추출할 때와 수신 시스템에서 데이터를 운영 DB에 반영할 때 데이터를 암·복호화 하는 것은?\n데이터의 암·복호화 처리 절차.\n- 송신 시스템.\n① DB에서 연계 데이터 추출.\n② 보안 적용 대상 컬럼(Column)을 암호화.\n③ 연계 데이터를 인터페이스 테이블 또는 파일에 등록 및 송신.\n- 수신 시스템.\n① 수신된 데이터 중 암호화한 컬럼(Column)을 복호화.\n② 운영 DB에 반영.",
    "answer": "Answer 1 : 데이터 보안"
  },
  {
    "question": "Question 372.\n특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어는?\n웹브라우저 간 HTML 문법이 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위하여 개발되었다.\n사용자가 직접 문서의 태그(Tag)를 정의할 수 있으며, 다른 사용자가 정의한 태그를 사용할 수 있다.\n트리 구조로 구성되어 있어 상위 태그는 여러 개의 하위 태그를 가질 수 있다.",
    "answer": "Answer 1 : XML\nAnswer 2 : eXtensible Markup Language"
  },
  {
    "question": "Question 373.\n컴퓨터 네트워크 상에서 HTTP/HTTPS, SMTP 등을 이용하여 XML을 교환하기 위한 통신 규약은?\n웹 서비스에서 사용되는 메시지의 형식과 처리 방법을 지정한다.\n기본적으로 HTTP 기반에서 동작하기 때문에 프록시와 방화벽의 영향 없이 통신할 수 있다.\n최근에는 무거운 구조의 ○○○ 대신 RESTful 프로토콜을 이용하기도 한다.",
    "answer": "Answer 1 : SOAP\nAnswer 2 : Simple Object Access Protocol"
  },
  {
    "question": "Question 374.\n웹 서비스와 관련된 서식이나 프로토콜 등을 표전적인 방법으로 기술하고 게시하기 위한 언어는?\nXML로 작성되며, UDDI의 기초가 된다.\nSOAP, XMML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해 사용된다.\n클라이언트는 ○○○ 파일을 읽어 서버에서 어떠한 조작이 가능한지를 파악할 수 있다.",
    "answer": "Answer 1 : WSDL\nAnswer 2 : Web Service Description Language"
  },
  {
    "question": "Question 375.\n구축된 연계 시스템과 연계 시스템의 구성 요소가 정상적으로 동작하는지 확인하는 활동은?\n○○○ 진행 순서.\n① ○○○ 케이스 작성 : 연계 시스템 간의 데이터 및 프로세스의 흐름을 분석하여 필요한 테스트 항목을 도출함.\n② ○○○ 환경 구축 : 테스트의 일정, 방법, 절차, 소요 시간 등을 송·수신 기관과의 협의를 통해 결정함.\n③ ○○○ 수행 : 연계 응용 프로그램을 실행하여 연계 테스트 케이스의 시험 항목 및 처리 절차 등을 실제로 진행함.\n④○○○ 수행 결과 검증 : ○○○ 케이스의 시험 항목 및 처리 절차를 수행한 결과가 예상 결과와 동일한지 확인함.",
    "answer": "Answer 1 : 연계 테스트"
  },
  {
    "question": "Question 376.\n응용 소프트웨어 개발을 위해 개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것을 의미하는 것은?\n응용 소프트웨어가 운영될 환경과 유사한 구조로 구축한다.\n분석 단계의 산출물을 바탕으로 개발에 필요한 하드웨어와 소프트웨어를 선정한다.\n하드웨어와 소프트웨어의 성능, 편의성, 라이선스 등의 비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축한다.",
    "answer": "Answer 1 : 개발 환경 구축"
  },
  {
    "question": "Question 377.\n사용자와의 인터페이스 역할을 하는 클라이언트(Client) 그리고 클라이언트와 통신하여 서비스를 제공하는 서버(Server)로 구성되는 것은?\n클라이언트의 종류 : 개인용 컴퓨터(PC), 스마트폰 등",
    "answer": "Answer 1 : 하드웨어 환경"
  },
  {
    "question": "Question 378.\n다음은 서버의 네 가지 종류 중 하나에 대한 설명이다.\n① 클라이언트로부터 직접 요청을 받아 처리함.\n② 저용량의 정적 파일들을 제공함.",
    "answer": "Answer 1 : 웹 서버\nAnswer 2 : Web Server"
  },
  {
    "question": "Question 379.\n다음은 서버의 네 가지 종류 중 하나에 대한 설명이다.\n동적 서비스를 제공하거나, 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할을 수행함.",
    "answer": "Answer 1 : 웹 애플리케이션 서버\nAnswer 2 : WAS\nAnswer 3 : Web Application Server"
  },
  {
    "question": "Question 380.\n다음은 서버의 네 가지 종류 중 하나에 대한 설명이다.\n데이터베이스와 이를 관리하는 DBMS를 운영함.",
    "answer": "Answer 1 : 데이터베이스 서버\nAnswer 2 : DB Server"
  },
  {
    "question": "Question 381.\n다음은 서버의 네 가지 종류 중 하나에 대한 설명이다.\n데이터베이스에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장함.",
    "answer": "Answer 1 : 파일 서버\nAnswer 2 : File Server"
  },
  {
    "question": "Question 382.\n클라이언트와 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성되는 것은?\n시스템 소프트웨어의 종류 : 운영체제(OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS 등",
    "answer": "Answer 1 : 소프트웨어 환경"
  },
  {
    "question": "Question 383.\n다음은 개발 소프트웨어의 여섯 가지 종류 중 하나에 대한 설명이다.\n요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어.",
    "answer": "Answer 1 : 요구사항 관리 도구"
  },
  {
    "question": "Question 384.\n다음은 개발 소프트웨어의 여섯 가지 종류 중 하나에 대한 설명이다.\nUML(통합 모델링 언어)을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어.",
    "answer": "Answer 1 : 설계/모델링 도구"
  },
  {
    "question": "Question 385.\n다음은 개발 소프트웨어의 여섯 가지 종류 중 하나에 대한 설명이다.\n개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어",
    "answer": "Answer 1 : 구현 도구"
  },
  {
    "question": "Question 386.\n다음은 개발 소프트웨어의 여섯 가지 종류 중 하나에 대한 설명이다.\n구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 소프트웨어.",
    "answer": "Answer 1 : 빌드 도구"
  },
  {
    "question": "Question 387.\n다음은 개발 소프트웨어의 여섯 가지 종류 중 하나에 대한 설명이다.\n모듈들이 요구사항에 적합하게 구현되었는지 테스트하는 소프트웨어",
    "answer": "Answer 1 : 테스트 도구"
  },
  {
    "question": "Question 388.\n다음은 개발 소프트웨어의 여섯 가지 종류 중 하나에 대한 설명이다.\n산출물들을 버전별로 관리하여 품질 향상을 지원하는 소프트웨어",
    "answer": "Answer 1 : 형상 관리 도구"
  },
  {
    "question": "Question 389.\n다음은 웹 서버(Web Server)의 여섯 가지 기능 중 하나에 대한 설명이다.\n브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜",
    "answer": "Answer 1 : HTTP/HTTPS 지원"
  },
  {
    "question": "Question 390.\n다음은 웹 서버(Web Server)의 여섯 가지 기능 중 하나에 대한 설명이다.\n처리한 요청들을 로그 파일로 기록하는 기능.",
    "answer": "Answer 1 : 통신 기록\nAnswer 2 : Communication Log"
  },
  {
    "question": "Question 391.\n다음은 웹 서버(Web Server)의 여섯 가지 기능 중 하나에 대한 설명이다.\nHTML, CSS, 이미지 등의 정적 파일들을 저장하고 관리하는 기능",
    "answer": "Answer 1 : 정적 파일 관리\nAnswer 2 : Managing Static Files"
  },
  {
    "question": "Question 392.\n다음은 웹 서버(Web Server)의 여섯 가지 기능 중 하나에 대한 설명이다.\n네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능",
    "answer": "Answer 1 : 대역폭 제한\nAnswer 2 : Bandwidth Throttling"
  },
  {
    "question": "Question 393.\n다음은 웹 서버(Web Server)의 여섯 가지 기능 중 하나에 대한 설명이다.\n하나의 서버로 여러 개의 도메인 이름을 연결하는 기능",
    "answer": "Answer 1 : 가상 호스팅\nAnswer 2 : Virtual Hosting"
  },
  {
    "question": "Question 394.\n다음은 웹 서버(Web Server)의 여섯 가지 기능 중 하나에 대한 설명이다.\n사용자가 합법적인 사용자인지를 확인하는 기능",
    "answer": "Answer 1 : 인증\nAnswer 2 : Authentication"
  },
  {
    "question": "Question 395.\n다음은 개발 언어의 다섯 가지 선정 기능 중 하나에 대한 설명이다.\n개발하려는 소프트웨어의 목적에 적합해야 함.",
    "answer": "Answer 1 : 적정성"
  },
  {
    "question": "Question 396.\n다음은 개발 언어의 다섯 가지 선정 기능 중 하나에 대한 설명이다.\n코드의 작성 및 구현이 효율적이어야 함.",
    "answer": "Answer 1 : 효율성"
  },
  {
    "question": "Question 397.\n다음은 개발 언어의 다섯 가지 선정 기능 중 하나에 대한 설명이다.\n다양한 시스템 및 환경에 적용이 가능해야 함.",
    "answer": "Answer 1 : 이식성"
  },
  {
    "question": "Question 398.\n다음은 개발 언어의 다섯 가지 선정 기능 중 하나에 대한 설명이다.\n개발 언어에 대한 개발자들의 이해도와 활용도가 높아야 함.",
    "answer": "Answer 1 : 친밀성"
  },
  {
    "question": "Question 399.\n다음은 개발 언어의 다섯 가지 선정 기능 중 하나에 대한 설명이다.\n다른 개발 사례가 존재하고 여러 분야에서 활용되고 있어야 함.",
    "answer": "Answer 1 : 범용성"
  },
  {
    "question": "Question 400.\n소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체는?\n애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정한다.\n○○○ 설계의 기본 원리에는 모듈화, 추상화, 단계적 분해, 정보은닉이 있다.",
    "answer": "Answer 1 : 소프트웨어 아키텍쳐"
  },
  {
    "question": "Question 401.\n소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미하는 것은?\n모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 든다.\n모듈의 크기를 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다.",
    "answer": "Answer 1 : 모듈화\nAnswer 2 : Modularity"
  },
  {
    "question": "Question 402.\n문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것은?\n완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있다.",
    "answer": "Answer 1 : 추상화\nAnswer 2 : Abstration"
  },
  {
    "question": "Question 403.\n다음은 추상화의 세 가지 유형 중 하나에 대한 설명이다.\n자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법.",
    "answer": "Answer 1 : 과정 추상화"
  },
  {
    "question": "Question 404.\n다음은 추상화의 세 가지 유형 중 하나에 대한 설명이다.\n데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법.",
    "answer": "Answer 1 : 데이터 추상화"
  },
  {
    "question": "Question 405.\n다음은 추상화의 세 가지 유형 중 하나에 대한 설명이다.\n이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법",
    "answer": "Answer 1 : 제어 추상화"
  },
  {
    "question": "Question 406.\n문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법은?\nNiklaus Wirth에 의해 제안된 하향식 설계 전략이다.\n소프트웨어의 포괄적인 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행한다.",
    "answer": "Answer 1 : 단계적 분해\nAnswer 2 : Stepwise Refinement"
  },
  {
    "question": "Question 407.\n한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법은?\n○○○을 통해 모듈을 독립적으로 수행할 수 있다.\n하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다.",
    "answer": "Answer 1 : 정보 은닉\nAnswer 2 : Information Hiding"
  },
  {
    "question": "Question 408.\n소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 품질 평가 요소들을 구체화 시켜 놓은 것은?\n품질 평가 요소의 종류.\n시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등.\n비즈니스 측면 : 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정 등.\n아키텍처 측면 : 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성 시험성 등.",
    "answer": "Answer 1 : 소프트웨어 아키텍처의 품질 속성"
  },
  {
    "question": "Question 409.\n컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것은?\n컴포넌트에 대한 정확한 인터페이스를 명세한다.\n명세에 포함될 조건.\n선행 조건(Precondition) : 오퍼레이션이 호출되기 전에 참이 되어야 할 조건.\n결과 조건(Postcondition) : 오퍼레이션이 수행된 후 만족되어야 할 조건.\n불변 조건(Incariant) : 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건.",
    "answer": "Answer 1 : 협약(Contract)에 의한 설계"
  },
  {
    "question": "Question 410.\n아키텍처를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제를 의미하는 것은?\n소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시한다.\n○○○에는 서브시스템들과 그 역할이 정의되어 있다.\n서브시스템 사이의 관계와 여러 규칙·지침 등이 포함되어 있다.",
    "answer": "Answer 1 : 아키텍처 패턴"
  },
  {
    "question": "Question 411.\n시스템을 계층으로 구분하여 구성하는 고전적인 방법의 패턴은?\n하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 된다.\n서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어진다.\n대표적으로 OSI 참조 모델이 있다.",
    "answer": "Answer 1 : 레이어 패턴\nAnswer 2 : Layers pattern"
  },
  {
    "question": "Question 412.\n하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴은?\n사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에게 제공하는 방식이다.",
    "answer": "Answer 1 : 클라이언트-서버 패턴\nAnswer 2 : Client-Server Pattern"
  },
  {
    "question": "Question 413.\n데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴은?\n앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복한다.\n데이터 변환, 버퍼링, 동기화 등에 주로 사용된다.\n대표적으로 UNIX의 쉘(Shell)이 있다.",
    "answer": "Answer 1 : 파이프-필터 패턴\nAnswer 2 : Pipe-Filter Pattern"
  },
  {
    "question": "Question 414.\n서브시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴은?\n컨트롤러가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용하여 뷰에 정보를 출력하는 구조이다.\n여러 개의 뷰를 만들 수 있다.\n한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합하다.",
    "answer": "Answer 1 : 모델-뷰-컨트롤러 패턴\nAnswer 2 : Model-View-Controller Pattern"
  },
  {
    "question": "Question 415.\n슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴은?\n예) 장애 허용 시스템, 병렬 컴퓨팅 시스템.",
    "answer": "Answer 1 : 마스터-슬레이브 패턴\nAnswer 2 : Master-Slaver Pattern"
  },
  {
    "question": "Question 416.\n사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴.\n예) 분산 환경 시스템.",
    "answer": "Answer 1 : 브로커 패턴\nAnswer 2 : Broker Pattern"
  },
  {
    "question": "Question 417.\n피어(Peer)라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수도 있는 패턴은?\n예) 파일 공유 네트워크.",
    "answer": "Answer 1 : 피어-투-피어 패턴\nAnswer 2 : Peer-To-Peer Pattern"
  },
  {
    "question": "Question 418.\n소스가 특정 채널에 이벤트 메시지를 발행(Publish)하면, 해당 채널을 구독(Subscribe)한 리스너(Listener)들이 메시지를 받아 이벤트를 처리하는 패턴은?\n예) 알림 서비스.",
    "answer": "Answer 1 : 이벤트-버스 패턴\nAnswer 2 : Event-Bus Pattern"
  },
  {
    "question": "Question 419.\n모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴은?\n예) 음성 인식, 차량 식별, 신호 해석.",
    "answer": "Answer 1 : 블랙보드 패턴\nAnswer 2 : Blackboard Pattern"
  },
  {
    "question": "Question 420.\n프로그램 코드의 각 라인을 수행하는 방법을 지정하고 기호마다 클래스를 갖도록 구성한 패턴은?\n예) 번역기, 컴파일러, 인터프리터.",
    "answer": "Answer 1 : 인터프리터 패턴\nAnswer 2 : Interpreter Pattern"
  },
  {
    "question": "Question 421.\n소프트웨어의 각 요소들을 객체(Object)로 만든 후, 객체들을 조립해서 소프트웨어를 개발하는 기법은?\n구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있다.\n소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다.\n○○○의 구성요소.\n- 객체(Object).\n- 클래스(Class).\n- 메시지(Message).\n○○○의 특징.\n- 캡슐화(Encapsulation).\n- 상속(Inheritance).\n- 다형성(Polymorphism).\n- 연관성(Relationship).",
    "answer": "Answer 1 : 객체지향\nAnswer 2 : Object-Oriented"
  },
  {
    "question": "Question 422.\n데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈은?\n데이터.\n객체가 가지고 있는 정보로, 속성이나 상태, 분류 등.\n함수.\n① 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘.\n② 각체의 상태를 참조하거나 변경하는 수단.",
    "answer": "Answer 1 : 객체\nAnswer 2 : Object"
  },
  {
    "question": "Question 423.\n공통된 속성과 연산을 갖는 객체의 집합은?\n각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.\n○○○에 속한 각각의 객체를 인스턴스(Instance)라고 한다.",
    "answer": "Answer 1 : 클래스\nAnswer 2 : Class"
  },
  {
    "question": "Question 424.\n객체들 간의 상호작용을 하는데 사용되는 수단으로, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항은?\n○○○를 받은 객체는 대응하는 연산을 수행하여 예상된 결과를 반환한다.",
    "answer": "Answer 1 : 메시지\nAnswer 2 : Message"
  },
  {
    "question": "Question 425.\n외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것은?\n○○○된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적다.\n객체들 간에 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다.",
    "answer": "Answer 1 : 캡슐화\nAnswer 2 : Encapsulation"
  },
  {
    "question": "Question 426.\n상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것은?\n하위 클래스는 물려받은 속성과 연산을 다시 정의하지 않아도 즉시 자신의 속성으로 사용할 수 있다.\n하위 클래스는 ○○○받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있다.",
    "answer": "Answer 1 : 상속\nAnswer 2 : Inheritance"
  },
  {
    "question": "Question 427.\n하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력은?\n객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다.\n예) '+' 연산자의 경우 숫자 클래스에서는 덧셈, 문자 클래스에서는 문자열의 연결 기능으로 사용된다.",
    "answer": "Answer 1 : 다형성\nAnswer 2 : Polymorphism"
  },
  {
    "question": "Question 428.\n두 개 이상의 객체들이 상호 참조하는 관계를 의미하는 것은?\n○○○의 종류.\n① 연관화(Association) : 2개 이상의 객체가 상호 관련되어 있음을 의미함.\n② 분류화(Classfication) : 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것.\n③ 집단화(Aggregation) : 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것.\n④일반화(Generalization) : 공통적인 성질들로 추상화한 상위 객체를 구성하는 것.\n⑤ 특수화/상세화(Specialization) : 상위 객체를 구체화하여 하위 객체를 구성하는 것.",
    "answer": "Answer 1 : 연관성\nAnswer 2 : Relationship"
  },
  {
    "question": "Question 429.\n다음은 연관성의 다섯 가지 종류 중 하나에 대한 설명이다.\n2개 이상의 객체가 상호 관련되어 있음을 의미함.\n종류 : is member of.",
    "answer": "Answer 1 : 연관화\nAnswer 2 : Association"
  },
  {
    "question": "Question 430.\n다음은 연관성의 다섯 가지 종류 중 하나에 대한 설명이다.\n동일한 형의 특성을 갖는 객체들을 모아 구성하는 것.\n종류 : is instance of.",
    "answer": "Answer 1 : 분류화\nAnswer 2 : Classfication"
  },
  {
    "question": "Question 431.\n다음은 연관성의 다섯 가지 종류 중 하나에 대한 설명이다.\n관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것.\n종류 : is part of.",
    "answer": "Answer 1 : 집단화\nAnswer 2 : Aggregation"
  },
  {
    "question": "Question 432.\n다음은 연관성의 다섯 가지 종류 중 하나에 대한 설명이다.\n공통적인 성질들로 추상화한 상위 객체를 구성하는 것.\n종류 : is a.",
    "answer": "Answer 1 : 일반화\nAnswer 2 : Generalization"
  },
  {
    "question": "Question 433.\n다음은 연관성의 다섯 가지 종류 중 하나에 대한 설명이다.\n상위 객체를 구체화하여 하위 객체를 구성하는 것.\n종류 : is a.",
    "answer": "Answer 1 : 특수화\nAnswer 2 : 상세화\nAnswer 3 : Specialization"
  },
  {
    "question": "Question 434.\n사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업은?\n개발을 위한 업무를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석한다.\n클래스를 식별하는 것이 ○○○의 주요 목적이다.",
    "answer": "Answer 1 : 객체지향 분석\nAnswer 2 : OOA\nAnswer 3 : Object Oriented Analysis"
  },
  {
    "question": "Question 435.\n다음은 객체지향 분석의 다섯 가지 방법론 중 하나에 대한 설명이다.\n모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법이다.\n객체 모델링 기법(OMT; Object- Modeling Technique)이라고도 한다.\n분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행한다.\n분석 활동은 객체 모델링 - > 동적 모델링 - > 기능 모델링 순으로 이루어진다.",
    "answer": "Answer 1 : 럼바우(Rumbaugh)의 분석 기법"
  },
  {
    "question": "Question 436.\n정보 모델링(Information Modeling)이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것은?",
    "answer": "Answer 1 : 객체 모델링\nAnswer 2 : Object Modeling"
  },
  {
    "question": "Question 437.\n상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링은?",
    "answer": "Answer 1 : 동적 모델링\nAnswer 2 : Dynamic Modeling"
  },
  {
    "question": "Question 438.\n자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링은?",
    "answer": "Answer 1 : 기능 모델링\nAnswer 2 : Functional Modeling"
  },
  {
    "question": "Question 439.\n다음은 객체지향 분석의 다섯 가지 방법론 중 하나에 대한 설명이다.\n① 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용함.\n② 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함.",
    "answer": "Answer 1 : 부치 방법\nAnswer 2 : Booch"
  },
  {
    "question": "Question 440.\n다음은 객체지향 분석의 다섯 가지 방법론 중 하나에 대한 설명이다.\n유스케이스(Use Case)를 강조하여 사용함.",
    "answer": "Answer 1 : Jacobson 방법"
  },
  {
    "question": "Question 441.\n다음은 객체지향 분석의 다섯 가지 방법론 중 하나에 대한 설명이다.\n① E-R 다이어그램을 사용하여 객체의 행위를 모델링함.\n② 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성함.",
    "answer": "Answer 1 : Coad와 Yourdon 방법"
  },
  {
    "question": "Question 442.\n다음은 객체지향 분석의 다섯 가지 방법론 중 하나에 대한 설명이다.\n분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행함.",
    "answer": "Answer 1 : Wirfs-Brock 방법"
  },
  {
    "question": "Question 443.\n변경이나 확장에 유연한 시스템을 설계하기 위해 지켜져야 할 원칙은?\nSRP, OCP, LSP, ISP, DIP의 다섯 가지 원칙의 앞 글자를 따 SOLID 원칙이라고 부른다.",
    "answer": "Answer 1 : 객체지향 설계 원칙"
  },
  {
    "question": "Question 444.\n다음은 객체지향 설계 원칙의 다섯 가지 종류 중 하나에 대한 설명이다.\n객체는 단 하나의 책임만 가져야 한다는 원칙.",
    "answer": "Answer 1 : 단일 책임 원칙\nAnswer 2 : SRP"
  },
  {
    "question": "Question 445.\n다음은 객체지향 설계 원칙의 다섯 가지 종류 중 하나에 대한 설명이다.\n기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설게해야 한다는 원칙.",
    "answer": "Answer 1 : 개방- 폐쇄 원칙\nAnswer 2 : OCP"
  },
  {
    "question": "Question 446.\n다음은 객체지향 설계 원칙의 다섯 가지 종류 중 하나에 대한 설명이다.\n자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙.",
    "answer": "Answer 1 : 리스코프 치환 원칙\nAnswer 2 : LSP"
  },
  {
    "question": "Question 447.\n다음은 객체지향 설계 원칙의 다섯 가지 종류 중 하나에 대한 설명이다.\n자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙.",
    "answer": "Answer 1 : 인터페이스 분리 원칙\nAnswer 2 : ISP"
  },
  {
    "question": "Question 448.\n다음은 객체지향 설계 원칙의 다섯 가지 종류 중 하나에 대한 설명이다.\n의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙.",
    "answer": "Answer 1 : 의존 역전 원칙\nAnswer 2 : DIP"
  },
  {
    "question": "Question 449.\n모듈화를 통해 분리된 시스템의 각 기능으로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등을 의미하는 것은?\n○○○의 기능적 독립성은 소프트웨어를 구성하는 각 ○○○의 기능이 서로 독립됨을 의미한다.\n○○○의 독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정된다.",
    "answer": "Answer 1 : 모듈\nAnswer 2 : Module"
  },
  {
    "question": "Question 450.\n모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계는?\n○○○이 약할수록 품질이 높고, 강할수록 품질이 낮다.\n○○○의 강도 : .\n내용 ○○○ > 공통 ○○○ > 외부 ○○○ > 제어 ○○○ > 스탬프 ○○○ > 자료 ○○○",
    "answer": "Answer 1 : 결합도\nAnswer 2 : Coupling"
  },
  {
    "question": "Question 451.\n다음은 결합도의 여섯 가지 종류 중 하나에 대한 설명이다.\n한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도.",
    "answer": "Answer 1 : 내용 결합도\nAnswer 2 : Content Coupling"
  },
  {
    "question": "Question 452.\n다음은 결합도의 여섯 가지 종류 중 하나에 대한 설명이다.\n① 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도.\n② 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용하는 때의 결합도.",
    "answer": "Answer 1 : 공통 결합도\nAnswer 2 : 공유 결합도\nAnswer 3 : Common Coupling"
  },
  {
    "question": "Question 453.\n다음은 결합도의 여섯 가지 종류 중 하나에 대한 설명이다.\n어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도",
    "answer": "Answer 1 : 외부 결합도\nAnswer 2 : External Coupling"
  },
  {
    "question": "Question 454.\n다음은 결합도의 여섯 가지 종류 중 하나에 대한 설명이다.\n① 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도.\n② 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위모듈에게 처리 명령을 내리는 권리 전도 현상이 발생하게 됨.",
    "answer": "Answer 1 : 제어 결합도\nAnswer 2 : Control Coupling"
  },
  {
    "question": "Question 455.\n다음은 결합도의 여섯 가지 종류 중 하나에 대한 설명이다.\n모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도.",
    "answer": "Answer 1 : 스탬프 결합도\nAnswer 2 : 검인 결합도\nAnswer 3 : Stamp Coupling"
  },
  {
    "question": "Question 456.\n다음은 결합도의 여섯 가지 종류 중 하나에 대한 설명이다.\n모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도.",
    "answer": "Answer 1 : 자료 결합도\nAnswer 2 : Data Coupling"
  },
  {
    "question": "Question 457.\n모듈의 내부 요소들이 서로 관련되어 있는 정도는?\n○○○가 강할수록 품질이 높고, 약할수록 품질이 낮다.\n○○○의 강도 : .\n기능적 ○○○ > 순차적 ○○○ > 교환적 ○○○ > 절차적 ○○○ > 시간적 ○○○ > 논리적 ○○○ > 우연적 ○○○.",
    "answer": "Answer 1 : 응집도\nAnswer 2 : Cohesion"
  },
  {
    "question": "Question 458.\n다음은 응집도의 일곱 가지 종류 중 하나에 대한 설명이다.\n모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도.",
    "answer": "Answer 1 : 기능적 응집도\nAnswer 2 : Functional Cohesion"
  },
  {
    "question": "Question 459.\n다음은 응집도의 일곱 가지 종류 중 하나에 대한 설명이다.\n모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도.",
    "answer": "Answer 1 : 순차적 응집도\nAnswer 2 : Sequential Cohesion"
  },
  {
    "question": "Question 460.\n다음은 응집도의 일곱 가지 종류 중 하나에 대한 설명이다.\n동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도.",
    "answer": "Answer 1 : 교환적 응집도\nAnswer 2 : 통신적 응집도\nAnswer 3 : Communication Cohesion"
  },
  {
    "question": "Question 461.\n다음은 응집도의 일곱 가지 종류 중 하나에 대한 설명이다.\n모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도.",
    "answer": "Answer 1 : 절차적 응집도\nAnswer 2 : Procedural Cohesion"
  },
  {
    "question": "Question 462.\n다음은 응집도의 일곱 가지 종류 중 하나에 대한 설명이다.\n특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도.",
    "answer": "Answer 1 : 시간적 응집도\nAnswer 2 : Temporal Cohesion"
  },
  {
    "question": "Question 463.\n다음은 응집도의 일곱 가지 종류 중 하나에 대한 설명이다.\n유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도.",
    "answer": "Answer 1 : 논리적 응집도\nAnswer 2 : Logical Cohesion"
  },
  {
    "question": "Question 464.\n다음은 응집도의 일곱 가지 종류 중 하나에 대한 설명이다.\n모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도.",
    "answer": "Answer 1 : 우연적 응집도\nAnswer 2 : Coincidental Cohesion"
  },
  {
    "question": "Question 465.\n어떤 모듈을 제어하는 모듈의 수는?\n○○○이 높다는 것은 재사용 측면에서 설계가 잘 되어 있다고 볼 수 있다.\n○○○이 높은 경우 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요하다.",
    "answer": "Answer 1 : 팬인\nAnswer 2 : Fan- In"
  },
  {
    "question": "Question 466.\n어떤 모듈에 의해 제어되는 모듈의 수는?",
    "answer": "Answer 1 : 팬아웃\nAnswer 2 : Fan- Out"
  },
  {
    "question": "Question 467.\n논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법은?\n박스 다이어그램, Chapin Chart라고도 한다.\nGOTO나 화살표를 사용하지 않는다.\n연속, 선택 및 다중 선택, 반복의 3가지 제어 논리 구조로 표현한다.\n조건이 복합되어 있는 곳의 처리를 시작적으로 명확히 식별하는 데 적합하다.",
    "answer": "Answer 1 : N- S 차트\nAnswer 2 : Nassi- Schneideman Chart"
  },
  {
    "question": "Question 468.\n소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것은?\n○○○로 구현되는 하나의 기능을 단위 기능이라고 부른다.\n독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 한다.",
    "answer": "Answer 1 : 단위 모듈\nAnswer 2 : Unit Module"
  },
  {
    "question": "Question 469.\n모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합은?\n복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다.",
    "answer": "Answer 1 : IPC\nAnswer 2 : Inter Process Communication"
  },
  {
    "question": "Question 470.\n다음은 IPC의 대표 메소드 다섯 가지 중 하나에 대한 설명이다.\n공유 가능한 메모리를 구성하여 다수의 프로세스가 통신하는 방식.",
    "answer": "Answer 1 : Shared Memory"
  },
  {
    "question": "Question 471.\n다음은 IPC의 대표 메소드 다섯 가지 중 하나에 대한 설명이다.\n네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스 간에 통신하는 방식.",
    "answer": "Answer 1 : Socket"
  },
  {
    "question": "Question 472.\n다음은 IPC의 대표 메소드 다섯 가지 중 하나에 대한 설명이다.\n공유 자원에 대한 접근 제어를 통해 통신하는 방식.",
    "answer": "Answer 1 : Semaphores"
  },
  {
    "question": "Question 473.\n다음은 IPC의 대표 메소드 다섯 가지 중 하나에 대한 설명이다.\n① 'Pipe'라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식.\n② Pipe는 하나의 프로세스가 이용 중이라면 다른 프로세스는 접근할 수 없음.",
    "answer": "Answer 1 : Pipe&named Pipes"
  },
  {
    "question": "Question 474.\n다음은 IPC의 대표 메소드 다섯 가지 중 하나에 대한 설명이다.\n메시지가 발생하면 이를 전달하는 방식으로 통신하는 방식.",
    "answer": "Answer 1 : Message Queueing"
  },
  {
    "question": "Question 475.\n프로그램의 단위 기능으로 구현된 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것은?\n단위 테스트(Unit Test)라고도 불린다.\n○○○의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없다.",
    "answer": "Answer 1 : 단위 모듈 테스트"
  },
  {
    "question": "Question 476.\n구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서를 의미하는 것은?\n○○○를 이용하지 않은 테스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있다.\nISO/IEC/IEEE 29119- 3 표준에 따른 ○○○의 구성 요소.\n식별자(Identifier) : 항목 식별자, 일련번호.\n테스트 항목(Test Item) : 테스트 대상(모듈 또는 기능).\n입력 명세(Input Specification) : 입력 데이터 또는 테스트 조건.\n출력 명세(Output Specification) : ○○○ 수행 시 예상되는 출력 결과.\n환경 설정(Environmental Needs) : 필요한 하드웨어나 소프트웨어의 환경.\n특수 절차 요구(Special Procedure Requirment) : ○○○ 수행 시 특별히 요구되는 절차.\n의존성 기술(Inter-case DEpendencies) : ○○○ 간의 의존성.",
    "answer": "Answer 1 : 테스트 케이스\nAnswer 2 : Test Case"
  },
  {
    "question": "Question 477.\n여러 프로그램에서 공통으로 사용할 수 있는 모듈은?\n자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능들이 ○○○로 구성될 수 있다.\n○○○을 구현할 때는 해당 기능을 명확히 이해할 수 있도록 명세 기법을 준수해야 한다.",
    "answer": "Answer 1 : 공통 모듈"
  },
  {
    "question": "Question 478.\n다음은 공통 모듈 명세의 다섯 가지 기법 중 하나에 대한 설명이다.\n시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성함.",
    "answer": "Answer 1 : 정확성\nAnswer 2 : Correctness"
  },
  {
    "question": "Question 479.\n다음은 공통 모듈 명세의 다섯 가지 기법 중 하나에 대한 설명이다.\n해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성함.",
    "answer": "Answer 1 : 명확성\nAnswer 2 : Clarity"
  },
  {
    "question": "Question 480.\n다음은 공통 모듈 명세의 다섯 가지 기법 중 하나에 대한 설명이다.\n시스템 구현을 위해 필요한 모든 것을 기술함.",
    "answer": "Answer 1 : 완전성\nAnswer 2 : Completeness"
  },
  {
    "question": "Question 481.\n다음은 공통 모듈 명세의 다섯 가지 기법 중 하나에 대한 설명이다.\n공통 기능들 간 상호 충돌이 발생하지 않도록 작성함.",
    "answer": "Answer 1 : 일관성\nAnswer 2 : Consistency"
  },
  {
    "question": "Question 482.\n다음은 공통 모듈 명세의 다섯 가지 기법 중 하나에 대한 설명이다.\n기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성함.",
    "answer": "Answer 1 : 추적성\nAnswer 2 : Traceability"
  },
  {
    "question": "Question 483.\n이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업은?\n새로 개발하는데 필요한 비용과 시간을 아낄 수 있다.\n누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야 한다.\n○○○ 규모에 따른 분류.\n함수와 객체 : 클래스나 메소드 단위의 소스 코드를 재사용함.\n컴포넌트 : .\n- 독립적인 업무 또는 기능을 수행하는 실행 코드 기반으로 작성된 모듈.\n- 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용함.\n애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용함.",
    "answer": "Answer 1 : 재사용\nAnswer 2 : Reuse"
  },
  {
    "question": "Question 484.\n자료의 분류·조합·집계·추출을 용이하게 하기 위해 사용하는 기호는?\n정보를 신속·정확·명료하게 전달할 수 있게 한다.\n일정한 규칙에 따라 작성된다.\n정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미친다.",
    "answer": "Answer 1 : 코드\nAnswer 2 : Code"
  },
  {
    "question": "Question 485.\n다음은 코드의 다섯 가지 주요 기능 중 하나에 대한 설명이다.\n데이터 간의 성격에 따라 구분이 가능함.",
    "answer": "Answer 1 : 식별 기능"
  },
  {
    "question": "Question 486.\n다음은 코드의 다섯 가지 주요 기능 중 하나에 대한 설명이다.\n특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 할 수 있음.",
    "answer": "Answer 1 : 분류기능"
  },
  {
    "question": "Question 487.\n다음은 코드의 다섯 가지 주요 기능 중 하나에 대한 설명이다.\n의미를 부여하여 나열할 수 있음.",
    "answer": "Answer 1 : 배열 기능"
  },
  {
    "question": "Question 488.\n다음은 코드의 다섯 가지 주요 기능 중 하나에 대한 설명이다.\n다양한 데이터를 기준에 맞추어 표현할 수 있음.",
    "answer": "Answer 1 : 표준화 기능"
  },
  {
    "question": "Question 489.\n다음은 코드의 다섯 가지 주요 기능 중 하나에 대한 설명이다.\n복잡한 데이터를 간소화할 수 있음.",
    "answer": "Answer 1 : 간소화 기능"
  },
  {
    "question": "Question 490.\n다음은 코드의 일곱 가지 종류 중 하나에 대한 설명이다.\n자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법으로, 순서 코드 또는 일련번호 코드라고 함.\n예) 1, 2, 3, 4, ….",
    "answer": "Answer 1 : 순차 코드\nAnswer 2 : Sequence Code"
  },
  {
    "question": "Question 491.\n다음은 코드의 일곱 가지 종류 중 하나에 대한 설명이다.\n코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법으로, 구분 코드라고도 함.\n예) 1001~1100 : 총무부, 1101~1200 : 영업부.",
    "answer": "Answer 1 : 블록 코드\nAnswer 2 : Block Code"
  },
  {
    "question": "Question 492.\n다음은 코드의 일곱 가지 종류 중 하나에 대한 설명이다.\n코드화 대상 항목을 0 ~ 9 까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 함.\n코드 대상 항목의 추가가 용이하며 무제한적으로 확대할 수 있으나 자릿수가 길어질 수 있고 기계 처리에는 적합하지 않다.\n예) 1000 : 공학, 1100 : 소프트웨어 공학, 1100 : 소프트웨어 설계.",
    "answer": "Answer 1 : 10진 코드\nAnswer 2 : Decimal Code"
  },
  {
    "question": "Question 493.\n다음은 코드의 일곱 가지 종류 중 하나에 대한 설명이다.\n코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법임.\n예) 1-01-001 : 본사-총무부-인사계, 2-01-001 : 지사-총무부-인사계.",
    "answer": "Answer 1 : 그룹 분류 코드\nAnswer 2 : Group Classification"
  },
  {
    "question": "Question 494.\n다음은 코드의 일곱 가지 종류 중 하나에 대한 설명이다.\n코드화 대상 항목의 명칭이나 약호와 관계가 있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법임.\n예) TV-40 : 40인치 TV, L-15-220 : 12W 220V의 램프.",
    "answer": "Answer 1 : 연상 코드\nAnswer 2 : Mnemonic Code"
  },
  {
    "question": "Question 495.\n다음은 코드의 일곱 가지 종류 중 하나에 대한 설명이다.\n코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법으로, 유효 숫자 코드라고도 함.\n예)120-720-1500 : 두께×폭×길이가 120×720×1500인 강판.",
    "answer": "Answer 1 : 표의 숫자 코드\nAnswer 2 : Significant Digit Code"
  },
  {
    "question": "Question 496.\n다음은 코드의 일곱 가지 종류 중 하나에 대한 설명이다.\n필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법임.\n예) 연상 코드＋순차 코드.\n예) KE-711 : 대한항공 711기, AC-253 : 에어캐나다 253기",
    "answer": "Answer 1 : 합성 코드\nAnswer 2 : Combined Code"
  },
  {
    "question": "Question 497.\n모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미하는 것은?\n문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있다.\n'바퀴를 다시 발명하지 마라(Don't reinvent the wheel)'라는 말과 같이, 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 ○○○을 참고하여 적용하는 것이 더 효율적이다.\nGOF의 ○○○은 생성 패턴, 구조 패턴, 행위 패턴으로 구분된다.",
    "answer": "Answer 1 : 디자인 패턴\nAnswer 2 : Design Pattern"
  },
  {
    "question": "Question 498.\n클래스나 객체의 생성과 참조 과정을 정의하는 패턴은?",
    "answer": "Answer 1 : 생성 패턴\nAnswer 2 : Creational Pattern"
  },
  {
    "question": "Question 499.\n다음은 생성 패턴의 다섯 가지 종류 중 하나에 대한 설명이다.\n① 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관·의존하는 객체들의 그룹으로 생성하여 추상적으로 표현함.\n② 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능함.",
    "answer": "Answer 1 : 추상 팩토리\nAnswer 2 : Abstract Factory"
  },
  {
    "question": "Question 500.\n다음은 생성 패턴의 다섯 가지 종류 중 하나에 대한 설명이다.\n① 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함.\n② 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음.",
    "answer": "Answer 1 : 빌더\nAnswer 2 : Builder"
  },
  {
    "question": "Question 501.\n다음은 생성 패턴의 다섯 가지 종류 중 하나에 대한 설명이다.\n① 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴.\n② 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함.\n③ 가상 생성자(Virtual Constructor) 패턴이라고도 함.",
    "answer": "Answer 1 : 팩토리 메소드\nAnswer 2 : Factory Method"
  },
  {
    "question": "Question 502.\n다음은 생성 패턴의 다섯 가지 종류 중 하나에 대한 설명이다.\n① 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴.\n② 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용함.",
    "answer": "Answer 1 : 프로토타입\nAnswer 2 : Prototype"
  },
  {
    "question": "Question 503.\n다음은 생성 패턴의 다섯 가지 종류 중 하나에 대한 설명이다.\n① 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음.\n② 클래스 내에서 인스터스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있음.",
    "answer": "Answer 1 : 싱글톤\nAnswer 2 : Singeton"
  },
  {
    "question": "Question 504.\n구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴은?",
    "answer": "Answer 1 : 구조 패턴\nAnswer 2 : Structural Pattern"
  },
  {
    "question": "Question 505.\n다음은 구조 패턴의 일곱 가지 종류 중 하나에 대한 설명이다.\n① 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴.\n② 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용함.",
    "answer": "Answer 1 : 어댑터\nAnswer 2 : Adapter"
  },
  {
    "question": "Question 506.\n다음은 구조 패턴의 일곱 가지 종류 중 하나에 대한 설명이다.\n① 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴.\n② 기능과 구현을 두 개의 별도 클래스로 구현함.",
    "answer": "Answer 1 : 브리지\nAnswer 2 : Bridge"
  },
  {
    "question": "Question 507.\n다음은 구조 패턴의 일곱 가지 종류 중 하나에 대한 설명이다.\n① 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴.\n② 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음.",
    "answer": "Answer 1 : 컴포지트\nAnswer 2 : Composite"
  },
  {
    "question": "Question 508.\n다음은 구조 패턴의 일곱 가지 종류 중 하나에 대한 설명이다.\n① 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴.\n② 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현함.",
    "answer": "Answer 1 : 데코레이터\nAnswer 2 : Decorator"
  },
  {
    "question": "Question 509.\n다음은 구조 패턴의 일곱 가지 종류 중 하나에 대한 설명이다.\n① 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴.\n② 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요함.",
    "answer": "Answer 1 : 퍼싸드\nAnswer 2 : Facade"
  },
  {
    "question": "Question 510.\n다음은 구조 패턴의 일곱 가지 종류 중 하나에 대한 설명이다.\n① 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한한 공유해서 사용함으로써 메모리를 절약하는 패턴.\n② 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음.",
    "answer": "Answer 1 : 플라이웨이트\nAnswer 2 : Flyweight"
  },
  {
    "question": "Question 511.\n다음은 구조 패턴의 일곱 가지 종류 중 하나에 대한 설명이다.\n① 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴.\n② 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용함.",
    "answer": "Answer 1 : 프록시\nAnswer 2 : Proxy"
  },
  {
    "question": "Question 512.\n클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴은?",
    "answer": "Answer 1 : 행위 패턴\nAnswer 2 : Behavioral Pattern"
  },
  {
    "question": "Question 513.\n다음은 행위 패턴의 열 가지 종류 중 하나에 대한 설명이다.\n1, 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴.\n② 요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶어 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감.",
    "answer": "Answer 1 : 책임 연쇄\nAnswer 2 : Chain of Responsibility"
  },
  {
    "question": "Question 514.\n다음은 행위 패턴의 열 가지 종류 중 하나에 대한 설명이다.\n① 요청을 객체의 형태로 캡슐화하여 재이용하거나 최소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴.\n② 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함.",
    "answer": "Answer 1 : 커맨드\nAnswer 2 : Command"
  },
  {
    "question": "Question 515.\n다음은 행위 패턴의 열 가지 종류 중 하나에 대한 설명이다.\n① 언어에 문법 표현을 정의하는 패턴.\n② SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용함.",
    "answer": "Answer 1 : 인터프리터\nAnswer 2 : Interpreter"
  },
  {
    "question": "Question 516.\n다음은 행위 패턴의 열 가지 종류 중 하나에 대한 설명이다.\n① 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴.\n② 내부 표현 방법의 노출 없이 순차적인 접근이 가능함.",
    "answer": "Answer 1 : 반복자\nAnswer 2 : Iterator"
  },
  {
    "question": "Question 517.\n다음은 행위 패턴의 열 가지 종류 중 하나에 대한 설명이다.\n① 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴.\n② Ctrl + Z와 같은 되돌리기 기능을 개발할 때 주로 이용함.",
    "answer": "Answer 1 : 메멘토\nAnswer 2 : Memento"
  },
  {
    "question": "Question 518.\n다음은 행위 패턴의 열 가지 종류 중 하나에 대한 설명이다.\n① 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴.\n② 일대다의 의존성을 정의함.\n③ 주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용함.",
    "answer": "Answer 1 : 옵서버\nAnswer 2 : Observer"
  },
  {
    "question": "Question 519.\n다음은 행위 패턴의 열 가지 종류 중 하나에 대한 설명이다.\n① 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴.\n② 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리함.",
    "answer": "Answer 1 : 상태\nAnswer 2 : State"
  },
  {
    "question": "Question 520.\n다음은 행위 패턴의 열 가지 종류 중 하나에 대한 설명이다.\n① 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴.\n② 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능함.",
    "answer": "Answer 1 : 전략\nAnswer 2 : Strategy"
  },
  {
    "question": "Question 521.\n다음은 행위 패턴의 열 가지 종류 중 하나에 대한 설명이다.\n① 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴.\n② 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌.",
    "answer": "Answer 1 : 템플릿 메소드\nAnswer 2 : Template Method"
  },
  {
    "question": "Question 522.\n개발에 필요한 환경, 즉 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger) 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공하는 환경을 말하는 것은?\n○○○ 도구는 ○○○을 제공하는 소프트웨어를 의미한다.\n○○○ 도구는 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정이 용이하다.",
    "answer": "Answer 1 : 통합 개발 환경\nAnswer 2 : IDE\nAnswer 3 : Integrated Development Environment"
  },
  {
    "question": "Question 523.\n소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물을 말하는 것은?\n○○○는 전처리(Preprocessing), 컴파일(Compile) 등의 작업을 수행한다.",
    "answer": "Answer 1 : 빌드 도구"
  },
  {
    "question": "Question 524.\n개발에 참여하는 사람들이 서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구는?\n협업 소프트웨어, 그룹웨어(Groupware) 등으로도 불린다.\n일정 관리, 업무흐름 관리, 정보 공유, 커뮤니케이션 등의 업무 보조 도구가 포함된다.",
    "answer": "Answer 1 : 협업 도구"
  },
  {
    "question": "Question 525.\n웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 웹 애플리케이션 서버(WAS)에 탑재하는 것의 의미하는 것은?\n○○○에 사용되는 프로그래밍 언어에는 Java, JavaScript, Python, PHP, Ruby 등이 있다.\n각 프로그래밍 언어에는 해당 언어로 서버 프로그램을 개발할 수 있도록 지원하는 프레임워크가 있다.",
    "answer": "Answer 1 : 서버 개발"
  },
  {
    "question": "Question 526.\n서버 프로그램 개발 시 다양한 네트워크 설정, 요청 및 응답 처리, 아키텍처 모델 구현 등을 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 소프트웨어를 의미하는 것은?\n○○○의 대부분은 모델- 뷰- 컨트롤러(MVC) 패턴을 기반으로 개발되었다.",
    "answer": "Answer 1 : 서버 개발 프레임워크"
  },
  {
    "question": "Question 527.\nDTO/VO, SQL, DAO, Service, Controller를 각각 구현하는 과정은?\n구현 순서는 개발자가 임의로 변경할 수 있다.\n개발하려는 서버 프로그램의 목적, 개발 언어, 규모 등의 이유로 통합하거나 세분화할 수 있다.",
    "answer": "Answer 1 : 서버 개발 과정"
  },
  {
    "question": "Question 528.\n다음은 서버 개발 구현의 다섯 가지 과정 둥 하나에 대한 설명이다.\n① 데이터 교환을 위해 사용할 객체를 만드는 과정.\n② 송·수신할 데이터의 자료형(Data Type)에 맞는 변수 및 객체를 생성함.",
    "answer": "Answer 1 : DTO/VO 구현\nAnswer 2 : Data Transfer Object/Value Object 구현"
  },
  {
    "question": "Question 529.\n다음은 서버 개발 구현의 다섯 가지 과정 둥 하나에 대한 설명이다.\n① 데이터의 삽입, 변경, 삭제 등의 작업을 수행할 SQL문을 생성하는 과정.\n② SQL문은 소스 코드 내에 직접 입력, 또는 별도의 XML 파일로 관리함.",
    "answer": "Answer 1 : SQL 구현"
  },
  {
    "question": "Question 530.\n다음은 서버 개발 구현의 다섯 가지 과정 둥 하나에 대한 설명이다.\n데이터베이스에 접근하고, SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정.",
    "answer": "Answer 1 : DAO 구현\nAnswer 2 : Data Access Object 구현"
  },
  {
    "question": "Question 531.\n다음은 서버 개발 구현의 다섯 가지 과정 둥 하나에 대한 설명이다.\n사용자의 요청에 응답하기 위한 로직을 구현하는 과정.",
    "answer": "Answer 1 : Service 구현"
  },
  {
    "question": "Question 532.\n다음은 서버 개발 구현의 다섯 가지 과정 둥 하나에 대한 설명이다.\n사용자의 요청에 적절한 서비스를 호출하여, 그 결과를 사용자에게 반환하는 코드를 구현하는 과정.",
    "answer": "Answer 1 : Controller 구현"
  },
  {
    "question": "Question 533.\n사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램을 의미하는 것은?",
    "answer": "Answer 1 : 배치 프로그램\nAnswer 2 : Batch Program"
  },
  {
    "question": "Question 534.\n다음은 배치 프로그램의 다섯 가지 필수 요소 중 하나에 대한 설명이다.\n대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함.",
    "answer": "Answer 1 : 대용량 데이터"
  },
  {
    "question": "Question 535.\n다음은 배치 프로그램의 다섯 가지 필수 요소 중 하나에 대한 설명이다.\n심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함.",
    "answer": "Answer 1 : 자동화"
  },
  {
    "question": "Question 536.\n다음은 배치 프로그램의 다섯 가지 필수 요소 중 하나에 대한 설명이다.\n잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함.",
    "answer": "Answer 1 : 견고성"
  },
  {
    "question": "Question 537.\n다음은 배치 프로그램의 다섯 가지 필수 요소 중 하나에 대한 설명이다.\n오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함.",
    "answer": "Answer 1 : 안정성\nAnswer 2 : 신뢰성"
  },
  {
    "question": "Question 538.\n다음은 배치 프로그램의 다섯 가지 필수 요소 중 하나에 대한 설명이다.\n① 다른 응용 프로그램의 수행을 방해하지 않아야 함.\n② 지정된 시간 내에 처리가 완료되어야 함.",
    "answer": "Answer 1 : 성능"
  },
  {
    "question": "Question 539.\n일괄 처리(Batch Processing) 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구는?\n특정 업무(Job)를 원하는 시간에 처리할 수 있도록 지원한다는 특성 때문에 잡 스케줄러(Job Scheduler)라고도 불린다.",
    "answer": "Answer 1 : 배치 스케줄러\nAnswer 2 : Batch Scheduler"
  },
  {
    "question": "Question 540.\n다음은 배치 스케줄러의 세 가지 종류 중 하나에 대한 설명이다.\n① Spring Source 사와 Accenture 사가 2007년 공동 개발한 오픈 소스 프레임워크.\n② 로그 관리, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등의 다양한 기능을 제공함.",
    "answer": "Answer 1 : 스프링 배치\nAnswer 2 : Spring Batch"
  },
  {
    "question": "Question 541.\n다음은 배치 스케줄러의 세 가지 종류 중 하나에 대한 설명이다.\n① 스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리.\n② 수행할 작업과 수행 시간을 관리하는 요소들을 분리하여 일괄 처리 작업에 유연성을 제공함.",
    "answer": "Answer 1 : Quartz"
  },
  {
    "question": "Question 542.\n다음은 배치 스케줄러의 세 가지 종류 중 하나에 대한 설명이다.\n① 리눅스의 기본 스케줄러 도구.\n② crontab 명령어를 통해 작업을 예약할 수 있음.",
    "answer": "Answer 1 : Cron"
  },
  {
    "question": "Question 543.\n개발할 시스템과 외부 시스템을 연동하는데 필요한 시스템 인터페이스에 대한 요구사항을 기술한 것은?\n○○○ 명세서의 구성 요소.\n- 인터페이스 이름.\n- 연계 대상 시스템.\n- 연계 범위 및 내용.\n- 연계 방식.\n- 송신 데이터.\n- 인터페이스 주기.\n- 기타 고려사항.",
    "answer": "Answer 1 : 시스템 인터페이스 요구사항"
  },
  {
    "question": "Question 544.\n요구사항을 분류하고 구체적으로 명세한 후 이를 이해관계자에게 전달하는 일련의 과정은?\n소프트웨어 요구사항 분석 기법을 적절히 이용한다.\n요구사항의 분해가 필요한 경우 적절한 수준으로 세분화한다.\n요구사항 분석 시 누락된 요구사항이나 제한 조건을 추가한다.\n요구사항에 대한 상대적 중요도를 평가하여 우선순위를 부여한다.\n○○○ 절차.\n① 시스템 인터페이스 관련 요구사항을 선별하여 별도로 요구사항 목록을 만든다.\n② 요구사항과 관련된 자료를 준비한다.\n③ 기능저인 요구사항과 비기능적인 요구사항으로 분류한다.\n④요구사항을 분석하고 요구사항 명세서에 내용을 추가하거나 수정한다.\n⑤ 추가·수정한 요구사항 명세서와 요구사항 목록을 관련 이해관계자에게 전달한다.",
    "answer": "Answer 1 : 시스템 인터페이스 요구사항 분석"
  },
  {
    "question": "Question 545.\n사용자들의 요구사항이 요구사항 명세서에 정확하고 완전하게 기술되었는지 검토하고 개발 범위의 기준인 베이스라인을 설정하는 것은?\n○○○ 수행 순서.\n① 요구사항 검토 계획 수립 : 검토 기준 및 방법, 참여자, 체크리스트, 관련 자료, 일정 등의 검토 계획 수립.\n② 검토 및 오류 수정 : 인터페이스 요구사항 명세서 검토 및 오류 목록과 시정 조치서 작성.\n③ 베이스라인 설정 : 검증된 인터페이스 요구사항을 승인받은 후 요구사항 명세서의 베이스라인 설정.",
    "answer": "Answer 1 : 인터페이스 요구사항 검증"
  },
  {
    "question": "Question 546.\n요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 결함 여부를 검토 담당자들이 수작업으로 분석하는 방법은?",
    "answer": "Answer 1 : 요구사항 검토\nAnswer 2 : Requirements Review"
  },
  {
    "question": "Question 547.\n다음은 요구사항 검토의 세 가지 방법 중 하나에 대한 설명이다.\n요구사항 명세서 작성자가 명세서 내용을 직접 설명하고 동료들이 이를 들으면서 결함을 발견하는 형태의 검토 방법.",
    "answer": "Answer 1 : 동료검토\nAnswer 2 : Peer Review"
  },
  {
    "question": "Question 548.\n다음은 요구사항 검토의 세 가지 방법 중 하나에 대한 설명이다.\n검토 회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토 방법.",
    "answer": "Answer 1 : 워크스루\nAnswer 2 : Walk Through"
  },
  {
    "question": "Question 549.\n다음은 요구사항 검토의 세 가지 방법 중 하나에 대한 설명이다.\n요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견하는 형태의 검토 방법.",
    "answer": "Answer 1 : 인스펙션\nAnswer 2 : Inspection"
  },
  {
    "question": "Question 550.\n사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품(Prototype)을 만들어 최정 결과물을 예측하는 것은?",
    "answer": "Answer 1 : 프로토타이핑\nAnswer 2 : Prototyping"
  },
  {
    "question": "Question 551.\n요구사항은 테스트할 수 있도록 작성되어야 하며, 이를 위해 테스트 케이스를 생성하여 요구사항이 현실적으로 테스트 가능한지를 검토하는 것은?",
    "answer": "Answer 1 : 테스트 설계"
  },
  {
    "question": "Question 552.\n일관성 분석(Consistency Analysis)을 통해 요구사항 변경사항의 추적, 분석, 관리, 표준 준수 여부를 확인하는 것은?",
    "answer": "Answer 1 : CASE 도구 활용"
  },
  {
    "question": "Question 553.\n다음은 인터페이스 요구사항 검증 시 확인해야 할 입곱 가지 항목 중 하나에 대한 설명이다.\n사용자의 모든 요구사항이 누락되지 않고 완전하게 반영되어 있는가?",
    "answer": "Answer 1 : 완전성\nAnswer 2 : Completeness"
  },
  {
    "question": "Question 554.\n다음은 인터페이스 요구사항 검증 시 확인해야 할 입곱 가지 항목 중 하나에 대한 설명이다.\n요구사항이 모순되거나 충돌되는 점 없이 ○○○을 유지하고 있는가?",
    "answer": "Answer 1 : 일관성\nAnswer 2 : Consistency"
  },
  {
    "question": "Question 555.\n다음은 인터페이스 요구사항 검증 시 확인해야 할 입곱 가지 항목 중 하나에 대한 설명이다.\n모든 참여자가 요구사항을 명확히 이해할 수 있는가?",
    "answer": "Answer 1 : 명확성\nAnswer 2 : Unambiguity"
  },
  {
    "question": "Question 556.\n다음은 인터페이스 요구사항 검증 시 확인해야 할 입곱 가지 항목 중 하나에 대한 설명이다.\n요구사항이 '어떻게(How to)'보다 '무엇을(What)'에 중점을 두고 있는가?",
    "answer": "Answer 1 : 기능성\nAnswer 2 : Functionality"
  },
  {
    "question": "Question 557.\n다음은 인터페이스 요구사항 검증 시 확인해야 할 입곱 가지 항목 중 하나에 대한 설명이다.\n요구사항이 사용자의 요구를 모두 만족하고, 개발된 소프트웨어가 사용자의 요구 내용과 일치하는지를 검증할 수 있는가?",
    "answer": "Answer 1 : 검증 가능성\nAnswer 2 : Verifiability"
  },
  {
    "question": "Question 558.\n다음은 인터페이스 요구사항 검증 시 확인해야 할 입곱 가지 항목 중 하나에 대한 설명이다.\n요구사항 명세서와 설계서를 추적할 수 있는가?",
    "answer": "Answer 1 : 추적 가능성\nAnswer 2 : Traceability"
  },
  {
    "question": "Question 559.\n다음은 인터페이스 요구사항 검증 시 확인해야 할 입곱 가지 항목 중 하나에 대한 설명이다.\n요구사항 명세서의 변경이 쉽도록 작성되었는가?",
    "answer": "Answer 1 : 변경 용이성\nAnswer 2 : Easily Changeable"
  },
  {
    "question": "Question 560.\n송·수신 시스템 사이에서 교환되는 데이터로, 규격화된 표준 형식에 따라 전송되는 것은?\n교환되는 데이터의 종류.\n- 인터페이스 표준 항목.\n- 송·수신 데이터 항목.\n- 공통 코드.",
    "answer": "Answer 1 : 식별 대상 데이터"
  },
  {
    "question": "Question 561.\n송·수신 시스템을 연계하는데 표준적으로 필요한 데이터는?",
    "answer": "Answer 1 : 인터페이스 표준 항목"
  },
  {
    "question": "Question 562.\n송·수신 시스템이 업무를 수행하는 데 사용하는 데이터는?\n전송되는 데이터 항목과 순서는 인터페이스별로 다르다.",
    "answer": "Answer 1 : 송·수신 데이터 항목"
  },
  {
    "question": "Question 563.\n시스템들에서 공통으로 사용하는 코드는?\n연계 시스템이나 연계 소프트웨어에서 사용하는 상태 및 오류 코드 등의 항목에 대해 코드값과 코드명, 코드 설명 등을 ○○○로 관리한다.",
    "answer": "Answer 1 : 공통 코드"
  },
  {
    "question": "Question 564.\n개발할 시스템과 내·외부 시스템 사이에서 전송되는 정보들의 방향성을 식별하는 것은?\n개발할 시스템과 내·외부 시스템에 대한 각각의 인터페이스 목록을 확인하여 ○○○한다.\n식별한 정보 흐름을 기반으로 송·수신 시스템 사이에서 교환되는 주요 데이터 항목이나 정보 그룹을 도출한다.",
    "answer": "Answer 1 : 정보 흐름 식별"
  },
  {
    "question": "Question 565.\n개발할 시스템과 연계할 내·외부 시스템 사이의 정보 흐름과 데이터베이스 산출물을 기반으로 식별하는 것은?\n○○○ 종류.\n- 인터페이스 표준 항목과 송·수신 데이터 항목 식별 : 송·수신 시스템 사이의 교환 범위를 확인하고 인터페이스 표준 항목에 대해 송·수신 데이터 항목을 식별한다.\n- 코드성 데이터 항목 식별 : 코드성 데이터 항목에 대해 코드, 코드명, 코드 설명 등의 코드 정보를 식별한다.",
    "answer": "Answer 1 : 송·수신 데이터 식별"
  },
  {
    "question": "Question 566.\n내·외부 시스템이 연계하여 작동할 때 인터페이스별 송·수신 방법, 송·수신 데이터, 오류 식별 및 처리 방안에 대한 내용을 문서로 정리하는 것은?\n○○○에 필요한 정보.\n- 시스템 연계 기술.\n- 인터페이스 통신 유형.\n- 처리 유형.\n- 발생 주기.",
    "answer": "Answer 1 : 인터페이스 방법 명세화"
  },
  {
    "question": "Question 567.\n다음은 인터페이스 방법 명세화의 세 가지 방법 중 하나에 대한 설명이다.\n내·외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 연계 방식, 통신 및 처리 유형, 발생 주기 등의 송·수신 방법을 정의하고 명세를 작성하는 것.",
    "answer": "Answer 1 : 송·수신 방법 명세화"
  },
  {
    "question": "Question 568.\n다음은 인터페이스 방법 명세화의 세 가지 방법 중 하나에 대한 설명이다.\n내·외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 인터페이스 시 필요한 송·수신 방법을 정의하고 명세를 작성하는 것.",
    "answer": "Answer 1 : 송·수신 데이터 명세화"
  },
  {
    "question": "Question 569.\n다음은 인터페이스 방법 명세화의 세 가지 방법 중 하나에 대한 설명이다.\n내·외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 인터페이스 시 발생할 수 있는 오류를 식별하고 오류 처리 방안에 대한 명세를 작성하는 것.",
    "answer": "Answer 1 : 오류 식별 및 처리 방안 명세화"
  },
  {
    "question": "Question 570.\n다음은 시스템 연계의 다섯 가지 기술 중 하나에 대한 설명이다.\nDB에서 제공하는 ○○○ 객체를 이용하는 방식.",
    "answer": "Answer 1 : DB Link"
  },
  {
    "question": "Question 571.\n다음은 시스템 연계의 다섯 가지 기술 중 하나에 대한 설명이다.\n송신 시스템의 데이터베이스(DB)에서 데이터를 읽어 와 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램.",
    "answer": "Answer 1 : API/Open API"
  },
  {
    "question": "Question 572.\n다음은 시스템 연계의 다섯 가지 기술 중 하나에 대한 설명이다.\nEAI 서버와 송·수신 시스템에 설치되는 클라이언트(Client)를 이용하는 방식.",
    "answer": "Answer 1 : 연계 솔루션"
  },
  {
    "question": "Question 573.\n다음은 시스템 연계의 다섯 가지 기술 중 하나에 대한 설명이다.\n서버가 통신을 위한 ○○○을 생성하여 포트를 할당하고 클라이언트의 통신 요청 시 클라이언트와 연결하여 통시하는 네트워크 기술.",
    "answer": "Answer 1 : 소켓\nAnswer 2 : Socket"
  },
  {
    "question": "Question 574.\n다음은 시스템 연계의 다섯 가지 기술 중 하나에 대한 설명이다.\n○○○에서 WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 서비스.",
    "answer": "Answer 1 : 웹 서비스\nAnswer 2 : Web Service"
  },
  {
    "question": "Question 575.\n다음은 인터페이스 통신의 세 가지 유형 중 하나에 대한 설명이다.\n시스템에서 거래를 요청만 하고 응답이 없는 방식.",
    "answer": "Answer 1 : 단방향"
  },
  {
    "question": "Question 576.\n다음은 인터페이스 통신의 세 가지 유형 중 하나에 대한 설명이다.\n시스템에서 거래를 요청하고 응답이 올 때까지 대기(Request- Reply)하는 방식.",
    "answer": "Answer 1 : 동기"
  },
  {
    "question": "Question 577.\n다음은 인터페이스 통신의 세 가지 유형 중 하나에 대한 설명이다.\n시스템에서 거래를 요청하고 다른 작업을 수행하다 응답이 오면 처리하는 방식(Send- Receive, Send- Receive- Acknowledge, Publish- Subscribe).",
    "answer": "Answer 1 : 비동기"
  },
  {
    "question": "Question 578.\n다음은 인터페이스 처리의 세 가지 유형 중 하나에 대한 설명이다.\n사용자가 요청한 내용을 바로 처리해야 할 때 사용하는 방식.",
    "answer": "Answer 1 : 실시간 방식"
  },
  {
    "question": "Question 579.\n다음은 인터페이스 처리의 세 가지 유형 중 하나에 대한 설명이다.\n데이터를 매건 단위로 처리할 경우 비용이 많이 발생할 때 사용하는 방식.",
    "answer": "Answer 1 : 지연 처리 방식"
  },
  {
    "question": "Question 580.\n다음은 인터페이스 처리의 세 가지 유형 중 하나에 대한 설명이다.\n대량의 데이터를 처리할 때 사용하는 방식.",
    "answer": "Answer 1 : 배치 방식"
  },
  {
    "question": "Question 581.\n개발할 시스템과 내·외부 시스템 간 송·수신 데이터가 전송되어 인터페이스가 사용되는 주기를 의미하는 것은?\n업무의 성격과 송·수신 데이터 전송량을 고려하여 매일, 수시, 주 1회 등으로 구분한다.",
    "answer": "Answer 1 : 인터페이스 발생 주기"
  },
  {
    "question": "Question 582.\n운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어는?\n표준화된 인터페이스를 제공함으로써 시스템 간의 데이터 교환에 일관성을 보장한다.\n○○○의 종류.\n- DB(DataBase).\n- RPC(Remote Procedure Call).\n- MOM(Message Oriented Middleware).\n- TP- Monitor(Transaction Processing Monitor).\n- ORB(Object Request Broker).\n- WAS(Web Application Server).",
    "answer": "Answer 1 : 미들웨어\nAnswer 2 : Middleware"
  },
  {
    "question": "Question 583.\n데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하는 미들웨어는?\n○○○를 사용하여 시스템을 구축하는 경우 보통 2- Tier 아키텍처라고 한다.",
    "answer": "Answer 1 : DB\nAnswer 2 : DataBase"
  },
  {
    "question": "Question 584.\n응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 미들웨어는?",
    "answer": "Answer 1 : RPC\nAnswer 2 : 원격 프로시저 호출\nAnswer 3 : Remote Procedure Call"
  },
  {
    "question": "Question 585.\n메시지 기반의 비동기형 메시지를 전달하는 미들웨어는?\n온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용된다.",
    "answer": "Answer 1 : MOM\nAnswer 2 : 메시지 지향 미들웨어\nAnswer 3 : Message Oriented Monitor"
  },
  {
    "question": "Question 586.\n온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어는?\n항공기나 철도 예약 업무 등 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용된다.",
    "answer": "Answer 1 : TP- Monitor\nAnswer 2 : 트랜잭션 처리 모니터\nAnswer 3 : Transaction Processing Monitor"
  },
  {
    "question": "Question 587.\n코바(CORBA) 표준 스펙을 구현한 객체 지향 미들웨어는?\n최근에는 TP- Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있다.",
    "answer": "Answer 1 : ORB\nAnswer 2 : 객체 요청 브로커\nAnswer 3 : Object Request Broker"
  },
  {
    "question": "Question 588.\n사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어는?\n클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어이다.\nHTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션- 크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현이 가능하다.",
    "answer": "Answer 1 : WAS\nAnswer 2 : 웹 애플리케이션 서버\nAnswer 3 : Web Application Server"
  },
  {
    "question": "Question 589.\n내부 모듈과 외부 모듈 또는 내부 모듈 간 데이터의 교환을 위해 관계를 설정하는 것은?\n대표적인 ○○○ 방법.\n- EAI(Enterprise Application Integration).\n- ESB(Enterprise Service Bus).\n- 웹 서비스(Web Service).",
    "answer": "Answer 1 : 모듈 연계"
  },
  {
    "question": "Question 590.\n기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션은?",
    "answer": "Answer 1 : EAI\nAnswer 2 : Enterprise Application Integration"
  },
  {
    "question": "Question 591.\n애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션은?\n애플리케이션 통합 측면에서 EAI와 우사하지만 애플리케이션보다는 서비스 중심의 통합을 지향한다.\n특정 서비스에 국한되지 않고 범용적으로 사용하기 위하여 애플리케이션과의 결합도(Coupling)를 약하게(Loosely) 유지한다.\n관리 및 보안 유지가 쉽다.\n높은 수준의 품질 지원이 가능하다.",
    "answer": "Answer 1 : ESB\nAnswer 2 : Enterprise Service Bus"
  },
  {
    "question": "Question 592.\n네트워크의 정보를 표준화된 서비스 형태로 만들어 공유하는 기술은?\n서비스 지향 아키텍처(SOA) 개념을 실현하는 대표적인 방법이다.",
    "answer": "Answer 1 : 웹 서비스\nAnswer 2 : Web Service"
  },
  {
    "question": "Question 593.\n다음은 웹 서비스의 세 가지 구성 중 하나에 대한 설명이다.\nHTTP, HTTPS, SMTP 등을 활용하여 XML 기반의 메시지를 네트워크 상에서 교환하는 프로토콜.",
    "answer": "Answer 1 : SOAP"
  },
  {
    "question": "Question 594.\n다음은 웹 서비스의 세 가지 구성 중 하나에 대한 설명이다.\nWSDL을 등록하여 서비스와 서비스 제공자를 검색하고 접근하는데 사용됨.",
    "answer": "Answer 1 : UDDI\nAnswer 2 : Universal Description, Discovery and Integration"
  },
  {
    "question": "Question 595.\n다음은 웹 서비스의 세 가지 구성 중 하나에 대한 설명이다.\n① 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어.\n② XML로 작성되며, UDDI의 기초가 됨.",
    "answer": "Answer 1 : WSDL"
  },
  {
    "question": "Question 596.\n모듈 간 인터페이스에 사용되는 데이터의 형식을 표준화하는 것은?\n기존의 데이터 중에서 공통 영역을 추출하거나 어느 한쪽의 데이터를 변환하여 정의한다.\n확인된 ○○○은 인터페이스 기능 구현을 정의하는데 사용된다.",
    "answer": "Answer 1 : 인터페이스 데이터 표준"
  },
  {
    "question": "Question 597.\n인터페이스를 실제로 구현하기 위해 인터페이스 기능에 대한 구현 방법을 기능별로 기술하는 것은?",
    "answer": "Answer 1 : 인터페이스 기능 구현의 정의"
  },
  {
    "question": "Question 598.\n모듈의 구성 요소와 세부적인 동작 등을 정의한 설계서는?",
    "answer": "Answer 1 : 모듈 세부 설계서"
  },
  {
    "question": "Question 599.\n다음은 모듈 세부 설계서의 두 가지 종류 중 하나에 대한 설명이다.\n컴포넌트의 개요 및 내부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세 등을 정의한 것.",
    "answer": "Answer 1 : 컴포넌트 명세서"
  },
  {
    "question": "Question 600.\n다음은 모듈 세부 설계서의 두 가지 종류 중 하나에 대한 설명이다.\n컴포넌트 명세서의 항목 중 인터페이스 클래스의 세부 조건 및 기능 등을 정의한 것.",
    "answer": "Answer 1 : 인터페이스 명세서"
  },
  {
    "question": "Question 601.\n송·수신 시스템 간의 데이터 교환 및 처리를 실현해주는 작업을 의미하는 것은?\n대표적인 ○○○ 방법.\n- 데이터 통신을 이용한 ○○○.\n- 인터페이스 엔티티를 이용한 ○○○.",
    "answer": "Answer 1 : 인터페이스 구현"
  },
  {
    "question": "Question 602.\n애플리케이션 영역에서 데이터 포맷을 인터페이스 대상으로 전송하면 이를 수신 측에서 파싱(Parsing)하여 해석하는 방식은?\n주로 JSON이나 XML 형식의 데이터 포맷을 사용하여 인터페이스를 구현한다.",
    "answer": "Answer 1 : 데이터 통신을 이용한 인터페이스 구현"
  },
  {
    "question": "Question 603.\n인터페이스가 필요한 시스템 사이에 별도의 인터페이스 엔티티를 두어 상호 연계하는 것은?\n일반적으로 인터페이스 테이블을 엔티티로 활용한다.",
    "answer": "Answer 1 : 인터페이스 엔티티를 이용한 인터페이스 구현"
  },
  {
    "question": "Question 604.\n웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성·값의 쌍(Attribute- Value Pairs) 형태로 표현하는 개방형 표준 포맷은?\n비동기 처리에 사용되는 AJAX에서 XML을 대체하여 사용되고 있다.",
    "answer": "Answer 1 : JSON\nAnswer 2 : JavaScript Object Notation"
  },
  {
    "question": "Question 605.\n자바 스크립트(JavaScript)를 사용하여 클라이언트와 서버 간에 XML 데이터를 주고 받는 비동기 통신 기술은?\n전체 페이즈를 새로 고치치 않고도 웹 페이지 일부 영역만을 업데이트할 수 있다.",
    "answer": "Answer 1 : AJAX\nAnswer 2 : Asynchronous JavaScript and XML"
  },
  {
    "question": "Question 606.\n인터페이스의 보안성 향상을 위해 인터페이스의 보안 취약점을 분석한 후 적절한 보안 기능을 적용하는 것은?",
    "answer": "Answer 1 : 인터페이스 보안"
  },
  {
    "question": "Question 607.\n다음은 인터페이스 보안 기능을 적용하는 세 가지 영역 중 하나에 대한 설명이다.\n① 인터페이스 송·수신 간 스니핑(Sniffing) 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 트래픽에 대한 암호화를 설정함.\n② 함호화는 인터페이스 아키텍처에 따라 IPSec, SSL, S- HTTP 등의 다양한 방식으로 적용함.",
    "answer": "Answer 1 : 네트워크 영역"
  },
  {
    "question": "Question 608.\n다음은 인터페이스 보안 기능을 적용하는 세 가지 영역 중 하나에 대한 설명이다.\n소프트웨어 개발 보안 가이드를 참조하여 애플리케이션 코드 상의 보안 취약점을 보완하는 방향으로 애플리케이션 보안 기능을 적용함.",
    "answer": "Answer 1 : 애플리케이션 영역"
  },
  {
    "question": "Question 609.\n다음은 인터페이스 보안 기능을 적용하는 세 가지 영역 중 하나에 대한 설명이다.\n① 데이터베이스 , 스키마, 엔티티의 접근 권한과 프로시저(Procedure), 트리거(Trigger) 등 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용함.\n② 개인 정보나 업무상 민감한 데이터의 경우 암호화나 익명화 등 데이터 자체의 보안 방안도 고려함.",
    "answer": "Answer 1 : 데이터베이스 영역"
  },
  {
    "question": "Question 610.\n인터페이스 보안 취약점을 분석하는데 사용되는 도구는?\n시스템 파일의 변경 유무를 확인하고, 파일이 변경되었을 경우 이를 관리자에게 알려준다.\n종류 : Tripwire, AIDE, Samhain, Claymore, Slipwire, Fchech 등.",
    "answer": "Answer 1 : 데이터 무결성 검사 도구"
  },
  {
    "question": "Question 611.\n인터페이스가 정상적으로 문제없이 작동하는지 확인하는 것은?\n○○○ 도구와 감시 도구를 이용하여 인터페이스의 동작 상태를 확인한다.",
    "answer": "Answer 1 : 인터페이스 구현 검증"
  },
  {
    "question": "Question 612.\n인터페이스 구현을 검증하기 위해서 인터페이스 단위 기능과 시나리오 등을 기반으로 하는 ○○○가 필요하다.",
    "answer": "Answer 1 : 통합 테스트"
  },
  {
    "question": "Question 613.\n다음은 통합 테스트를 수행하기 위해 사용하는 테스트 자동화 도구의 여섯 가지 도구 중 하나에 대한 설명이다.\n① 같은 테스트 코드를 여러 번 작성하지 않게 도와주고, 테스트마다 예상 결과를 기억할 필요가 없게 하는 자동화된 해법을 제공하는 단위 테스트 프레임워크.\n② Smalltalk에 처음 적용되어 SUnit이라는 이름이었으나 Java용의 JUnit, C++용의 CppUnit, 닷NET용의 NUnit, Http용의 HttpUnit 등 다양한 언어에 적용되면서 ○○○으로 통칭되고 있음.",
    "answer": "Answer 1 : xUnit"
  },
  {
    "question": "Question 614.\n다음은 통합 테스트를 수행하기 위해 사용하는 테스트 자동화 도구의 여섯 가지 도구 중 하나에 대한 설명이다.\n① 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크.\n② 크로스 플랫폼이나 분삭 소프트웨어에서 테스트 환경을 조성할 수 있도록 지원함.\n③ 분산 소프트웨어의 경우 각 분산 환경에 설치된 데몬이 프로그램 테스트에 대한 응답을 대신하며, 테스트가 완료되면 이를 통합하고 자동화하여 프로그램을 완성함.",
    "answer": "Answer 1 : STAF"
  },
  {
    "question": "Question 615.\n다음은 통합 테스트를 수행하기 위해 사용하는 테스트 자동화 도구의 여섯 가지 도구 중 하나에 대한 설명이다.\n웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크.",
    "answer": "Answer 1 : FitNesse"
  },
  {
    "question": "Question 616.\n다음은 통합 테스트를 수행하기 위해 사용하는 테스트 자동화 도구의 여섯 가지 도구 중 하나에 대한 설명이다.\nFitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN(Naver)의 테스트 자동화 프레임워크.",
    "answer": "Answer 1 : NTAF"
  },
  {
    "question": "Question 617.\n다음은 통합 테스트를 수행하기 위해 사용하는 테스트 자동화 도구의 여섯 가지 도구 중 하나에 대한 설명이다.\n다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크.",
    "answer": "Answer 1 : Selenium"
  },
  {
    "question": "Question 618.\n다음은 통합 테스트를 수행하기 위해 사용하는 테스트 자동화 도구의 여섯 가지 도구 중 하나에 대한 설명이다.\nRuby를 사용하는 애플리케이션 테스트 프레임워크.",
    "answer": "Answer 1 : Watir"
  },
  {
    "question": "Question 619.\n인터페이스 동작 상태는 APM(애플리케이션 성능 관리)을 사용하여 감시(Monitoring)하는 도구는?\nAPM을 통해 데이터베이스와 웹 애플리에키션의 트랜잭션, 변수값, 호출 함수, 로그 및 시스템 부하 등 종합적인 정보를 조회하고 분석할 수 있다.",
    "answer": "Answer 1 : 인터페이스 구현 감시 도구"
  },
  {
    "question": "Question 620.\n다음은 대표적인 APM의 두 가지 종류 중 하나에 대한 설명이다.\n애플리케이션 및 OS 자원에 대한 모니터링 기능을 제공하는 오픈소스 APM 소프트웨어.",
    "answer": "Answer 1 : 스카우터\nAnswer 2 : Scouter"
  },
  {
    "question": "Question 621.\n다음은 대표적인 APM의 두 가지 종류 중 하나에 대한 설명이다.\n애플리케이션의 개발부터 테스트, 오픈, 운영, 안정화까지, 전 단계에 걸쳐 성능을 모니터링하고 분석해주는 소프트웨어.",
    "answer": "Answer 1 : 제니퍼\nAnswer 2 : Jennifer"
  },
  {
    "question": "Question 622.\n애플리케이션의 성능 관리를 위해 접속자, 자원 현황, 트랜잭션 수행 내역, 장애 진단 등 다양한 모니터링 기능을 제공하는 도구는?\n○○○은 리소스 방식과 엔드투엔드(End- to- End)의 두 가지 유형이 있다.\n리소스 방식 : Nagios, Zabbix, Cacti 등.\n엔드투엔드 방식 : VisualVM, 제니퍼, 스카우터 등.",
    "answer": "Answer 1 : APM\nAnswer 2 : Application Performance Management\nAnswer 3 : Application Performance Monitoring"
  },
  {
    "question": "Question 623.\n사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어를 의미하는 것은?\n○○○의 세 가지 분야.\n- 정보 제공과 전달을 위한 물리적 제어에 관한 분야.\n- 콘텐츠의 상세적인 표현과 전체적인 구성에 관한 분야.\n- 모든 사용자가 편리하고 간편하게 사용하도록 하는 기능에 관한 분야.",
    "answer": "Answer 1 : 사용자 인터페이스\nAnswer 2 : UI\nAnswer 3 : User Interface"
  },
  {
    "question": "Question 624.\n다음은 사용자 인터페이스의 세 가지 종류 중 하나에 대한 설명이다.\n명령과 출력이 텍스트 형태로 이뤄지는 인터페이스.",
    "answer": "Answer 1 : CLI\nAnswer 2 : Command Line Interface"
  },
  {
    "question": "Question 625.\n다음은 사용자 인터페이스의 세 가지 종류 중 하나에 대한 설명이다.\n아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스",
    "answer": "Answer 1 : GUI\nAnswer 2 : Graphical User Interface"
  },
  {
    "question": "Question 626.\n다음은 사용자 인터페이스의 세 가지 종류 중 하나에 대한 설명이다.\n사용자의 말이나 행동 등 자연스러운 움직임을 통해 기기를 조작하는 인터페이스",
    "answer": "Answer 1 : NUI\nAnswer 2 : Natural User Interface"
  },
  {
    "question": "Question 627.\n다음은 사용자 인터페이스의 네 가지 기본 원칙 중 하나에 대한 설명이다.\n누구나 쉽게 이해하고 사용할 수 있어야 함.",
    "answer": "Answer 1 : 직관성"
  },
  {
    "question": "Question 628.\n다음은 사용자 인터페이스의 네 가지 기본 원칙 중 하나에 대한 설명이다.\n사용자의 목적을 정확하고 완벽하게 달성해야 함.",
    "answer": "Answer 1 : 유효성"
  },
  {
    "question": "Question 629.\n다음은 사용자 인터페이스의 네 가지 기본 원칙 중 하나에 대한 설명이다.\n누구나 쉽게 배우고 익힐 수 있어야 함.",
    "answer": "Answer 1 : 학습성"
  },
  {
    "question": "Question 630.\n다음은 사용자 인터페이스의 네 가지 기본 원칙 중 하나에 대한 설명이다.\n사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함.",
    "answer": "Answer 1 : 유연성"
  },
  {
    "question": "Question 631.\n페이지에 대한 개략적인 레이아웃이나 UI 요소 등에 대한 뼈대를 설계하는 도구는?\n기획 단계의 초기에 제작한다.\n개발자나 디자이나 등이 레이아웃을 협의하거나 현재 진행 상태 등을 공유하기 위해 사용한다.\n페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계한다.\n○○○ 툴 : 손그림, 파워포인트, 키노트, 스케치, 일러스트, 포토샵 등",
    "answer": "Answer 1 : 와이어프레임\nAnswer 2 : Wireframe"
  },
  {
    "question": "Question 632.\n와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형은?\n디자인, 사용 방법 설명, 평가 등을 위해 만든다.\n시작적으로만 구성 요소를 배치하는 것으로 실제로 구현되지는 않는다.\n○○○ 툴 : 파워 ○○○, 발사믹 ○○○ 등.",
    "answer": "Answer 1 : 목업\nAnswer 2 : Mockup"
  },
  {
    "question": "Question 633.\n와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서는?\n디자이너와 개발자가 최종적으로 참고하는 작업 지침서이다.\n서비스 구축을 위한 모든 정보가 들어있다.\n○○○ 툴 : 파워포인트, 키노트, 스케치, Axure 등.",
    "answer": "Answer 1 : 스토리보드\nAnswer 2 : Story Board"
  },
  {
    "question": "Question 634.\n와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형은?\n사용자의 요구사항을 개발자가 맞게 해석했는지 검증하기 위한 것이다.\n일부 핵심적인 기능만을 제공한다.",
    "answer": "Answer 1 : 프로토타입\nAnswer 2 : Prototype"
  },
  {
    "question": "Question 635.\n다음은 프로토타입의 두 가지 종류 중 하나에 대한 설명이다.\n① 스케치, 그림, 글 등을 이용하여 손으로 직접 작성하는 아날로그적인 방법.\n② 제작 기간이 짧은 경우, 제작 비용이 적을 경우, 업무 협의가 빠를 경우 사용함.",
    "answer": "Answer 1 : 페이퍼 프로토타입"
  },
  {
    "question": "Question 636.\n다음은 프로토타입의 두 가지 종류 중 하나에 대한 설명이다.\n① 파워포인트, 아크로뱃, 비지오, 옴니그래플 등과 같은 프로그램을 사용하여 작성하는 방법.\n② 재사용이 필요한 경우, 산출물과 비슷한 효과가 필요한 경우, 숙련된 전문가가 있을 경우 사용함.",
    "answer": "Answer 1 : 디지털 프로토타입"
  },
  {
    "question": "Question 637.\n사용자의 요구사항을 기능 단위로 표현하는 것은?\n사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다.\n사용자의 요구사항을 빠르게 파악함으로써 프로젝트의 초기에 시스템의 기능적인 요구를 결정하고 그 결과를 문서화할 수 있다.\n일반적으로 다이어그램 형식으로 묘사된다.",
    "answer": "Answer 1 : 유스케이스\nAnswer 2 : Use Case"
  },
  {
    "question": "Question 638.\n다음은 ISO/IEC 9126의 소프트웨어 품질 특성의 여섯 가지 특성 중 하나에 대한 설명이다.\n① 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부를 나타냄.\n② 하위 특성 : 적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성.",
    "answer": "Answer 1 : 기능성\nAnswer 2 : Functionality"
  },
  {
    "question": "Question 639.\n다음은 ISO/IEC 9126의 소프트웨어 품질 특성의 여섯 가지 특성 중 하나에 대한 설명이다.\n① 주어진 시간동안 주어진 기능을 오류 없이 수행할 수 있는 정도를 나타냄.\n② 하위 특성 : 성숙성, 고장 허용성, 회복성.",
    "answer": "Answer 1 : 신뢰성\nAnswer 2 : Reliability"
  },
  {
    "question": "Question 640.\n다음은 ISO/IEC 9126의 소프트웨어 품질 특성의 여섯 가지 특성 중 하나에 대한 설명이다.\n① 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대하여 사용자가 정확하게 이해하고 사용하며, 향후 다시 사용하고 싶은 정도를 나타냄.\n② 하위 특성 : 이해성, 학습성, 운용성, 친밀성.",
    "answer": "Answer 1 : 사용성\nAnswer 2 : Usability"
  },
  {
    "question": "Question 641.\n다음은 ISO/IEC 9126의 소프트웨어 품질 특성의 여섯 가지 특성 중 하나에 대한 설명이다.\n① 사용자가 요구하는 기능을 얼마나 빠르게 처리할 수 있는지 정도를 나타냄.\n② 하위 특성 : 시간 ○○○, 자원 ○○○.",
    "answer": "Answer 1 : 효율성\nAnswer 2 : Efficiency"
  },
  {
    "question": "Question 642.\n다음은 ISO/IEC 9126의 소프트웨어 품질 특성의 여섯 가지 특성 중 하나에 대한 설명이다.\n① 환경의 변화 또는 새로운 요구사항이 발생했을 때 소프트웨어를 개선하거나 확장할 수 있는 정도를 나타냄.\n② 하위 특성 : 분석성, 변경성, 안정성, 시험성.",
    "answer": "Answer 1 : 유지 보수성\nAnswer 2 : Maintainability"
  },
  {
    "question": "Question 643.\n다음은 ISO/IEC 9126의 소프트웨어 품질 특성의 여섯 가지 특성 중 하나에 대한 설명이다.\n① 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도를 나타냄.\n② 하위 특성 : 적용성, 설치성, 대체성, 공존성.",
    "answer": "Answer 1 : 이식성\nAnswer 2 : Portability"
  },
  {
    "question": "Question 644.\n사용자의 요구사항을 바탕으로 UI 설계를 구체화하여 작성하는 문서는?\n기획자, 개발자, 디자이너 등과의 원활한 의사소통을 위해 작성한다.",
    "answer": "Answer 1 : UI 설계서"
  },
  {
    "question": "Question 645.\n업무의 진행 과정이나 수행 절차에 따른 흐름을 파악하여 화면과 폼을 설계하는 단계는?",
    "answer": "Answer 1 : UI 흐름 설계"
  },
  {
    "question": "Question 646.\nUI 설계서를 바탕으로 실제 설계 및 구현을 위해 모든 화면에 대해 자세하게 설계를 진행하는 단계는?\n○○○를 할 때는 반드시 시나리오를 작성해야 한다.",
    "answer": "Answer 1 : UI 상세 설계"
  },
  {
    "question": "Question 647.\n사용자 인터페이스의 기능 구조, 대표 화면, 화면 간 인터랙션의 흐름, 다양한 상황에서의 예외 처리 등을 정리한 문서는?\n사용자가 최종 목표를 달성하기 위한 방법이 순차적으로 묘사되어 있다.",
    "answer": "Answer 1 : UI 시나리오 문서"
  },
  {
    "question": "Question 648.\n다음은 UI 시나리오 문서의 여섯 가지 요건 중 하나에 대한 설명이다.\n누락되지 않도록 최대한 상세하게 기술해야 함.",
    "answer": "Answer 1 : 완전성\nAnswer 2 : Complete"
  },
  {
    "question": "Question 649.\n다음은 UI 시나리오 문서의 여섯 가지 요건 중 하나에 대한 설명이다.\n서비스 목표, 시스템 및 사용자의 요구사항, UI 스타일 등이 모두 ○○○을 유지해야 함.",
    "answer": "Answer 1 : 일관성\nAnswer 2 : Consistent"
  },
  {
    "question": "Question 650.\n다음은 UI 시나리오 문서의 여섯 가지 요건 중 하나에 대한 설명이다.\n누구나 쉽게 이해할 수 있도록 설명함.",
    "answer": "Answer 1 : 이해성\nAnswer 2 : Understandable"
  },
  {
    "question": "Question 651.\n다음은 UI 시나리오 문서의 여섯 가지 요건 중 하나에 대한 설명이다.\n표준화된 템플릿 등을 활용하여 문서를 쉽게 읽을 수 있도록 해야함.",
    "answer": "Answer 1 : 가독성\nAnswer 2 : Readable"
  },
  {
    "question": "Question 652.\n다음은 UI 시나리오 문서의 여섯 가지 요건 중 하나에 대한 설명이다.\n시나리오의 수정이나 개선이 쉬워야 함.",
    "answer": "Answer 1 : 수정 용이성\nAnswer 2 : Modifiable"
  },
  {
    "question": "Question 653.\n다음은 UI 시나리오 문서의 여섯 가지 요건 중 하나에 대한 설명이다.\n변경 사항은 언제, 어떤 부분이, 왜 발생했는지 쉽게 추적할 수 있어야 함.",
    "answer": "Answer 1 : 추적 용이성\nAnswer 2 : Traceable"
  },
  {
    "question": "Question 654.\n사람이 시스템을 보다 편리하고 안전하게 사용할 수 있도록 연구하고 개발하는 학문은?\n최종 목표는 시스템을 사용하는데 있어 최적의 사용자 경험(UX)을 만드는 것이다.\n어떤 제품이 좋은 제품인지, 어떻게 하면 좋은 제품을 만들 수 있는지 등을 연구한다.",
    "answer": "Answer 1 : HCI\nAnswer 2 : Human Computer Interaction\nAnswer 3 : Human Computer Interface"
  },
  {
    "question": "Question 655.\n사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 경험은?\nUI가 사용성, 접근성, 편의성을 중시한다면 ○○○는 이러한 UI를 통해 사용자가 느끼는 만족이나 감정을 중시한다.\n기술을 효용성 측면에서만 보는 것이 아니라 사용자의 삶의 질을 향상시키는 하나의 방향으로 보는 새로운 개념이다.",
    "answer": "Answer 1 : UX\nAnswer 2 : User Experience\nAnswer 3 : 사용자 경험"
  },
  {
    "question": "Question 656.\n다음은 UX의 세 가지 특징 중 하나에 대한 설명이다.\n사람들의 개인적, 신체적, 인지적 특성에 따라 다르므로 주관적임.",
    "answer": "Answer 1 : 주관성\nAnswer 2 : Subjectivity"
  },
  {
    "question": "Question 657.\n다음은 UX의 세 가지 특징 중 하나에 대한 설명이다.\n경험이 일어나는 상황 또는 주변 환경에 영향을 받음.",
    "answer": "Answer 1 : 정황성\nAnswer 2 : Contextuality"
  },
  {
    "question": "Question 658.\n다음은 UX의 세 가지 특징 중 하나에 대한 설명이다.\n개인이 느끼는 총체적인 심리적, 감성적인 결과임.",
    "answer": "Answer 1 : 총체성\nAnswer 2 : Holistic"
  },
  {
    "question": "Question 659.\n제품이나 작업환경을 사용자의 감성에 알맞도록 설계 및 제작하는 기술은?\n인문사회과학, 공학, 의학 등 여러 분야의 학문이 공존하는 종합과학이다.\n○○○의 목적은 인간의 삶을 편리하고 안전하며 쾌적하게 만드는 것이다.\n○○○은 인간의 감성을 구체적으로 제품 설계에 적용하기 위해 공학적인 접근 방법을 사용한다.",
    "answer": "Answer 1 : 감성공학"
  },
  {
    "question": "Question 660.\n애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차는?\n개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인(Validation)하고 소프트웨어가 기능을 정확히 수행하는지 검증(Verification)한다.",
    "answer": "Answer 1 : 애플리케이션 테스트"
  },
  {
    "question": "Question 661.\n다음은 애플리케이션 테스트의 여덟 가지 기본 원리 중 하나에 대한 설명이다.\n소프트웨어의 잠재적인 결함을 줄일 수 있지만 소프트웨어에 결함이 없다고 증명할 수는 없음.",
    "answer": "Answer 1 : 완벽한 테스트 불가능"
  },
  {
    "question": "Question 662.\n다음은 애플리케이션 테스트의 여덟 가지 기본 원리 중 하나에 대한 설명이다.\n애플리케이션의 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙.",
    "answer": "Answer 1 : 파레토 법칙\nAnswer 2 : Pareto Principle"
  },
  {
    "question": "Question 663.\n다음은 애플리케이션 테스트의 여덟 가지 기본 원리 중 하나에 대한 설명이다.\n동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상.",
    "answer": "Answer 1 : 살충제 패러독스\nAnswer 2 : Pesticide Paradox"
  },
  {
    "question": "Question 664.\n다음은 애플리케이션 테스트의 여덟 가지 기본 원리 중 하나에 대한 설명이다.\n소프트웨어의 특징, 테스트 환경, 테스터의 역량 등 정황(Context)에 따라 테스트 결과가 달라질 수 있으므로, 정황에 따라 테스트를 다르게 수행해야 함.",
    "answer": "Answer 1 : 테스팅은 정황(Context) 의존"
  },
  {
    "question": "Question 665.\n다음은 애플리케이션 테스트의 여덟 가지 기본 원리 중 하나에 대한 설명이다.\n소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없는 것.",
    "answer": "Answer 1 : 오류- 부재의 궤변\nAnswer 2 : Absence of Error Fallacy"
  },
  {
    "question": "Question 666.\n다음은 애플리케이션 테스트의 여덟 가지 기본 원리 중 하나에 대한 설명이다.\n테스트를 많이 하면 할수록 미래에 발생할 위험을 줄일 수 있음.",
    "answer": "Answer 1 : 테스트와 위험은 반비례"
  },
  {
    "question": "Question 667.\n다음은 애플리케이션 테스트의 여덟 가지 기본 원리 중 하나에 대한 설명이다.\n테스트는 작은 부분에서 시작하여 점점 확대하며 진행해야 함.",
    "answer": "Answer 1 : 테스트의 점진적 확대"
  },
  {
    "question": "Question 668.\n다음은 애플리케이션 테스트의 여덟 가지 기본 원리 중 하나에 대한 설명이다.\n테스트는 개발자와 관계없는 별도의 팀에서 수행해야 함.",
    "answer": "Answer 1 : 테스트의 별도 팀 수행"
  },
  {
    "question": "Question 669.\n다음은 프로그램 실행 여부에 따른 테스트의 두 가지 종류 중 하나에 대한 설명이다.\n① 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트.\n② 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도, 남은 결함 등을 발견하기 위해 사용함.\n③ 종류 : 워크스루, 인스펙션, 코드 검사 등.",
    "answer": "Answer 1 : 정적 테스트"
  },
  {
    "question": "Question 670.\n다음은 프로그램 실행 여부에 따른 테스트의 두 가지 종류 중 하나에 대한 설명이다.\n① 프로그램을 실행하여 오류를 찾는 테스트.\n② 소프트웨어 개발의 모든 단계에서 테스트를 수행함.\n③ 종류 : 블랙박스 테스트, 화이트박스 테스트.",
    "answer": "Answer 1 : 동적 테스트"
  },
  {
    "question": "Question 671.\n다음은 테스트 기반(Test Bases)에 따른 테스트의 세 가지 종류 중 하나에 대한 설명이다.\n① 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트.\n② 종류 : 동등 분할, 경계 값 분석 등.",
    "answer": "Answer 1 : 명세 기반 테스트"
  },
  {
    "question": "Question 672.\n다음은 테스트 기반(Test Bases)에 따른 테스트의 세 가지 종류 중 하나에 대한 설명이다.\n① 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트.\n② 종류 : 구문 기반, 결정 기반, 조건 기반 등.",
    "answer": "Answer 1 : 구조 기반 테스트"
  },
  {
    "question": "Question 673.\n다음은 테스트 기반(Test Bases)에 따른 테스트의 세 가지 종류 중 하나에 대한 설명이다.\n① 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트.\n② 사용자의 요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 수행하면 효과적임.\n③ 종류 : 에러 추정, 체크 리스트, 탐색적 테스팅.",
    "answer": "Answer 1 : 경험 기반 테스트"
  },
  {
    "question": "Question 674.\n다음은 시각에 따른 테스트의 두 가지 종류 중 하나에 대한 설명이다.\n① 개발자의 시각에서 제품의 생산 과정을 테스트하는 것.\n② 제품이 명세서대로 완성됐는지를 테스트함.",
    "answer": "Answer 1 : 검증 테스트\nAnswer 2 : Verification Test"
  },
  {
    "question": "Question 675.\n다음은 시각에 따른 테스트의 두 가지 종류 중 하나에 대한 설명이다.\n① 사용자의 시각에서 생산된 제품의 결과를 테스트하는 것.\n② 사용자가 요구한대로 제품이 완성됐는지, 제품이 정상적으로 동작하는지를 테스트함.",
    "answer": "Answer 1 : 확인 테스트\nAnswer 2 : Validation Test"
  },
  {
    "question": "Question 676.\n다음은 목적에 따른 테스트의 일곱 가지 종류 중 하나에 대한 설명이다.\n시스템에 여러 가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지를 확인하는 테스트.",
    "answer": "Answer 1 : 회복 테스트\nAnswer 2 : Recovery Test"
  },
  {
    "question": "Question 677.\n다음은 목적에 따른 테스트의 일곱 가지 종류 중 하나에 대한 설명이다.\n시스템에 설치된 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지를 확인하는 테스트.",
    "answer": "Answer 1 : 안전 테스트\nAnswer 2 : Security Test"
  },
  {
    "question": "Question 678.\n다음은 목적에 따른 테스트의 일곱 가지 종류 중 하나에 대한 설명이다.\n시스템에 과도한 정보량이나 빈도 등을 부과하여 과부하 시에도 소프트웨어가 정상적으로 실행되는지를 확인하는 테스트.",
    "answer": "Answer 1 : 강도 테스트\nAnswer 2 : Stress Test"
  },
  {
    "question": "Question 679.\n다음은 목적에 따른 테스트의 일곱 가지 종류 중 하나에 대한 설명이다.\n소프트웨어의 실시간 성능이나 전체적인 효율성을 진단하는 테스트로, 소프트웨어의 응답 시간, 처리량 등을 테스트.",
    "answer": "Answer 1 : 성능 테스트\nAnswer 2 : Performance Test"
  },
  {
    "question": "Question 680.\n다음은 목적에 따른 테스트의 일곱 가지 종류 중 하나에 대한 설명이다.\n소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트.",
    "answer": "Answer 1 : 구조 테스트\nAnswer 2 : Structure Test"
  },
  {
    "question": "Question 681.\n다음은 목적에 따른 테스트의 일곱 가지 종류 중 하나에 대한 설명이다.\n소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트.",
    "answer": "Answer 1 : 회귀 테스트\nAnswer 2 : Regresstion Test"
  },
  {
    "question": "Question 682.\n다음은 목적에 따른 테스트의 일곱 가지 종류 중 하나에 대한 설명이다.\n변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교하는 테스트.",
    "answer": "Answer 1 : 병행 테스트\nAnswer 2 : Parallel Test"
  },
  {
    "question": "Question 683.\n모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법은?\n모듈 안의 작동을 직접 관찰한다.\n원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행된다.",
    "answer": "Answer 1 : 화이트박스 테스트\nAnswer 2 : White Box Test"
  },
  {
    "question": "Question 684.\n다음은 화이트박스 테스트의 두 가지 종류 중 하나에 대한 설명이다.\n① 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법.\n② 대표적인 화이트박스 테스트 기법임.",
    "answer": "Answer 1 : 기초 경로 검사\nAnswer 2 : Base Path Testing"
  },
  {
    "question": "Question 685.\n다음은 화이트박스 테스트의 두 가지 종류 중 하나에 대한 설명이다.\n① 조건 검사(Condition Testing) : 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법.\n② 루프 검사(Loop Testing) : 프로그램의 반복(Loop) 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법.\n③ 데이터 흐름 검사(Data Flow Testing) : 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법.",
    "answer": "Answer 1 : 제어 구조 검사\nAnswer 2 : Control\nAnswer 3 : Structure Testing"
  },
  {
    "question": "Question 686.\n다음은 화이트박스 테스트의 네 가지 검증 기준 중 하나에 대한 설명이다.\n소스 코드의 모든 구문이 한 번 이상 수행되도록 테스트 케이스를 설계함.",
    "answer": "Answer 1 : 문장 검증 기준\nAnswer 2 : Statement Coverage"
  },
  {
    "question": "Question 687.\n다음은 화이트박스 테스트의 네 가지 검증 기준 중 하나에 대한 설명이다.\n① 소스 코드의 모든 조건문에 대해 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스를 설계함.\n② 결정 검증 기준(Dicision Coverage)이라고도 함.",
    "answer": "Answer 1 : 분기 검증 기준\nAnswer 2 : Branch Coverage"
  },
  {
    "question": "Question 688.\n다음은 화이트박스 테스트의 네 가지 검증 기준 중 하나에 대한 설명이다.\n소스 코드의 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스를 설계함.",
    "answer": "Answer 1 : 조건 검증 기준\nAnswer 2 : Condition Coverage"
  },
  {
    "question": "Question 689.\n다음은 화이트박스 테스트의 네 가지 검증 기준 중 하나에 대한 설명이다.\n분기 검증 기준과 조건 검증 기준을 모두 만족하는 설계로, 조건문이 True인 경우와 False인 경우에 따라 조건 검증 기준의 입력 데이터를 구분하는 테스트 케이스를 설계함.",
    "answer": "Answer 1 : 분기/조건 기준\nAnswer 2 : Branch/Condition Coverage"
  },
  {
    "question": "Question 690.\n소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트로, 기능 테스트라고도 한다.\n사용자의 요구사항 명세를 보면서 테스트한다.\n주로 구현된 기능을 테스트한다.\n소프트웨어 인터페이스를 통해 실시된다.",
    "answer": "Answer 1 : 블랙박스 테스트\nAnswer 2 : Black Box Test"
  },
  {
    "question": "Question 691.\n다음은 블랙박스 테스트의 다섯 가지 종류 중 하나에 대한 설명이다.\n① 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법.\n② 동등 분할 기법이라고도 함.",
    "answer": "Answer 1 : 동치 분할 검사\nAnswer 2 : 동치 클래스 분해\nAnswer 3 : Equivalence Partitioning Testing"
  },
  {
    "question": "Question 692.\n다음은 블랙박스 테스트의 다섯 가지 종류 중 하나에 대한 설명이다.\n입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법.",
    "answer": "Answer 1 : 경계값 분석\nAnswer 2 : Boundary Value Analysis"
  },
  {
    "question": "Question 693.\n다음은 블랙박스 테스트의 다섯 가지 종류 중 하나에 대한 설명이다.\n입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법.",
    "answer": "Answer 1 : 원인- 효과 그래프 검사\nAnswer 2 : Cause- Effect Graphing Testing"
  },
  {
    "question": "Question 694.\n다음은 블랙박스 테스트의 다섯 가지 종류 중 하나에 대한 설명이다.\n과거의 경험이나 확인자의 감각으로 테스트하는 기법.",
    "answer": "Answer 1 : 오류 예측 검사"
  },
  {
    "question": "Question 695.\n다음은 블랙박스 테스트의 다섯 가지 종류 중 하나에 대한 설명이다.\n여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법.",
    "answer": "Answer 1 : 비교 검사\nAnswer 2 : Comparison Testing"
  },
  {
    "question": "Question 696.\n코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것은?\n인터페이스, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사한다.\n사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행한다.\n구조 기반 테스트와 명세 기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행한다.",
    "answer": "Answer 1 : 단위 테스트\nAnswer 2 : Unit Test"
  },
  {
    "question": "Question 697.\n단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트를 의미하는 것은?\n모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사한다.",
    "answer": "Answer 1 : 통합 테스트\nAnswer 2 : Integration Test"
  },
  {
    "question": "Question 698.\n개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트는?\n기능적 요구사항과 비기능적 요구사항으로 구분하여 각각을 만족하는지 테스트한다.",
    "answer": "Answer 1 : 시스템 테스트\nAnswer 2 : System Test"
  },
  {
    "question": "Question 699.\n개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법은?\n개발한 소프트웨어를 사용자가 직접 테스트한다.",
    "answer": "Answer 1 : 인수 테스트\nAnswer 2 : Acceptance Test"
  },
  {
    "question": "Question 700.\n다음은 인수 테스트의 여섯 가지 종류 중 하나에 대한 설명이다.\n사용자가 시스템 사용의 적절성 여부를 확인함.",
    "answer": "Answer 1 : 사용자 인수 테스트"
  },
  {
    "question": "Question 701.\n다음은 인수 테스트의 여섯 가지 종류 중 하나에 대한 설명이다.\n① 시스템 관리자가 시스템 인수 시 수행하는 테스트 기법.\n② 백업/복원 시스템, 재난 복구, 사용자 관리, 정기 점검 등을 확인함.",
    "answer": "Answer 1 : 운영상의 인수 테스트"
  },
  {
    "question": "Question 702.\n다음은 인수 테스트의 여섯 가지 종류 중 하나에 대한 설명이다.\n계약상의 인수/검수 조건을 준수하는지 여부를 확인함.",
    "answer": "Answer 1 : 계약 인수 테스트"
  },
  {
    "question": "Question 703.\n다음은 인수 테스트의 여섯 가지 종류 중 하나에 대한 설명이다.\n소프트웨어가 정부 지침, 법규, 규정 등 규정에 맞게 개발되었는지 확인함.",
    "answer": "Answer 1 : 규정 인수 테스트"
  },
  {
    "question": "Question 704.\n다음은 인수 테스트의 여섯 가지 종류 중 하나에 대한 설명이다.\n① 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법.\n② 테스트는 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록함.",
    "answer": "Answer 1 : 알파 테스트"
  },
  {
    "question": "Question 705.\n다음은 인수 테스트의 여섯 가지 종류 중 하나에 대한 설명이다.\n① 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법.\n② 실업무를 가지고 사용자가 직접 테스트.",
    "answer": "Answer 1 : 베타 테스트"
  },
  {
    "question": "Question 706.\n단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법은?",
    "answer": "Answer 1 : 통합 테스트\nAnswer 2 : Integration Test"
  },
  {
    "question": "Question 707.\n다음은 통합 테스트의 두 가지 종류 중 하나에 대한 설명이다.\n① 단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트하는 방법.\n② 종류 : 빅뱅 통합 테스트 방식.",
    "answer": "Answer 1 : 비점진적 통합 방식"
  },
  {
    "question": "Question 708.\n다음은 통합 테스트의 두 가지 종류 중 하나에 대한 설명이다.\n① 모듈 단위로 단계적으로 통합하면서 테스트하는 방법.\n② 종류 : 하향식 통합 테스트, 상향식 통합 테스트, 혼합식 통합 테스트.",
    "answer": "Answer 1 : 점진적 통합 방식"
  },
  {
    "question": "Question 709.\n프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법은?\n깊이 우선 통합법이나 넓이 우선 통합법을 사용한다.\n○○○ 절차.\n① 주요 제어 모듈은 작성된 프로그램을 사용하고, 주요 제어 모듈의 종속 모듈들은 스텁(Stub)으로 대체한다.\n② 깊이 우선 또는 넓이 우선 등의 통합 방식에 따라 하위 모듈인 스텁들이 한 번에 하나씩 실제 모듈로 교체된다.\n③ 모듈이 통합될 때마다 테스트를 실시한다.\n④새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트를 실시한다.",
    "answer": "Answer 1 : 하향식 통합 테스트\nAnswer 2 : Top Down Integration Test"
  },
  {
    "question": "Question 710.\n프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법은?\n○○○ 절차.\n① 하위 모듈들을 클러스터(Cluster)로 결합한다.\n② 상위 모듈에서 데이터의 입·출력을 확인하기 위해 더미 모듈인 드라이버(Driver)를 작성한다.\n③ 통합된 클러스터 단위로 테스트한다.\n④테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체된다.",
    "answer": "Answer 1 : 상향식 통합 테스트\nAnswer 2 : Bottom Up Integration Test"
  },
  {
    "question": "Question 711.\n하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식은?\n샌드위치(Sandwich)식 통합 테스트 방법이라고도 한다.",
    "answer": "Answer 1 : 혼합식 통합 테스트"
  },
  {
    "question": "Question 712.\n통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트는?\n이미 테스트된 프로그램의 테스팅을 반복하는 것이다.\n회귀 테스트는 수정한 모듈이나 컴포넌트가 다른 부분에 영향을 미치는지, 오류가 생기지 않았는지 테스트하여 새로운 오류가 발생하지 않음을 보증하기 위해 반복 테스트한다.",
    "answer": "Answer 1 : 회귀 테스팅\nAnswer 2 : Regression Testing"
  },
  {
    "question": "Question 713.\n구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서는?\n○○○를 미리 설계하면 테스트 오류 방지, 테스트 수행에 필요한 인력, 시간 등의 자원 낭비를 줄일 수 있다.",
    "answer": "Answer 1 : 테스트 케이스\nAnswer 2 : Test Case"
  },
  {
    "question": "Question 714.\n테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스를 묶은 집합은?\n테스트 케이스를 적용하는 구체적인 절차를 명세한다.\n테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정되어 있다.",
    "answer": "Answer 1 : 테스트 시나리오\nAnswer 2 : Test Scenario"
  },
  {
    "question": "Question 715.\n테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값을 대입하여 비교하는 기법 및 활동을 말하는 것은?\n결과를 판단하기 위해 테스크 케이스에 대한 예상 결과를 계산하거나 확인한다.\n○○○의 특징.\n① 제한된 검증 : ○○○을 모든 테스트 케이스에 적용할 수 없음.\n② 수학적 기법 : ○○○의 값을 수학적 기법을 이용하여 구할 수 있음.\n③ 자동화 기능 : 테스트 대상 프로그램의 실행, 결과 비교, 커버리지 측정 등을 자동화 할 수 있음.",
    "answer": "Answer 1 : 테스트 오라클\nAnswer 2 : Test Oracle"
  },
  {
    "question": "Question 716.\n다음은 테스트 오라클의 네 가지 종류 중 하나에 대한 설명이다.\n① 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클.\n② 발생된 모든 오류를 검출할 수 있음.",
    "answer": "Answer 1 : 참 오라클\nAnswer 2 : True Oracle"
  },
  {
    "question": "Question 717.\n다음은 테스트 오라클의 네 가지 종류 중 하나에 대한 설명이다.\n특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로 전수 테스트가 불가능한 경우 사용.",
    "answer": "Answer 1 : 샘플링 오라클\nAnswer 2 : Sampling Oracle"
  },
  {
    "question": "Question 718.\n다음은 테스트 오라클의 네 가지 종류 중 하나에 대한 설명이다.\n특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클.",
    "answer": "Answer 1 : 추정 오라클\nAnswer 2 : Heuristic Oracle"
  },
  {
    "question": "Question 719.\n다음은 테스트 오라클의 네 가지 종류 중 하나에 대한 설명이다.\n애플리케이션에 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클.",
    "answer": "Answer 1 : 일관성 검사 오라클\nAnswer 2 : Consistent Oracle"
  },
  {
    "question": "Question 720.\n사람이 반복적으로 수행하던 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용함으로써 쉽고 효율적으로 테스트를 수행할 수 있도록 한 것은?\n테스트 유형에 따른 ○○○ 도구의 종류.\n- 정적 분석 도구.\n- 테스트 실행 도구.\n- 성능 테스트 도구.\n- 테스트 통제 도구.",
    "answer": "Answer 1 : 테스트 자동화"
  },
  {
    "question": "Question 721.\n프로그램을 실행하지 않고 분석하는 도구는?\n소스 코드에 대한 코딩 표준.\n코딩 스타일, 코드 복잡도 및 남은 결함 등을 발견하기 위해 사용된다.",
    "answer": "Answer 1 : 정적 분석 도구\nAnswer 2 : Static Analysis Tools"
  },
  {
    "question": "Question 722.\n스크립트 언어를 사용하여 테스트를 실행하는 도구는?\n테스트 데이터와 테스트 수행 방법 등이 포함된 스크립트를 작성한 후 실행한다.\n데이터 주도 접근 방식 : 스프레드시트에 테스트 데이터를 저장하고, 이를 읽어 실행하는 방식.\n키워드 주도 접근 방식 : 스프레드시트에 테스트를 수행할 동작을 나타내는 키워드와 테스트 데이터를 읽어 저장하여 실행하는 방식.",
    "answer": "Answer 1 : 테스트 실행 도구\nAnswer 2 : Test Execution Tools"
  },
  {
    "question": "Question 723.\n애플리케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률 등을 인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부를 확인하는 도구는?",
    "answer": "Answer 1 : 성능 테스트 도구\nAnswer 2 : Performanced Test Tools"
  },
  {
    "question": "Question 724.\n테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구는?\n종류 : 형상 관리 도구, 결함 추적/관리 도구 등.",
    "answer": "Answer 1 : 테스트 통제 도구\nAnswer 2 : Test Control Tools"
  },
  {
    "question": "Question 725.\n테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구는?",
    "answer": "Answer 1 : 테스트 하네스 도구\nAnswer 2 : Test Harness Tools\nAnswer 3 : 테스트 하네스(Test Harness) : 애플리케이션의 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로, 테스트를 지원하기 위해 생성된 코드와 데이터를 의미함."
  },
  {
    "question": "Question 726.\n다음은 테스트 하네스의 여섯 가지 구성 요소 중 하나에 대한 설명이다.\n테스트 대상의 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 도구.",
    "answer": "Answer 1 : 테스트 드라이버\nAnswer 2 : Test Driver"
  },
  {
    "question": "Question 727.\n다음은 테스트 하네스의 여섯 가지 구성 요소 중 하나에 대한 설명이다.\n제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈.",
    "answer": "Answer 1 : 테스트 스텁\nAnswer 2 : Test Stub"
  },
  {
    "question": "Question 728.\n다음은 테스트 하네스의 여섯 가지 구성 요소 중 하나에 대한 설명이다.\n테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합.",
    "answer": "Answer 1 : 테스트 슈트\nAnswer 2 : Test Suites"
  },
  {
    "question": "Question 729.\n다음은 테스트 하네스의 여섯 가지 구성 요소 중 하나에 대한 설명이다.\n사용자의 요구사항을 정확하게 준수했는지 확인하기 위한 입력값, 실행 조건, 기대 결과 등으로 만들어진 테스트 항목의 명세서.",
    "answer": "Answer 1 : 테스트 케이스\nAnswer 2 : Test Case"
  },
  {
    "question": "Question 730.\n다음은 테스트 하네스의 여섯 가지 구성 요소 중 하나에 대한 설명이다.\n자동화된 테스트 실행 절차에 대한 명세서.",
    "answer": "Answer 1 : 테스트 스크립트\nAnswer 2 : Test Script"
  },
  {
    "question": "Question 731.\n다음은 테스트 하네스의 여섯 가지 구성 요소 중 하나에 대한 설명이다.\n사전에 사용자의 행위를 조건부로 입력해두면, 그 상황에 맞는 예정된 행위를 수행하는 객체.",
    "answer": "Answer 1 : 목 오브젝트\nAnswer 2 : Mock Object"
  },
  {
    "question": "Question 732.\n오류 발생, 작동 실패 등과 같이 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것을 의미하는 것은?\n사용자가 예상한 결과와 실행 결과 간의 차이나 업무 내용과의 불일치 등으로 인해 변경이 필요한 부분도 모두 ○○○에 해당된다.",
    "answer": "Answer 1 : 결함\nAnswer 2 : Fault"
  },
  {
    "question": "Question 733.\n테스트에서 발견된 결함은 지속적으로 상태 변화를 추적하고 관리해야 한다는 것을 의미하는 말은?\n발견된 결함에 대해 결함 관리 측정 지표의 속성 값들을 분석하여 향후 결함이 발견될 모듈 또는 컴포넌트를 추정할 수 있다.\n결함 관리 측정 지표.\n- 결함 분포 : 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함 수 측정.\n- 결함 추세 : 테스트 진행 시간에 따른 결함 수의 추이 분석.\n- 결함 에이징 : 특정 결함 상태로 지속되는 시간 측정.",
    "answer": "Answer 1 : 결함 상태 추적"
  },
  {
    "question": "Question 734.\n다음은 결함의 네 가지 분류 중 하나에 대한 설명이다.\n애플리케이션 환경이나데이터베이스 처리에서 발생된 결함.",
    "answer": "Answer 1 : 시스템 결함"
  },
  {
    "question": "Question 735.\n다음은 결함의 네 가지 분류 중 하나에 대한 설명이다.\n애플리케이션의 기획, 설계, 업무 시나리오 등의 단계에서 유입된 결함.",
    "answer": "Answer 1 : 기능 결함"
  },
  {
    "question": "Question 736.\n다음은 결함의 네 가지 분류 중 하나에 대한 설명이다.\n사용자 화면 설계에서 발생된 결함.",
    "answer": "Answer 1 : GUI 결함"
  },
  {
    "question": "Question 737.\n다음은 결함의 네 가지 분류 중 하나에 대한 설명이다.\n기획자, 사용자, 개발자 간의 의사소통 및 기록이 원활하지 않아 발생된 결함.",
    "answer": "Answer 1 : 문서 결함"
  },
  {
    "question": "Question 738.\n애플리케이션에 발생한 결함이 전체 시스템에 미치는 치명도를 나타내는 척도는?\nHigh, Medium, Low 또는 치명적(Critical), 주요(Major), 보통(Normal), 경미(Minor), 단순(Simple) 등으로 분류된다.",
    "answer": "Answer 1 : 결함 심각도"
  },
  {
    "question": "Question 739.\n발견된 결함 처리에 신속성을 나타내는 척도는?\n결함의 중요도와 심각도에 따라 설정되고 수정 여부가 결정된다.\n결정적(Critical), 높음(High), 보통(Medium), 낮음(Low) 또는 즉시 해결, 주의 요망, 대기, 개선 권고 등으로 분류된다.",
    "answer": "Answer 1 : 결함 우선순위"
  },
  {
    "question": "Question 740.\n다음은 결함 관리 도구의 네 가지 종류 중 하나에 대한 설명이다.\n결함 및 이슈 관리 도구로, 소프트웨어 설계 시 단위별 작업 내용을 기록할 수 있어 결함 추적도 가능한 도구.",
    "answer": "Answer 1 : Mantis"
  },
  {
    "question": "Question 741.\n다음은 결함 관리 도구의 네 가지 종류 중 하나에 대한 설명이다.\n결함 추적은 물론 결함을 통합하여 관리할 수 있는 도구.",
    "answer": "Answer 1 : Trac"
  },
  {
    "question": "Question 742.\n다음은 결함 관리 도구의 네 가지 종류 중 하나에 대한 설명이다.\n프로젝트 관리 및 결함 추적이 가능한 도구.",
    "answer": "Answer 1 : Redmine"
  },
  {
    "question": "Question 743.\n다음은 결함 관리 도구의 네 가지 종류 중 하나에 대한 설명이다.\n① 결함 신고, 확인, 처리 등 결함을 지속적으로 관리할 수 있는 도구.\n② 결함의 심각도와 우선순위를 지정할 수도 있음.",
    "answer": "Answer 1 : Bugzilla"
  },
  {
    "question": "Question 744.\n최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도를 나타낸 것은?",
    "answer": "Answer 1 : 애플리케이션 성능"
  },
  {
    "question": "Question 745.\n다음은 애플리케이션 성능의 네 가지 측정 지표 중 하나에 대한 설명이다.\n일정 시간 내에 애플리케이션이 처리하는 일의 양.",
    "answer": "Answer 1 : 처리량\nAnswer 2 : Throughput"
  },
  {
    "question": "Question 746.\n다음은 애플리케이션 성능의 네 가지 측정 지표 중 하나에 대한 설명이다.\n애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간.",
    "answer": "Answer 1 : 응답 시간\nAnswer 2 : Response Time"
  },
  {
    "question": "Question 747.\n다음은 애플리케이션 성능의 네 가지 측정 지표 중 하나에 대한 설명이다.\n애플리케이션에 작업을 외뢰한 시간부터 처리가 완료될 때까지 걸린 시간.",
    "answer": "Answer 1 : 경과 시간\nAnswer 2 : Turn Around Time"
  },
  {
    "question": "Question 748.\n다음은 애플리케이션 성능의 네 가지 측정 지표 중 하나에 대한 설명이다.\n애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 ○○○",
    "answer": "Answer 1 : 자원 사용률\nAnswer 2 : Resource Usage"
  },
  {
    "question": "Question 749.\n애플리케이션의 성능을 테스트하기 위해 애플리케이션에 부하나 스트레스를 가하면서 애플리케이션의 성능 측정 지표를 점검하는 도구는?",
    "answer": "Answer 1 : 성능 테스트 도구"
  },
  {
    "question": "Question 750.\n애플리케이션이 실행되었을 때 시스템 자원의 사용량을 확인하고 분석하는 도구는?",
    "answer": "Answer 1 : 시스템 모니터링 도구\nAnswer 2 : System Monitoring Tools"
  },
  {
    "question": "Question 751.\n시스템이나 시스템 구성 요소 또는 소프트웨어의 복잡한 정도를 나타내는 말은?\n시스템 또는 소프트웨어를 어느 정도의 수준까지 테스트해야 하는지 또는 개발하는 데 어느 정도의 자원이 소요되는지 예측하는 데 사용된다.",
    "answer": "Answer 1 : 복잡도\nAnswer 2 : Complexity"
  },
  {
    "question": "Question 752.\n알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화한 것을 의미하는 것은?\n○○○가 낮을수록 알고리즘의 실행시간이 짧고, 높을수록 실행시간이 길어진다.",
    "answer": "Answer 1 : 시간 복잡도"
  },
  {
    "question": "Question 753.\n다음은 시간 복잡도를 적을 때 쓰는 점근 표기법의 세 가지 종류 중 하나에 대한 설명이다.\n① 알고리즘의 실행시간이 최악일 때를 표기하는 방법.\n② 입력값에 대해 알고리즘을 수행했을 때 명령어의 실행 횟수는 어떠한 경우에도 표기 수치보다 많을 수 없음.",
    "answer": "Answer 1 : 빅오 표기법\nAnswer 2 : Big-O-Notation"
  },
  {
    "question": "Question 754.\n다음은 시간 복잡도를 적을 때 쓰는 점근 표기법의 세 가지 종류 중 하나에 대한 설명이다.\n① 알고리즘의 실행시간이 평균일 때를 표기하는 방법.\n② 입력값에 대해 알고리즘을 수행했을 때 명령어 실행 횟수의 평균적인 수치를 표기함.",
    "answer": "Answer 1 : 세타 표기법\nAnswer 2 : Big-θ Notation"
  },
  {
    "question": "Question 755.\n다음은 시간 복잡도를 적을 때 쓰는 점근 표기법의 세 가지 종류 중 하나에 대한 설명이다.\n① 알고리즘의 실행시간이 최상일 때를 표기하는 방법.\n② 입력값에 대해 알고리즘을 수행했을 때 명령어의 실행횟수는 어떠한 경우에도 표기 수치보다 적을 수 없음.",
    "answer": "Answer 1 : 오메가 표기법\nAnswer 2 : Big-Ω Notation"
  },
  {
    "question": "Question 756.\n한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도는?\n맥케이브 순환도(McCabe's Cyclomatic) 또는 맥케이브 복잡도 메트릭(McCabe's Complexity Metrics)라고도 한다.\n제어 흐름도 이론에 기초를 둔다.",
    "answer": "Answer 1 : 순환 복잡도\nAnswer 2 : Cyclomatic Complexity"
  },
  {
    "question": "Question 757.\n나쁜 코드(Bad Code)를 배제하고, 클린 코드(Clean Code)로 작성하는 것은?\n클린 코드(Clean Code) : 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순, 명료한 코드, 즉 잘 작성된 코드.\n나쁜 코드(Bad Code) : ① 프로그램의 로직(Logic)이 복잡하고 이해하기 어려운 코드.\n② 대표적인 나쁜 코드 : .\n- 스파게티 코드 : 코드의 로직이 서로 복잡하게 얽혀 있는 코드.\n- 외계인 코드 : 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드.\n나쁜 코드로 작성된 애플리케이션의 코드를 클린 코드로 수정하면 애플리케이션의 성능이 개선된다.",
    "answer": "Answer 1 : 소스 코드 최적화"
  },
  {
    "question": "Question 758.\n다음은 클린 코드의 다섯 가지 작성 원칙 중 하나에 대한 설명이다.\n① 누구든지 코드를 쉽게 읽을 수 있도록 작성함.\n② 코드 작성 시 이해하기 쉬운 용어를 사용하거나 들여쓰기 기능 등을 사용함.",
    "answer": "Answer 1 : 가독성"
  },
  {
    "question": "Question 759.\n다음은 클린 코드의 다섯 가지 작성 원칙 중 하나에 대한 설명이다.\n① 코드를 간단하게 작성함.\n② 한 번에 한 가지를 처리하도록 코드를 작성하고 클래스/메소드/함수 등을 최소 단위로 분리함.",
    "answer": "Answer 1 : 단순성"
  },
  {
    "question": "Question 760.\n다음은 클린 코드의 다섯 가지 작성 원칙 중 하나에 대한 설명이다.\n① 코드가 다른 모듈에 미치는 영향을 최소화함.\n② 코드 변경 시 다른 부분에 영향이 없도록 작성함.",
    "answer": "Answer 1 : 의존성 배제"
  },
  {
    "question": "Question 761.\n다음은 클린 코드의 다섯 가지 작성 원칙 중 하나에 대한 설명이다.\n① 코드의 중복을 최소화함.\n② 중복된 코드는 삭제하고 공통된 코드를 사용함.",
    "answer": "Answer 1 : 중복성 최소화"
  },
  {
    "question": "Question 762.\n다음은 클린 코드의 다섯 가지 작성 원칙 중 하나에 대한 설명이다.\n상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고, 상세 내용은 하위 클래스/메소드/함수에서 구현함.",
    "answer": "Answer 1 : 추상화"
  },
  {
    "question": "Question 763.\n다음은 소스 코드 두 가지의 최적화 유형 중 하나에 대한 설명이다.\n하나의 클래스는 하나의 역할만 수행하도록 응집도를 높이고, 크기를 작게 작성함.",
    "answer": "Answer 1 : 클래스 분할 배치"
  },
  {
    "question": "Question 764.\n다음은 소스 코드 두 가지의 최적화 유형 중 하나에 대한 설명이다.\n인터페이스 클래스를 이용하여 추상화된 자료 구조와 메소드를 구현함으로써 클래스 간의 의존성을 최소함.",
    "answer": "Answer 1 : 느슨한 결함\nAnswer 2 : Loosely Coupled"
  },
  {
    "question": "Question 765.\n소스 코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메무리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 분석 도구는?",
    "answer": "Answer 1 : 소스 코드 품질 분석 도구"
  },
  {
    "question": "Question 766.\n다음은 소스 코드 품질 분석 도구의 두 가지 종류 중 하나에 대한 설명이다.\n① 작성한 소스 코드를 실행하지 않고 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구.\n② 종류 : pmd, cppcheck, SonarQube, chechstyle, ccm, cobertura 등.",
    "answer": "Answer 1 : 정적 분석 도구\nAnswer 2 : Static Analysis"
  },
  {
    "question": "Question 767.\n다음은 소스 코드 품질 분석 도구의 두 가지 종류 중 하나에 대한 설명이다.\n① 작성한 소스 코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 도구.\n② 종류 : Avalanche, Valgrind 등.",
    "answer": "Answer 1 : 동적 분석 도구\nAnswer 2 : Dynamic Analysis"
  },
  {
    "question": "Question 768.\nDB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어는?\n번역한 결과가 데이터 사전(Data Dictionary)이라는 특별한 파일에 여러 개의 테이블로 저장된다.\n○○○의 세 가지 유형.\nCREATE : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의함.\nALTER : TABLE에 대한 정의를 변경하는 데 사용함.\nDROP : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제함.",
    "answer": "Answer 1 : DDL Data Define Language\nAnswer 2 : 데이터 정의어"
  },
  {
    "question": "Question 769.\n보안상 안전한 소프트웨어를 개발하기 위해 SDLC에 보안 강화를 위한 프로세스를 포함한 것은?\n○○○는 요구사항 분석, 설계, 구현, 테스트, 유지보수 등 SDLC 전체 단계에 걸쳐 수행되어야 할 보안 활동을 제시한다.",
    "answer": "Answer 1 : Secure SDLC"
  },
  {
    "question": "Question 770.\n다음은 SDLC의 대표적인 방법론 세 가지 중 하나에 대한 설명이다.\nSDLC의 초기 단계에서 보안을 강화하기 위해 개발된 방법론.",
    "answer": "Answer 1 : CLASP"
  },
  {
    "question": "Question 771.\n다음은 SDLC의 대표적인 방법론 세 가지 중 하나에 대한 설명이다.\n마이크로소프트 사에서 안전한 소프트웨어 개발을 위해 기존의 SDLC를 개선한 방법론.",
    "answer": "Answer 1 : SDL"
  },
  {
    "question": "Question 772.\n다음은 SDLC의 대표적인 방법론 세 가지 중 하나에 대한 설명이다.\n소프트웨어 보안의 모범사례를 SDLC에 통합한 방법론.",
    "answer": "Answer 1 : Seven Touchpoints"
  },
  {
    "question": "Question 773.\n다음은 소프트웨어 개발 보안의 다섯 가지 요소 중 하나에 대한 설명이다.\n① 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용됨.\n② 정보가 전송 중에 노출되더라도 데이터를 읽을 수 없음.",
    "answer": "Answer 1 : 기밀성\nAnswer 2 : Confidentiality"
  },
  {
    "question": "Question 774.\n다음은 소프트웨어 개발 보안의 다섯 가지 요소 중 하나에 대한 설명이다.\n시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있음.",
    "answer": "Answer 1 : 무결성\nAnswer 2 : Integrity"
  },
  {
    "question": "Question 775.\n다음은 소프트웨어 개발 보안의 다섯 가지 요소 중 하나에 대한 설명이다.\n① 시스템 내의 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지를 확인하는 모든 행위.\n② 대표적 방법 : 패스워드, 인증용 카드, 지문 검사 등.",
    "answer": "Answer 1 : 인증\nAnswer 2 : Authentication"
  },
  {
    "question": "Question 776.\n다음은 소프트웨어 개발 보안의 다섯 가지 요소 중 하나에 대한 설명이다.\n데이터를 송·수신한 자가 송·수신 사실을 부인할 수 없도록 송·수신 증거를 제공함.",
    "answer": "Answer 1 : 부인 방지\nAnswer 2 : NonRequdiation"
  },
  {
    "question": "Question 777.\n구현 단계에서 발생할 수 있는 보안 취약점들을 최소화하기 위해 보안 요소들을 고려하며 코딩하는 걸 의미하는 것은?\n보안 취약점을 사전 대응하여 안정성과 신뢰성을 확보한다.\n보안 정책을 바탕으로 ○○○ 가이드를 작성하고, 개발 참여자에게는 ○○○ 교육을 실시한다.",
    "answer": "Answer 1 : 시큐어 코딩\nAnswer 2 : Secure Coding"
  },
  {
    "question": "Question 778.\n패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법을 의미하는 것은?",
    "answer": "Answer 1 : 암호 알고리즘"
  },
  {
    "question": "Question 779.\n동일한 키로 데이터를 암호화하고 복호화하는 기법은?\n대칭 암호 기법 또는 단일키 암호화 기법이라고도 한다.\n암호화/복호화 속도가 빠르지만, 관리해야 할 키의 수가 많다.",
    "answer": "Answer 1 : 개인키 암호화 기법\nAnswer 2 : Private Key Encryption 기법"
  },
  {
    "question": "Question 780.\n다음은 개인키 암호화 기법의 두 가지 종류 중 하나에 대한 설명이다.\n평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화하는 방식.\n종류 : LFSR, RC4, TKIP.",
    "answer": "Answer 1 : 스트림 암호화 방식"
  },
  {
    "question": "Question 781.\n다음은 개인키 암호화 기법의 두 가지 종류 중 하나에 대한 설명이다.\n반 번에 하나의 데이터 블록을 암호화하는 방식.\n종류 : DES, SEED, AES, ARIA, IDEA, Skipjack",
    "answer": "Answer 1 : 블록 암호화 방식"
  },
  {
    "question": "Question 782.\n데이터를 암호화할 때 사용하는 공개키(Public Key)는 사용자에게 공개하고, 복호화할 때의 비밀키(Secret Key)는 관리자가 비밀리에 관리하는 암호화 기법은?\n비대칭 암호 기법이라고도 한다.\n관리해야 할 키의 수가 적지만, 암호화/복호화 속도가 느리다.\n대표적으로는 RSA(Rivest Shamir Adleman) 기법이 있다.",
    "answer": "Answer 1 : 공개키 암호화 기법\nAnswer 2 : Public Key Encryption 기법"
  },
  {
    "question": "Question 783.\n임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변호나하는 것을 의미하는 것은?\n○○○ 알고리즘을 ○○○ 함수라고 부르며, ○○○ 함수로 변환된 값이나 키를 ○○○값 또는 ○○○키라고 부른다.\n데이터의 암호화, 무결성 검증을 위해 사용도리 뿐만 아니라 정보보호의 다양한 분야에서 활용된다.",
    "answer": "Answer 1 : 해시\nAnswer 2 : Hash"
  },
  {
    "question": "Question 784.\n표적이 되는 서버의 자원을 고갈시킬 목적으로 다수의 공격자 또는 시스템에서 대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써, 표적이 되는 서버의 정상적인 기능을 방해하는 것은?",
    "answer": "Answer 1 : 서비스 거부 공격\nAnswer 2 : Dos 공격\nAnswer 3 : Denial of Servie 공격"
  },
  {
    "question": "Question 785.\nPing 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 공격 대상의 네트워크를 마비시키는 서비스 거부 공격 방법은?\n공격에 사용되는 큰 패킷은 수백 개의 패킷으로 분할되어 전송되는데, 공격 대상은 분할된 대량의 패킷을 수신함으로써 분할되어 전송된 패킷을 재조립해야 하는 부담과 분할되어 전송된 각각의 패킷들의 ICMP Ping 메시지에 대한 응답을 처리하느라 시스템이 다운되게 된다.",
    "answer": "Answer 1 : Ping of Death\nAnswer 2 : 죽음의 핑"
  },
  {
    "question": "Question 786.\nIP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법은?\n공격자는 송신 주소를 공격 대상자의 IP 주소로 위장하고 해당 네트워크 라우터의 브로드캐스트 주소를 수신자로 하여 패킷을 전송하면, 라우터의 브로드캐스트 주소로 수신된 패킷은 해당 네트워크 내의 모든 컴퓨터로 전송된다.\n해당 네트워크 내의 모든 컴퓨터는 수신된 패킷에 대한 응답 메시지를 송신 주소인 공격 대상지로 집중적으로 전송하게 되는데, 이로 인해 공격 대상지는 네트워크 과부하로 인해 정상적인 서비스를 수행할 수 없게 된다.\n○○○ 공격을 무력화하는 방법 중 하나는 각 네트워크 라우터에서 브로드캐스트 주소를 사용할 수 없게 미리 설정해 놓는 것이다.",
    "answer": "Answer 1 : Smurfing\nAnswer 2 : 스머핑"
  },
  {
    "question": "Question 787.\n신뢰성 있는 전송을 위해 3-way-handshake를 거친 후에 데이터를 전송하게 되는데, ○○○은 공격자가 가상의 클라이언트로 위장하여 3-way-handshake 과정을 의도적으로 중단시킴으로써 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법은?\n○○○에 대비하기 위해 수신지의 SYN 수신 대기 시간을 줄이거나 침입 차단 시스템을 활용한다.",
    "answer": "Answer 1 : SYN Flooding"
  },
  {
    "question": "Question 788.\n패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여 공격 대상에게 전송하는 것으로, 이 패킷을 받은 공격 대상은 송신 IP 주소가 자기 자신이므로 자신에게 응답을 수행하게 되는데, 이러한 패킷이 계속해서 전송될 경우 자신에 대해 무한히 응답하게 하는 공격은?\n○○○에 대비하기 위해 송신 IP 주소와 수신 IP 주소의 적절성을 검사한다.",
    "answer": "Answer 1 : LAND Attack\nAnswer 2 : Local Area Network Denial Attack"
  },
  {
    "question": "Question 789.\n여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 서비스 거부 공격을 수행하는 것은?\n네트워크에서 취약점이 있는 호스트들을 탐색한 후 이들 호스트들에 분산 서비스 공격용 툴을 설치하여 에이전트(Agent)로 만든 후 ○○○ 공격에 이용한다.",
    "answer": "Answer 1 : DDoS 공격\nAnswer 2 : 분산 서비스 거부 공격\nAnswer 3 : Distributed Denial of Servie 공격"
  },
  {
    "question": "Question 790.\n인터넷을 통해 개인정보를 암호화하여 송·수신할 수 있는 기능을 갖춘 서버를 말하는 것은?\n○○○의 기능.\n- 서버에 SSL(Secure Socket Layer) 인증서를 설치하여 전송 정보를 암호화하여 송·수신하는 기능.\n- 서버에 암호화 응용 프로그램을 설치하고 전송 정보를 암호화하여 송·수신하는 기능.",
    "answer": "Answer 1 : 보안 서버"
  },
  {
    "question": "Question 791.\n다중 사용자 컴퓨터 시스템이나 네트워크 시스템에서 로그인을 요청한 사용자의 정보를 확인하고 접근 권한을 검증하는 보안 절차는?\n네트워크를 통해 컴퓨터에 접속하는 사용자의 등록 여부를 확인하는 것과 전송된 메시지의 위·변조 여부를 확인하는 것이 있다.",
    "answer": "Answer 1 : 인증\nAnswer 2 : Authentication"
  },
  {
    "question": "Question 792.\n사용자가 기억하고 있는 정보를 기반으로 인증을 수행하는 것은?\n사용자의 기억을 기반으로 하므로 관리 비용이 저렴하다.\n사용자가 인증 정보를 기억하지 못하면 본인이라도 인증 받지 못한다.\n○○○ 유형.\n① 고정된 패스워드(Password) : 사용자가 알고 있는 비밀번호를 접속할 때마다 반복해서 입력함.\n② 패스 프레이즈(Passphrase) : 일반 패스워드보다 길이가 길고 기억하기 쉬운 문장을 활용하여 비밀번호를 구성하는 방법.\n③ 아이핀(i-PIN) : 인터넷에서 주민등록번호 대신 쓸 수 있도록 만든 사이버 주민등록번호, 사용자에 대한 신원 확인을 완료한 후에 본인확인 기관에서 온라인으로 발행함.",
    "answer": "Answer 1 : 지식 기반 인증\nAnswer 2 : Something You Know"
  },
  {
    "question": "Question 793.\n사용자가 소유하고 있는 것을 기반으로 인증을 수행하는 것은?\n소유물이 쉽게 도용될 수 있으므로 지식 기반 인증 방식이나 생체 기반 인증 방식과 함게 사용된다.\n○○○ 유형.\n① 신분증 : 사용자의 사진이 포함된 주민등록증, 운전면허증, 여권 등을 사용하여 사용자의 신분 확인.\n② 메모리 카드(토큰) : 마그네틱 선에 보안 코드를 저장해서 사용하는 것으로, 카드 리더기를 통해서만 읽을 수 있음.\n③ 스마트 카드 : 마이크로프로세서, 카드 운영체제, 메모리 등으로 구성되어 사용자의 정보뿐만 아니라 특정 업무를 처리할 수 있는 기능이 내장되어 있음.\n④ OTP(One Time Password) : 사용자가 패스워드를 요청할 때마다 암호 알고리즘을 통해 새롭게 생성된 패스워드를 사용하는 것으로, 한 번 사용된 패스워드는 폐기됨.",
    "answer": "Answer 1 : 소유 기반 인증\nAnswer 2 : Something You have"
  },
  {
    "question": "Question 794.\n사용자의 고유한 생체 정보를 기반으로 인증을 수행하는 것은?\n사용이 쉽고 도난의 위험도 적으며 위조가 어렵다.\n사용 대상 : 지문, 홍채/망막, 얼굴, 음성, 정맥 등.",
    "answer": "Answer 1 : 생체 기반 인증\nAnswer 2 : Something You Are"
  },
  {
    "question": "Question 795.\n사용자의 행동 정보를 이용해 인증을 수행하는 것은?\n예) 서명, 동작.",
    "answer": "Answer 1 : 행위 기반 인증\nAnswer 2 : Something You Do"
  },
  {
    "question": "Question 796.\n인증을 시도하는 위치의 적절성을 확인하는 것은?\n예) 콜백, GPS나 IP 주소를 이용한 ○○○.",
    "answer": "Answer 1 : 위치 기반 인증\nAnswer 2 : Somewhere You Are"
  },
  {
    "question": "Question 797.\n접근 통제, 침입 차단 및 탐지 등을 수행하여 외부로부터의 불법적인 침입을 막는 기술 및 시스템을 말하는 것은?",
    "answer": "Answer 1 : 보안 솔루션"
  },
  {
    "question": "Question 798.\n기업이나 조직 내부의 네트워크와 인터넷 간에 전송되는 정보를 선별하여 수용·거부·수정하는 기능을 가진 침입 차단 시스템은?\n내부 네트워크에서 외부로 나가는 패킷은 그대로 통과시키고, 외부에서 내부 네트워크로 들어오는 패킷은 내용을 엄밀히 체크하여 인증된 패킷만 통과시키는 구조이다.",
    "answer": "Answer 1 : 방화벽\nAnswer 2 : Firewall"
  },
  {
    "question": "Question 799.\n컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템은?\n오용 탐지(Misuse Detection) : 미리 입력해 둔 공격 패턴이 감지되면 이를 알려준다.\n이상 탐지(Anomaly Detection) : 평균적인 시스템의 상태를 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려준다.",
    "answer": "Answer 1 : 침입 탐지 시스템\nAnswer 2 : IDS\nAnswer 3 : Intrusion Detection System"
  },
  {
    "question": "Question 800.\n비정상적인 트래픽을 능동적으로 차단하고 격리하는 등의 방어 조치를 취하는 보안 솔루션은?\n방화벽과 침입 탐지 시스템을 결합한 것이다.\n침입 탐지 기능으로 패킷을 하나씩 검사한 후 비정상적인 패킷이 탐지되면 방화벽 기능으로 해당 패킷을 차단한다.",
    "answer": "Answer 1 : 침입 방지 시스템\nAnswer 2 : IPS\nAnswer 3 : Intrusion Prevention System"
  },
  {
    "question": "Question 801.\n내부 정보의 외부 유출을 방지하는 보안 솔루션은?\n사내 직원이 사용하는 PC와 네트워크상의 모든 정보를 검색하고 메일 메신저, 웹하드, 네트워크 프린터 등의 사용자 행위를 탐지·통제해 외부로의 유출을 사전에 막는다.",
    "answer": "Answer 1 : 데이터 유출 방지\nAnswer 2 : DLP\nAnswer 3 : Data Leakage/Loss Prevention"
  },
  {
    "question": "Question 802.\n일반 방화벽이 탐지하지 못하는 SQL 삽입 공격, Cross-Site Scripting(XSS) 등의 웹 기반 공격을 방어할 목적으로 만들어진 웹 서버에 특화된 방화벽은?\n웹 관련 공격을 감시하고 공격이 웹 서버에 도달하기 전에 이를 차단해 준다.",
    "answer": "Answer 1 : 웹 방화벽\nAnswer 2 : Web Firewall"
  },
  {
    "question": "Question 803.\n인터넷 등 통신 사업자의 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션은?\nSSL ○○○ : PC에 ○○○ Client 프로그램을 설치하여 ○○○ 서버에 접속하는 방식으로, 암호화를 위해 SSL 프로토콜을 사용함.",
    "answer": "Answer 1 : IPSec ○○○ : ○○○ 서버가 설치된 각각의 네트워크를 서로 연결하는 방식으로, 암호화를 위해 IPSec 프로토콜을 사용함.\nAnswer 2 : VPN\nAnswer 3 : Virtual Private Network"
  },
  {
    "question": "Question 804.\n네트워크에 접속하는 내부 PC의 MAC 주소를 IP 관리 시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안 솔루션은?\n내부 PC의 소프트웨어 사용 현황을 관리하여 불법적인 소프트웨어 설치를 방지한다.",
    "answer": "Answer 1 : NAC\nAnswer 2 : Network Access Control"
  },
  {
    "question": "Question 805.\n다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합하여 관리하는 빅 데이터 기반의 보안 솔루션은?\n방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원을 절약할 수 있다.\n장기간의 로그 및 보안 이벤트를 수집 및 검색할 수 있는 빅데이터 기반의 통합 로그 수집 시스템이다.",
    "answer": "Answer 1 : SIEM\nAnswer 2 : Security Information and Event Management"
  },
  {
    "question": "Question 806.\n컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임은?\n컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로 동작하는 시스템 소프트웨어의 일종이다.\n다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다.\n프로세스, 기억장치, 주변장치, 파일 등을 관리하는 기능을 수행한다.",
    "answer": "Answer 1 : 운영체제\nAnswer 2 : OS\nAnswer 3 : Operating System"
  },
  {
    "question": "Question 807.\n다음은 운영체제의 네 가지 목적 중 하나에 대한 설명이다.\n일정 시간 내에 시스템이 처리하는 일의 양.",
    "answer": "Answer 1 : 처리 능력\nAnswer 2 : Throughput"
  },
  {
    "question": "Question 808.\n다음은 운영체제의 네 가지 목적 중 하나에 대한 설명이다.\n시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간",
    "answer": "Answer 1 : 반환 시간.\nAnswer 2 : Turn Around Time"
  },
  {
    "question": "Question 809.\n다음은 운영체제의 네 가지 목적 중 하나에 대한 설명이다.\n시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도.",
    "answer": "Answer 1 : 사용 가능도\nAnswer 2 : Availability"
  },
  {
    "question": "Question 810.\n다음은 운영체제의 네 가지 목적 중 하나에 대한 설명이다.\n시스템이 주어진 문제를 정확하게 해결하는 정도.",
    "answer": "Answer 1 : 신뢰도\nAnswer 2 : Reliability"
  },
  {
    "question": "Question 811.\n1990년대 마이크로소프트(Microsoft) 사가 개발한 운영체제는?",
    "answer": "Answer 1 : Windows"
  },
  {
    "question": "Question 812.\n1960년대 AT&T 벨(Bell) 연구소, MIT, General Electric이 공동 개발한 운영체제는?\n시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제이다.\n소스가 공개된 개방형 시스템(Open System)이다.\n대부분 C 언어로 작성되어 있어 이식성이 높으며, 장치, 프로세스 간의 호환성이 높다.",
    "answer": "Answer 1 : UNIX"
  },
  {
    "question": "Question 813.\n1991년 리누스 토발즈(Linus Torvalds)가 UNIX를 기반으로 개발한 운영체제는?\n프로그램 소스 코드가 무료로 공개되어 있기 때문에 프로그래머가 원하는 기능을 추가할 수 있다.\n다양한 플랫폼에 설치하여 사용이 가능하며, 재배포가 가능하다.\nUNIX와 완벽하게 호환된다.\n대부분의 특징이 UNIX와 동일하다.",
    "answer": "Answer 1 : LINUX"
  },
  {
    "question": "Question 814.\n1980년대 애플(Apple) 사가 UNIX를 기반으로 개발한 운영체제는?\n아이맥(iMac)과 맥북(MacBook) 등 애플 사에서 생산하는 제품에서만 사용이 가능하다.\n드라이버 설치 및 install과 uninstall의 과정이 단순하다.",
    "answer": "Answer 1 : MacOS"
  },
  {
    "question": "Question 815.\n구글(Google) 사에서 개발한 리눅스 커널 기반의 개방형 모바일 운영체제는?\n모든 코드가 공개된 개방형 소프트웨어이다.\n자바와 코틀린으로 애플리케이션을 작성한다.\n스마트폰 등의 휴대용 장치에서 주로 사용된다.",
    "answer": "Answer 1 : Android"
  },
  {
    "question": "Question 816.\n애플(Apple) 사에서 개발한 유닉스 기반의 모바일 운영체제는?\n아이폰, 아이팟 터치, 아이패드 등에 내장된다.\n애플사 고유의 모바일 운영체제로 타사 제품은 ○○○를 탑재할 수 없다.",
    "answer": "Answer 1 : iOS"
  },
  {
    "question": "Question 817.\n보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것은?\n종류.\n- 반입(Fetch) 전략.\n- 배치(Placement) 전략.\n- 교체(Replacement) 전략.",
    "answer": "Answer 1 : 기억장치의 관리 전략"
  },
  {
    "question": "Question 818.\n보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략은?",
    "answer": "Answer 1 : 반입 전략\nAnswer 2 : Fetch 전략"
  },
  {
    "question": "Question 819.\n다음은 반입 전략의 두 가지 기법 중 하나에 대한 설명이다.\n실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법.",
    "answer": "Answer 1 : 요구 반입\nAnswer 2 : Demand Fetch"
  },
  {
    "question": "Question 820.\n다음은 반입 전략의 두 가지 기법 중 하나에 대한 설명이다.\n실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법.",
    "answer": "Answer 1 : 예상 반입\nAnswer 2 : Anticipatory Fetch"
  },
  {
    "question": "Question 821.\n새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치 시킬 것인지를 결정하는 전략은?",
    "answer": "Answer 1 : 배치 전략\nAnswer 2 : Placement 전략"
  },
  {
    "question": "Question 822.\n다음은 배치 전략의 세 가지 기법 중 하나에 대한 설명이다.\n프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법.",
    "answer": "Answer 1 : 최초 적합\nAnswer 2 : First Fit"
  },
  {
    "question": "Question 823.\n다음은 배치 전략의 세 가지 기법 중 하나에 대한 설명이다.\n프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법.",
    "answer": "Answer 1 : 최적 적합\nAnswer 2 : Best Fit"
  },
  {
    "question": "Question 824.\n다음은 배치 전략의 세 가지 기법 중 하나에 대한 설명이다.\n프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법.",
    "answer": "Answer 1 : 최악 적합\nAnswer 2 : Worst Fit"
  },
  {
    "question": "Question 825.\n주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략은?\n종류 : FIFO, OPT, LRU, NUR, SCR 등.",
    "answer": "Answer 1 : 교체 전략\nAnswer 2 : Replacement 전략"
  },
  {
    "question": "Question 826.\n보조기억장치의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법은?\n프로그램을 여러 개의 작은 블록 단위로 나누어서 가상기억장치에 보관해놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리한다.\n주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다.\n블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있다.\n○○○의 일반적인 구현 방법 : 페이징 기법, 세그먼테이션 기법.",
    "answer": "Answer 1 : 가상기억장치\nAnswer 2 : Virtual Memory"
  },
  {
    "question": "Question 827.\n가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법은?\n프로그램을 일정한 크기로 나눈 단위를 페이지(Page)라고 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)이라고 한다.\n외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.\n주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블(Page Map Table)이 필요하다.\n페이지 맵 테이블 사용으로 비용이 증가하고, 처리 속도가 감소된다.",
    "answer": "Answer 1 : 페이징 기법\nAnswer 2 : Paging 기법"
  },
  {
    "question": "Question 828.\n가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법은?\n프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트(Segment)라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.\n○○○을 이용하는 궁극적인 이유는 기억공간을 절약하기 위해서이다.\n주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블(Segment Map Table)이 필요하다.\n내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.",
    "answer": "Answer 1 : 세그먼테이션 기법\nAnswer 2 : Segmentation 기법"
  },
  {
    "question": "Question 829.\n페이지 부재(Page Fault)가 발생하면 가상기억장치에서 필요한 페이지를 찾아 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법은?\n종류 : OPT, FIFO, LRU, LFU, NUR, SCR 등.",
    "answer": "Answer 1 : 페이지 교체 알고리즘"
  },
  {
    "question": "Question 830.\n다음은 페이지 교체 알고리즘의 여섯 가지 종류 중 하나에 대한 설명이다.\n앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법이다.\n벨레이디(Belady)가 제안한 것이다.\n페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘이다.",
    "answer": "Answer 1 : OPT\nAnswer 2 : OPTimal replacement\nAnswer 3 : 최적 교체"
  },
  {
    "question": "Question 831.\n다음은 페이지 교체 알고리즘의 여섯 가지 종류 중 하나에 대한 설명이다.\n각 체이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법이다.\n이해하기 쉽고 프로그래밍 및 설계가 간단하다.",
    "answer": "Answer 1 : FIFO\nAnswer 2 : First In First Out"
  },
  {
    "question": "Question 832.\n다음은 페이지 교체 알고리즘의 여섯 가지 종류 중 하나에 대한 설명이다.\n최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법이다.\n각 페이지마다 계수기(Counter)나 스택(Stack)을 두어 현시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래전에 사용한 페이지를 교체한다.",
    "answer": "Answer 1 : LRU\nAnswer 2 : Least Recently Used"
  },
  {
    "question": "Question 833.\n다음은 페이지 교체 알고리즘의 여섯 가지 종류 중 하나에 대한 설명이다.\n사용 빈도가 가장 적은 페이지를 교체하는 기법이다.\n활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용된다.",
    "answer": "Answer 1 : LFU\nAnswer 2 : Least Frequently Used"
  },
  {
    "question": "Question 834.\n다음은 페이지 교체 알고리즘의 여섯 가지 종류 중 하나에 대한 설명이다.\nLRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법이다.\n최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제로 LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.\n최근의 사용 여부를 확인하기 위해서 각 페이지마다 두 개의 비트, 즉 참조 비트(Reference Bit)와 변형 비트(Modified Bit, Dirty Bit)가 사용된다.",
    "answer": "Answer 1 : NUR\nAnswer 2 : Not Used Recently"
  },
  {
    "question": "Question 835.\n다음은 페이지 교체 알고리즘의 여섯 가지 종류 중 하나에 대한 설명이다.\n가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 기법이다.\nFIFO 기법의 단점을 보완하는데 사용된다.",
    "answer": "Answer 1 : SCR\nAnswer 2 : Second Chance Replacement\nAnswer 3 : 2차 기회 교체"
  },
  {
    "question": "Question 836.\n프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론은?\n스레싱을 방지하기 위한 워킹 셋 이론의 기반이 되었다.\n가상기억장치 관리와 캐시 메모리 시스템의 이론적인 근거이다.\n데닝(Denning) 교수에 의해 ○○○의 개념이 증명되었다.",
    "answer": "Answer 1 : Locality\nAnswer 2 : 국부성\nAnswer 3 : 지역성, 구역성, 국소성"
  },
  {
    "question": "Question 837.\n다음은 Locality의 두 가지 종류 중 하나에 대한 설명이다.\n프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상.",
    "answer": "Answer 1 : 시간 구역성\nAnswer 2 : Temporal Locality"
  },
  {
    "question": "Question 838.\n다음은 Locality의 두 가지 종류 중 하나에 대한 설명이다.\n프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상.",
    "answer": "Answer 1 : 공간 구역성\nAnswer 2 : Spatial Locality"
  },
  {
    "question": "Question 839.\n프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합은?\n데닝(Denning)이 제안한 프로그램의 움직임에 대한 모델로, 프로그램의 Locality 특징을 이용한다.\n자주 참조되는 ○○○을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정된다.",
    "answer": "Answer 1 : 워킹 셋\nAnswer 2 : Working Set"
  },
  {
    "question": "Question 840.\n프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상은?\n다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중에 자주 페이지 부재(Page Fault)가 발생함으로써 나타나며, 전체 시스템의 성능이 저하된다.\n다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소하게 된다.",
    "answer": "Answer 1 : 스래싱\nAnswer 2 : Thrashing"
  },
  {
    "question": "Question 841.\n일반적으로 프로세서에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미하는 것은?\n○○○는 다음과 같이 여러 가지로 정의할 수 있다.\n- PCB를 가진 프로그램.\n- 실기억장치에 저장된 프로그램.\n- 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위.\n- 프로시저가 활동중인 것.\n- 비동기적 행위를 일으키는 주체.\n- 지정된 결과를 얻기 위한 일련의 계통적 동작.\n- 목적 또는 결과에 따라 발생되는 사건들의 과정.\n- 운영체제가 관리하는 실행 단위.",
    "answer": "Answer 1 : 프로세스\nAnswer 2 : Process"
  },
  {
    "question": "Question 842.\n운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳은?\n각 프로세스가 생성될 때마다 고유의 ○○○가 생성되고, 프로세스가 완료되면 ○○○는 제거된다.\n○○○에 저장되어 있는 정보.\n- 프로세스의 현재 상태.\n- 포인터.\n- 프로세스 고유 식별자.\n- 스케줄링 및 프로세스의 우선순위.\n- CPU 레지스터 정보.\n- 주기억장치 관리 정보.\n- 입·출력 상태 정보.\n- 계정 정보.",
    "answer": "Answer 1 : PCB\nAnswer 2 : Process Control Block\nAnswer 3 : 프로세스 제어 블록"
  },
  {
    "question": "Question 843.\n프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것을 의미하는 것은?",
    "answer": "Answer 1 : 프로세스 상태 전이"
  },
  {
    "question": "Question 844.\n다음은 프로세스 상태 전이 관련 용어 중 하나에 대한 설명이다.\n준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정.",
    "answer": "Answer 1 : Dispatch"
  },
  {
    "question": "Question 845.\n다음은 프로세스 상태 전이 관련 용어 중 하나에 대한 설명이다.\n입·출력 작업이 완료되어 프로세서가 대기 상태에서 준비 상태로 전이 되는 과정.",
    "answer": "Answer 1 : Wake Up"
  },
  {
    "question": "Question 846.\n다음은 프로세스 상태 전이 관련 용어 중 하나에 대한 설명이다.\n입·출력장치의 공유 및 상대적으로 느린 입·출력장치의 처리 속도를 보완하고 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입·출력할 데이터를 직접 입·출력장치에 보내지않고 나중에 한꺼번에 입·출력하기 위해 디스크에 저장하는 과정.",
    "answer": "Answer 1 : Spooling"
  },
  {
    "question": "Question 847.\n다음은 프로세스 상태 전이 관련 용어 중 하나에 대한 설명이다.\n프로세스의 상태에 대한 조사와 통보 담당.",
    "answer": "Answer 1 : 교통량 제어기\nAnswer 2 : Traffic Controller"
  },
  {
    "question": "Question 848.\n시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위 또는 프로세스 내에서의 작업 단위로 사용되는 것은?\n하나의 프로세스에 하나의 ○○○가 존재하는 경우에는 단일 ○○○, 하나 이상의 ○○○가 존재하는 경우에는 다중 ○○○라고 한다.\n프로세스의 일부 특성을 갖고 있기 때문에 경량(Light Weight) 프로세스라고도 한다.\n○○○ 기반 시스템에서 ○○○는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당한다.",
    "answer": "Answer 1 : 스레드\nAnswer 2 : Thread"
  },
  {
    "question": "Question 849.\n프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업을 의미하는 것은?\n프로세스가 생성되어 완료될 때까지 프로세스는 여러 종류의 스케줄링 과정을 거치게 된다.",
    "answer": "Answer 1 : 스케줄링\nAnswer 2 : Scheduling"
  },
  {
    "question": "Question 850.\n다음은 스케줄링의 세 가지 종류 중 하나에 대한 내용이다.\n어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업.",
    "answer": "Answer 1 : 장기 스케줄링"
  },
  {
    "question": "Question 851.\n다음은 스케줄링의 세 가지 종류 중 하나에 대한 내용이다.\n어떤 프로세스들이 CPU를 할당받을 것인지 결정하는 작업.",
    "answer": "Answer 1 : 중기 스케줄링"
  },
  {
    "question": "Question 852.\n다음은 스케줄링의 세 가지 종류 중 하나에 대한 내용이다.\n프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업.",
    "answer": "Answer 1 : 단기 스케줄링"
  },
  {
    "question": "Question 853.\n다음은 스케줄링의 열 가지 목적 중 하나에 대한 내용이다.\n모든 프로세스에 공정하게 할당함.",
    "answer": "Answer 1 : 공정성"
  },
  {
    "question": "Question 854.\n다음은 스케줄링의 열 가지 목적 중 하나에 대한 내용이다.\n단위 시간당 프로세스를 처리하는 비율을 증가시킴.",
    "answer": "Answer 1 : 처리율 증가"
  },
  {
    "question": "Question 855.\n다음은 스케줄링의 열 가지 목적 중 하나에 대한 내용이다.\nCPU가 순수하게 프로세스를 실행하는 데 사용되는 시간 비율을 증가시킴.",
    "answer": "Answer 1 : CPU 이용률 증가"
  },
  {
    "question": "Question 856.\n다음은 스케줄링의 열 가지 목적 중 하나에 대한 내용이다.\n우선순위가 높은 프로세스를 먼저 실행함.",
    "answer": "Answer 1 : 우선순위 제도"
  },
  {
    "question": "Question 857.\n다음은 스케줄링의 열 가지 목적 중 하나에 대한 내용이다.\n오버헤드를 최소화함.",
    "answer": "Answer 1 : 오버헤드 최소화"
  },
  {
    "question": "Question 858.\n다음은 스케줄링의 열 가지 목적 중 하나에 대한 내용이다.\n작업을 지시하고, 반응하기 시작하는 시간을 최소화함.",
    "answer": "Answer 1 : 응답 시간 최소화"
  },
  {
    "question": "Question 859.\n다음은 스케줄링의 열 가지 목적 중 하나에 대한 내용이다.\n프로세스를 제출한 시간부터 실행이 완료될 때까지 걸리는 시간을 최소화함.",
    "answer": "Answer 1 : 반환 시간 최소화"
  },
  {
    "question": "Question 860.\n다음은 스케줄링의 열 가지 목적 중 하나에 대한 내용이다.\n프로세스가 준비상태 큐에서 대기하는 시간을 최소화함.",
    "answer": "Answer 1 : 대기 시간 최소화"
  },
  {
    "question": "Question 861.\n다음은 스케줄링의 열 가지 목적 중 하나에 대한 내용이다.\n메모리, 입·출력장치 등의자원을 균형 있게 사용함.",
    "answer": "Answer 1 : 균형 있는 자원의 사용"
  },
  {
    "question": "Question 862.\n다음은 스케줄링의 열 가지 목적 중 하나에 대한 내용이다.\n자원을 사용하기 위해 무한정 연기되는 상태를 회피함.",
    "answer": "Answer 1 : 무한 연기 회피"
  },
  {
    "question": "Question 863.\n이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용 할 수 없는 스케줄링 기법은?\n프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다.\n프로세스 앙답 시간의 예측이 용이하다.\n일괄 처리 방식에 적합하다.\n종류 : FCFS, SJF, 우선순위, HRN, 기한부 등.",
    "answer": "Answer 1 : 비선점 스케줄링\nAnswer 2 : Non-Preemptive 스케줄링"
  },
  {
    "question": "Question 864.\n하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법은?\n우선순위가 높은 프로세스를 빠르게 처리할 수 있다.\n주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용된다.\n많은 오버헤드(Overhead)를 초래한다.\n종류 : Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등.",
    "answer": "Answer 1 : 선점 스케줄링\nAnswer 2 : Preemptive 스케줄링"
  },
  {
    "question": "Question 865.\n준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법은?\n가장 간단한 알고리즘이다.",
    "answer": "Answer 1 : FCFS\nAnswer 2 : First Come First Service\nAnswer 3 : 선입 선출; FIFO; First If First Out"
  },
  {
    "question": "Question 866.\n준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법은?\n가장 적은 평균 대기 시간을 제공하는 최적 알고리즘이다.",
    "answer": "Answer 1 : SJF\nAnswer 2 : Shortest Job First\nAnswer 3 : 단기 작업 우선"
  },
  {
    "question": "Question 867.\n대기 시간과 서비스(실행) 시간을 이용하는 기법은?\n실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것이다.\n우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여된다.\n우선순위 계산식은 (대기시간 + 서비스 시간) / 서비스 시간.",
    "answer": "Answer 1 : HRN\nAnswer 2 : highest Response-ratio Next"
  },
  {
    "question": "Question 868.\n각 프로세스를 시간 할당량(Time Slice, Quantum) 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주는 기법은?\n시분할 시스템(Time Sharing System)을 위해 고안된 방식으로, 할당되는 시간의 크기가 작으면 작은 프로세스들에게 유리하다.\n할당되는 시간이 클 경우 FCFS 기법과 같아지고, 할당되는 시간이 작을 경우 문맥 교환 및 오버헤드가 자주 발생되어 요청된 작업을 신속히 처리할 수 없다.",
    "answer": "Answer 1 : RR\nAnswer 2 : Round Robin"
  },
  {
    "question": "Question 869.\n현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행 시간을 비교하여 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당하는 기법은?\n시분할 시스템에 유용하며 준비상태 큐에 있는 각 프로세스의 실행 시간을 추적하여 보유하고 있어야 하므로 오버헤드가 증가한다.",
    "answer": "Answer 1 : SRT\nAnswer 2 : Shortest Remaining Time"
  },
  {
    "question": "Question 870.\n시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임을 의미하는 것은?\n변수명과 값으로 구성된다.\n시스템의 기본 정보를 저장한다.\n자식 프로세스에 상속된다.\n시스템 전반에 걸쳐 적용되는 시스템 ○○○와 사용자 계정 내에서만 적용되는 사용자 ○○○로 구분된다.",
    "answer": "Answer 1 : 환경 변수\nAnswer 2 : Environment Variable"
  },
  {
    "question": "Question 871.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n현재 디렉터리의 파일 목록을 표시함.",
    "answer": "Answer 1 : DIR"
  },
  {
    "question": "Question 872.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n파일을 복사함.",
    "answer": "Answer 1 : COPY"
  },
  {
    "question": "Question 873.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n파일을 삭제함.",
    "answer": "Answer 1 : DEL"
  },
  {
    "question": "Question 874.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n파일의 내용을 표시함.",
    "answer": "Answer 1 : TYPE"
  },
  {
    "question": "Question 875.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n파일의 이름을 변경함.",
    "answer": "Answer 1 : REN"
  },
  {
    "question": "Question 876.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n디렉터리를 생성함.",
    "answer": "Answer 1 : MD"
  },
  {
    "question": "Question 877.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n동일한 드라이브에서 디렉터리의 위치를 변경함.",
    "answer": "Answer 1 : CD"
  },
  {
    "question": "Question 878.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n화면의 내용을 지움.",
    "answer": "Answer 1 : CLS"
  },
  {
    "question": "Question 879.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n파일의 속성을 변경함.",
    "answer": "Answer 1 : ATTRIB"
  },
  {
    "question": "Question 880.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n파일에서 문자열을 찾음.",
    "answer": "Answer 1 : FIND"
  },
  {
    "question": "Question 881.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n디스크 상태를 점검함.",
    "answer": "Answer 1 : CHKDSK"
  },
  {
    "question": "Question 882.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n디스크 표면을 트랙과 섹터로 나누어 초기화함.",
    "answer": "Answer 1 : FORMAT"
  },
  {
    "question": "Question 883.\n다음은 Windows 기본 명령어 중 하나에 대한 설명이다.\n파일을 이동함.",
    "answer": "Answer 1 : MOVE"
  },
  {
    "question": "Question 884.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n파일 내용을 화면에 표시함.",
    "answer": "Answer 1 : cat"
  },
  {
    "question": "Question 885.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n디렉터리의 위치를 변경함.",
    "answer": "Answer 1 : cd"
  },
  {
    "question": "Question 886.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n파일의 보호 모드를 설정하여 파일의 사용 허가를 지정함.",
    "answer": "Answer 1 : crmod"
  },
  {
    "question": "Question 887.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n파일 소유자와 그룹을 변경함.",
    "answer": "Answer 1 : chown"
  },
  {
    "question": "Question 888.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n파일을 복사함.",
    "answer": "Answer 1 : cp"
  },
  {
    "question": "Question 889.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n파일을 삭제함.",
    "answer": "Answer 1 : rm"
  },
  {
    "question": "Question 890.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n파일을 찾음.",
    "answer": "Answer 1 : find"
  },
  {
    "question": "Question 891.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n파일 시스템을 검사하고 보수함.",
    "answer": "Answer 1 : fsck"
  },
  {
    "question": "Question 892.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\nPID(프로세스 고유 번호)를 이용하여 프로세스를 종료함.",
    "answer": "Answer 1 : kill"
  },
  {
    "question": "Question 893.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n새로운 프로세스를 생성함.",
    "answer": "Answer 1 : fork"
  },
  {
    "question": "Question 894.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n프로세스의 이름을 이용하여 프로세스를 종료함.",
    "answer": "Answer 1 : killall"
  },
  {
    "question": "Question 895.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n현재 디렉터리의 파일 목록을 표시함.",
    "answer": "Answer 1 : ls"
  },
  {
    "question": "Question 896.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n디렉터리를 생성함.",
    "answer": "Answer 1 : mkdir"
  },
  {
    "question": "Question 897.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n디렉터리를 삭제함.",
    "answer": "Answer 1 : rmdir"
  },
  {
    "question": "Question 898.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n파일을 이동함.",
    "answer": "Answer 1 : mv"
  },
  {
    "question": "Question 899.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n현재 실행중인 프로세스를 표시함.",
    "answer": "Answer 1 : ps"
  },
  {
    "question": "Question 900.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n현재 작업중인 디렉터리 경로를 화면에 표시함.",
    "answer": "Answer 1 : pwd"
  },
  {
    "question": "Question 901.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n시스템의 프로세스와 메모리 사용 현황을 표시함.",
    "answer": "Answer 1 : top"
  },
  {
    "question": "Question 902.\n다음은 UNIX/LINUX의 기본 명령어 중 하나에 대한 설명이다.\n현재 시스템에 접속해 있는 사용자를 표시함.",
    "answer": "Answer 1 : who"
  },
  {
    "question": "Question 903.\nTCP/IP 프로토콜을 기반으로 하여 전 세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망은?\n○○○에 연결된 모든 컴퓨터는 고유한 IP 주소를 갖는다.",
    "answer": "Answer 1 : 인터넷"
  },
  {
    "question": "Question 904.\n인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소는?\n8비트씩 4부분, 총 32비트로 구성되어 있다.",
    "answer": "Answer 1 : IP 주소\nAnswer 2 : Internet Protocol Address"
  },
  {
    "question": "Question 905.\n할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것은?\n4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다.\n서브넷 마스크는 각 클래스마다 다르게 사용된다.",
    "answer": "Answer 1 : 서브네팅\nAnswer 2 : Subnetting"
  },
  {
    "question": "Question 906.\n현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발된 것은?\n128비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있다.\nIPv4에 비해 자료 전송 속도가 빠르다.\n인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있다.\n주소의 확장성, 융통성, 연동성이 뛰어나다.\n실시간 흐름 제어로 향상된 멀티미디어 기능을 지원한다.\n패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없다.\n기본 헤더 뒤에 확장 헤더를 더함으로써 더욱 다양한 정보의 저장이 가능해져 네트워크 기능 확장이 용이하다.\nIPv4와 호환성이 뛰어나다.",
    "answer": "Answer 1 : IPv6\nAnswer 2 : Internet Protocol version 6"
  },
  {
    "question": "Question 907.\n숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것은?\n호스트 컴퓨터 이름, 소속 기관 이름, 소속 기관의 종류, 소속 국가명 순으로 구성되며, 왼쪽에서 오른쪽으로 갈수록 상위 도메인을 의미한다.\n문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할을 하는 시스템을 DNS(Domain Name System)라고 하며 이런 역할을 하는 서버를 DNS 서버라고 한다.",
    "answer": "Answer 1 : 도메인 네임\nAnswer 2 : Domain Name"
  },
  {
    "question": "Question 908.\n다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol)은?\nOSI 7계층은 1~3 계층을 하위 계층, 4~7 계층을 상위 계층이라고 한다.",
    "answer": "Answer 1 : OSI 참조 모델\nAnswer 2 : Open System Interconnection 참조 모델"
  },
  {
    "question": "Question 909.\n전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의한 것은?\n물리적 전송 매체와 전송 신호 방식을 정의한다.\nRS-232C, X닷21 등의 표쥰이 있다.\n관련 장비 : 리피터, 허브.",
    "answer": "Answer 1 : 물리 계층\nAnswer 2 : Physical layer"
  },
  {
    "question": "Question 910.\n두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당하는 것은?\n송신 측과 수신 측의 속도 차이 해결을 위한 흐름 제어 기능을 한다.\n프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 기능을 한다.\n오류의 검출과 회복을 위한 오류 제어 기능을 한다.\nHDLC, LAPB, LLC, MAC, LAPD, PPP 등의 표준이 있다.\n관련 장비 : 랜카드, 브리지, 스위치.",
    "answer": "Answer 1 : 데이터 링크 계층\nAnswer 2 : Data Link Layer"
  },
  {
    "question": "Question 911.\n개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 하는 것은?\n네트워크 연결을 설정, 유지, 해제하는 기능을 한다.\n경로 설정(Routing), 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송을 수행한다.\nX닷25, IP 등의 표쥰이 있다.\n관련 장비 : 라우터.",
    "answer": "Answer 1 : 네트워크 계층\nAnswer 2 : 망 계층\nAnswer 3 : Network Layer"
  },
  {
    "question": "Question 912.\n논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템(End-to-End) 간에 투명한 데이터 전송을 가능하게 한다.\nOSI 7계층 중 하위 3계층과 상위 3계층의 인터페이스(Interface)를 담당한다.\n종단 시스템(End-to-End) 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능을 한다.\n주소 설정, 다중화(분할 및 재조립), 오류 제어, 흐름 제어를 수행한다.\nTCP, UDP 등의 표준이 있다.\n관련 장비 : 게이트웨이.",
    "answer": "Answer 1 : 전송 계층\nAnswer 2 : Transport Layer"
  },
  {
    "question": "Question 913.\n송·수신 측 간의 관련성을 유지하고 대화 제어를 담당하는 것은?\n대화(회화) 구성 및 동기 제어, 데이터 교환 관리 기능을 한다.\n대화의 생성, 관리, 종료를 위해 토큰을 사용한다.\n동기점은 오류가 있는 데이터의 회복을 위해 사용하는 것으로, 종류에는 소동기점과 대동기점이 있다.",
    "answer": "Answer 1 : 세션 계층\nAnswer 2 : Session Layer"
  },
  {
    "question": "Question 914.\n응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 하는 것은?\n서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층이다.\n코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식(포맷) 변환, 문맥관리 기능을 한다.",
    "answer": "Answer 1 : 표현 계층\nAnswer 2 : Presentation Layer"
  },
  {
    "question": "Question 915.\n사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공하는 것은?\n응용 프로세스 간의 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 등의 서비스를 제공한다.",
    "answer": "Answer 1 : 응용 계층\nAnswer 2 : Application Layer"
  },
  {
    "question": "Question 916.\n컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치는?\n정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경한다.\n이더넷 카드(LAN 카드) 혹은 네트워크 어댑터라고 한다.",
    "answer": "Answer 1 : 네트워크 인터페이스 카드\nAnswer 2 : NIC\nAnswer 3 : Netwokr Internet Card"
  },
  {
    "question": "Question 917.\n한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각각의 회선을 통합하여 관리하는 것은?\n신호 증폭 기능을 하는 리피터의 역할을 포함한다.\n○○○ 종류.\n- 더미 ○○○(Dummy ○○○) : 네트워크에 흐르는 모든 데이터를 단순히 연결하는 기능만 제공하는 ○○○.\n- 스위칭 ○○○(Switching ○○○) : 네트워크상에 흐르는 데이터의 유무 및 흐름을 제어하여 각각의 노드가 ○○의 최대 대역폭을 사용할 수 있는 지능형 ○○.",
    "answer": "Answer 1 : 허브\nAnswer 2 : Hub"
  },
  {
    "question": "Question 918.\n거리가 증가할수록 감쇠하는 디지털 신호의 장거리 전송을 위해 수신한 신호를 재생시키거나 출력 전압을 높여 전송하는 장치는?\nOSI 참조 모델의 물리 계층에서 동작하는 장비이다.\n전송 거리의 연장 또는 배선의 자유도를 높이기 위한 용도로 사용된다.",
    "answer": "Answer 1 : 리피터\nAnswer 2 : Repeater"
  },
  {
    "question": "Question 919.\nLAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹을 연결하는 장치는?\n네트워크의 수많은 단말기들에 의해 발생되는 트래픽 병목 현상을 줄일 수 있다.\n네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있다.\n○○○를 이용한 서브넷(Subnet) 구성 시 전송 가능한 최선 수는 ○○○가 n개 일 때, n(n-1)/2개이다.",
    "answer": "Answer 1 : 브리지\nAnswer 2 : Bridge"
  },
  {
    "question": "Question 920.\n브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치는?\n하드웨어를 기반으로 처리하므로 전송 속도가 빠르다.\n포트마다 서로 다른 전송 속도를 지원하게 제어할 수 있다.\n수십에서 수백 개의 포트를 제공한다.\nOSI 참조 모델의 데이터 링크 계층에서 사용된다.",
    "answer": "Answer 1 : 스위치\nAnswer 2 : Switch"
  },
  {
    "question": "Question 921.\n브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택하는 기능이 추가된 장치는?\n서로 다른 LAN 또는 LAN과 WAN을 연결하는 기능도 한다.\nOSI 참조 모델의 네트워크 계층에서 동작하는 장비이다.\n3계층, 즉 네트워크 계층까지의 프로토콜 구조가 다른 네트워크 간의 연결을 위해 프로토콜 변환 기능을 수행한다.",
    "answer": "Answer 1 : 라우터\nAnswer 2 : Router"
  },
  {
    "question": "Question 922.\nOSI 전 계층의 프로토콜 구조가 다른 네트워크를 연결하는 장치는?\nLAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할을 한다.\n세션 계층, 표현 계층, 응용 계층 간을 연결하여 데이터 형식 변환, 주소 변환, 프로토콜 변환 등을 수행한다.",
    "answer": "Answer 1 : 게이트웨이\nAnswer 2 : Gateway"
  },
  {
    "question": "Question 923.\n서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약은?\n○○○의 기능 : 단편화와 재결합, 캡슐화, 흐름 제어, 오류 제어, 동기화, 순서 제어, 주소 지정, 다중화, 경로 제어, 전송 서비스 등.\n○○○의 기본 요소.\n구문(Syntax) : 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정함.\n의미(Semantics) : 두 기기 간의 효율적으로 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정함.\n시간(Timing) : 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정함.",
    "answer": "Answer 1 : 프로토콜\nAnswer 2 : Protocol"
  },
  {
    "question": "Question 924.\n인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜은?",
    "answer": "Answer 1 : TCP/IP\nAnswer 2 : Tranmission Control Protocol/Internet Protocol"
  },
  {
    "question": "Question 925.\nOSI 7계층의 전송 계층에 해당하며, 가상 회선 방식을 기반으로 하는 연결형 서비스를 제공하는 것은?\n패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능을 제공한다.",
    "answer": "Answer 1 : TCP\nAnswer 2 : Trasmission Control Protocol"
  },
  {
    "question": "Question 926.\nOSI 7계층의 네트워크 계층에 해당하며, 데이터그램 방식을 기반으로 하는 비연결형 서비스를 제공하는 것은?\n패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공한다.",
    "answer": "Answer 1 : IP\nAnswer 2 : Internet Protocol"
  },
  {
    "question": "Question 927.\n다음은 응용 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고 받을 수 있도록 하는 원격 파일 전송 프로토콜.",
    "answer": "Answer 1 : FTP\nAnswer 2 : File Tranfer Protocol"
  },
  {
    "question": "Question 928.\n다음은 응용 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n전자 우편을 교환하는 서비스.",
    "answer": "Answer 1 : SMTP\nAnswer 2 : Simple Mail Transfer Protocol"
  },
  {
    "question": "Question 929.\n다음은 응용 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n① 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스.\n② 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널(Virtual Terminal) 기능을 수행함.",
    "answer": "Answer 1 : TELNET"
  },
  {
    "question": "Question 930.\n다음은 응용 계층의 주요 프로토콜 중 하나에 대한 설명이다.\nTCP/IP의 네트워크 관리 프로토콜로, 라우터나 허브 등 네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는데 사용되는 표준 통신 규약.",
    "answer": "Answer 1 : SNMP\nAnswer 2 : Simple Network Management Protocol"
  },
  {
    "question": "Question 931.\n다음은 응용 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n도메인 네임을 IP 주소로 매핑(Mapping)하는 시스템.",
    "answer": "Answer 1 : DNS\nAnswer 2 : Domain Name System"
  },
  {
    "question": "Question 932.\n다음은 응용 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n월드 와이드 웹(WWW)에서 HTML 문서를 송수신 하기 위한 표준 프로토콜.",
    "answer": "Answer 1 : HTTP\nAnswer 2 : Hyper Text Transfer Protocol"
  },
  {
    "question": "Question 933.\n다음은 전송 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n① 양방향 연결(Full Duplex Connection)형 서비스를 제공함.\n② 가상 회선 연결(Cirtual Circuit Connection) 형태의 서비스를 제공함.\n③ 스트림 위주의 전달(패킷 단위)을 함.\n④신뢰성 있는 경로를 확립하고 메시지 전송을 감독함.\n⑤ 순서 제어, 오류 제어, 흐름 제어 기능을 함.\n⑥ 패킷의 분실, 손상, 지연이나 순서가 틀린 것 등이 발생할 때 투명성이 보장되는 통신을 제공함.\n⑦ ○○○ 프로토콜의 헤더는 기본적으로 20Byte에서 60Byte까지 사용할 수 있는데, 선택적으로 40Byte를 더 추가할 수 있으므로 최대 100Byte까지 크기를 확장할 수 있음.",
    "answer": "Answer 1 : TCP\nAnswer 2 : Transmission Control Protocol"
  },
  {
    "question": "Question 934.\n다음은 전송 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n① 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공함.\n② TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로, 오버헤드가 적고, 흐름 제어나 순서 제어가 없어 전송 속도가 빠름.\n③ 고속의 안정성 있는 전송 매체를 사용하여 빠른 속도를 필요로 하는 경우, 동시에 여러 사용자에게 데이터를 전달할 경우, 정기적으로 반복해서 전송할 경우에 사용함.\n④실시간 전송에 유리하며, 신뢰성보다는 속도가 중요시되는 네트워크에서 사용됨.\n⑤ ○○○ 헤더에는 Source Port Number, Destination Port Number, Length, Checksum 등이 포함됨.",
    "answer": "Answer 1 : UDP\nAnswer 2 : User Datagram Protocol"
  },
  {
    "question": "Question 935.\n다음은 전송 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n① RTP(Real-time Transport Protocol) 패킷의 전송 품질을 제어하기 위한 제어 프로토콜.\n② 세선(Session)에 참여한 각 참여자들에게 주기적으로 제어 정보를 전송함.\n③ 하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화(Multiplexing)를 제공함.\n④데이터 전송을 모니터링하고 최소한의 제어와 인증 기능만을 제공함.\n⑤ ○○○ 패킷은 항상 32비트의 경계로 끝남.",
    "answer": "Answer 1 : RTCP\nAnswer 2 : Real-Time Control Protocol"
  },
  {
    "question": "Question 936.\n다음은 인터넷 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n① 전송할 데이터에 주소를 지정하고, 경로를 설정하는 기능을 함.",
    "answer": "Answer 1 : IP\nAnswer 2 : Internet Protocol"
  },
  {
    "question": "Question 937.\n다음은 인터넷 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n① IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 역할을 함.\n② 헤더는 8Byte로 구성됨.",
    "answer": "Answer 1 : ICMP\nAnswer 2 : Internet Control Message Protocol\nAnswer 3 : 인터넷 제어 메시지 프로토콜"
  },
  {
    "question": "Question 938.\n다음은 인터넷 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용됨.",
    "answer": "Answer 1 : IGMP\nAnswer 2 : Internet Group Management Protocol\nAnswer 3 : 인터넷 그룹 관리 프로토콜"
  },
  {
    "question": "Question 939.\n다음은 인터넷 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC Address)로 바꿈.",
    "answer": "Answer 1 : ARP\nAnswer 2 : Address Resolution Protocol\nAnswer 3 : 주소 분석 프로토콜"
  },
  {
    "question": "Question 940.\n다음은 인터넷 계층의 주요 프로토콜 중 하나에 대한 설명이다.\nARP와 반대로 물리적 주소를 IP 주소로 변환하는 기능을 함.",
    "answer": "Answer 1 : RARP\nAnswer 2 : Reverse Address Resolution Protocol"
  },
  {
    "question": "Question 941.\n다음은 네트워크 액세스 계층의 주요 프로토콜 중 하나에 대한 설명이다.\nCSMA/CD 방식의 LAN.",
    "answer": "Answer 1 : Ethernet(IEEE 802.3)"
  },
  {
    "question": "Question 942.\n다음은 네트워크 액세스 계층의 주요 프로토콜 중 하나에 대한 설명이다.\nLAN을 위한 표준 프로토콜.",
    "answer": "Answer 1 : IEEE 802"
  },
  {
    "question": "Question 943.\n다음은 네트워크 액세스 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n비트 위주의 데이터 링크 제어 프로토콜.",
    "answer": "Answer 1 : HDLC"
  },
  {
    "question": "Question 944.\n다음은 네트워크 액세스 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜.",
    "answer": "Answer 1 : X.25"
  },
  {
    "question": "Question 945.\n다음은 네트워크 액세스 계층의 주요 프로토콜 중 하나에 대한 설명이다.\n공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜.",
    "answer": "Answer 1 : RS-232C"
  },
  {
    "question": "Question 946.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n정보 통신 기술을 기반으로 실세계9(Physical World)와 가상 세계(Virtual World)의 다양한 사물들을 인터넷으로 서로 연결하여 진보된 서비스를 제공하기 위한 서비스 기반 기술.",
    "answer": "Answer 1 : IoT\nAnswer 2 : Internet of Things\nAnswer 3 : 사물인터넷"
  },
  {
    "question": "Question 947.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 무선 통신을 이용한 기계와 기계 사이의 통신.\n② 변압기 원격 감시, 전기, 가스 등의 원격 검침, 무선 신용카드 조회기, 무선 보안단말기, 버스 운행 시스템, 위치 추적 시스템, 시설물 관리 등을 무선으로 통합하여 상호 작용하는 통신.",
    "answer": "Answer 1 : M2M\nAnswer 2 : Machine to Machine\nAnswer 3 : 사물 통신"
  },
  {
    "question": "Question 948.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n휴대형 기기로 이동하면서 자유로이 네트워크에 접속하여 업무를 처리할 수 있는 환경.",
    "answer": "Answer 1 : 모바일 컴퓨팅\nAnswer 2 : Mobile Computing"
  },
  {
    "question": "Question 949.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n각종 컴퓨팅 자원을 중앙 컴퓨터에 두고 인터넷 기능을 갖는 단말기로 언제 어디서나 인터넷을 통해 컴퓨터 작업을 수행할 수 있는 가상화된 환경.",
    "answer": "Answer 1 : 클라우드 컴퓨팅\nAnswer 2 : Cloud Computing"
  },
  {
    "question": "Question 950.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n자리적으로 분산되어 있는 컴퓨터를 초고속 인터넷망으로 연결하여 공유함으로써 하나의 고성능 컴퓨터처럼 활용하는 기술.",
    "answer": "Answer 1 : 그리그 컴퓨팅\nAnswer 2 : Grid Computing"
  },
  {
    "question": "Question 951.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n소비자와 소비자의 파트너가 클라우드 서비스를 이용하여 모바일 기기로 클라우드 컴퓨팅 인프라를 구성하여 여러 가지 정보와 자원을 공유하는 ICT 기술.",
    "answer": "Answer 1 : 모바일 클라우드 컴퓨팅\nAnswer 2 : MCC\nAnswer 3 : Mobile Cloud Computing"
  },
  {
    "question": "Question 952.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n각기 다른 클라우드 서비스를 연동하거나 컴퓨팅 자원의 동적 할당이 가능하도록 여러 클라우드 서비스 제공자들이 제공하는 클라우드 서비스나 자원을 연결하는 기술.",
    "answer": "Answer 1 : 인터클라우드 컴퓨팅\nAnswer 2 : Inter-Cloud Computing"
  },
  {
    "question": "Question 953.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 차세대 이동통신, 홈네트워킹, 공공 안전 등 특수 목적을 위한 새로운 방식의 네트워크 기술.\n② 대규모 디바이스의 네트워크 생성에 최적화되어 있음.",
    "answer": "Answer 1 : 메시 네트워크\nAnswer 2 : Mesh Network"
  },
  {
    "question": "Question 954.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n스마트 그리드와 같은 장거리 무선 통신을 필요로 하는 사물 인터넷(IoT) 서비스를 위한 저전력 장거리(LPWA; Low-Power Wide Area) 통신 기술.",
    "answer": "Answer 1 : 와이선\nAnswer 2 : Wi-SUN"
  },
  {
    "question": "Question 955.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 콘텐츠 자체의 정보와 라우터 기능만으로 데이터 전송을 수행하는 기술.\n② 클라이언트와 서버가 패킷의 헤더에 내장되어 있는 주소 정보를 이용하여 연결되던 기존의 IP(Internet Protocol)망을 대체할 새로운 인터넷 아키텍처로 떠오르고 있음.",
    "answer": "Answer 1 : NDN\nAnswer 2 : Named Data Networking"
  },
  {
    "question": "Question 956.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① ITU-T에서 개발하고 있는 유선망 기반의 차세대 통신망.\n② 유선망뿐만 아니라 이동 사용자를 목표로 하며, 이동통신에서 제공하는 완전한 이동성(Full Mobility) 제공을 목표로 개발되고 있음.",
    "answer": "Answer 1 : NGN\nAnswer 2 : Next Generation Network\nAnswer 3 : 차세대 통신망"
  },
  {
    "question": "Question 957.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n네트워크를 컴퓨터처럼 모델링하여 여러 사용자가 각각의 소프트웨어로 네트워킹을 가상화하여 제어하고 관리하는 네트워크.",
    "answer": "Answer 1 : SDN\nAnswer 2 : Software Defined Networking\nAnswer 3 : 소프트웨어 정의 네트워킹"
  },
  {
    "question": "Question 958.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 고주파(HF)를 이용한 근거리 무선 통신 기술.\n② 아주 가까운 거리에서 양방향 통신을 지원하는 RFID 기술의 일종임.",
    "answer": "Answer 1 : NFC\nAnswer 2 : Near Field Communication\nAnswer 3 : 근거리 무선 통신"
  },
  {
    "question": "Question 959.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n짧은 거리에서 많은 양의 디지털 데이터를 낮은 전력으로 전송하기 위한 무선 기술로 무선 디지털 펄스라고도 함.\n② 1/2mW 정도으 저전력으로 많은 양의 데이터를 1km의 거리까지 전송할 수 있을 뿐만 아니라, 땅속이나 벽면 뒤로도 전송이 가능함.",
    "answer": "Answer 1 : UWB\nAnswer 2 : Ultra WideBand\nAnswer 3 : 초광대역"
  },
  {
    "question": "Question 960.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n여러 개의 독립된 통신장치가 블루투스 기술이나 UWB 통신 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술.",
    "answer": "Answer 1 : 피코넷\nAnswer 2 : PICONET"
  },
  {
    "question": "Question 961.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n웨어러블(Wearablr) 또는 몸에 심는(Implant) 형태의 센서나 기기를 무선으로 연결하는 개인 영역 네트워킹 기술.",
    "answer": "Answer 1 : WBAN\nAnswer 2 : Wireless Body Area Network"
  },
  {
    "question": "Question 962.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 지리적인 자료를 수집·저장·분석·출력할 수 있는 컴퓨터 응용 시스템.\n② 위성을 이용해 모든 사물의 위치 정보를 제공해 줌.",
    "answer": "Answer 1 : GIS\nAnswer 2 : Geographic Information System\nAnswer 3 : 지리 정보 시스템"
  },
  {
    "question": "Question 963.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 각종 센서로 수집한 정보를 무선으로 수집할 수 있도록 구성한 네트워크.\n② 필요한 모든 것에 RFID 태그를 부착하고, 이를 통하여 사물의 인식정보는 물론 주변의 환경정보까지 탐지하여 이를 네으퉈크에 연결하여 정보를 관리함.",
    "answer": "Answer 1 : USN\nAnswer 2 : Ubiquitous Sensor Network\nAnswer 3 : 유비쿼터스 센서 네트워크"
  },
  {
    "question": "Question 964.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 주변 상황에 맞추어 스스로 망을 구성하는 네트워크.\n② ○○○의 목적은 통신망 커버리지 및 전송 용량 확장의 경제성 문제를 해결하고, 망의 운영과 관리의 효율성을 높이는 것임.",
    "answer": "Answer 1 : SON\nAnswer 2 : Self Organizing Network\nAnswer 3 : 자동 구성 네트워크"
  },
  {
    "question": "Question 965.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 재난 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트(Mobile Host)만을 이용하여 구성한 네트워크.\n② 망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합함.",
    "answer": "Answer 1 : 애드 혹 네트워크\nAnswer 2 : Ad-hoc Network"
  },
  {
    "question": "Question 966.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 네트워크에서 하나의 물리적인 코어 네트워크 인프라(Infrastructure)를 독립된 다수의 가상 네트워크로 분리하여 각각의 네트워크를 통해 다양한 고객 맞춤형 서비스를 제공하는 것을 목적으로 하는 네트워크 기술.\n② #FPP를 포함한 여러 글로벌 이동통신 표준화 단체가 선정한 5G(IMT-2020)의 핵심기술 중 하나임.",
    "answer": "Answer 1 : 네트워크 슬라이싱\nAnswer 2 : Network Slicing"
  },
  {
    "question": "Question 967.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n일반 블루투스와 동일한 2。4GHz 주파수 대역을 사용하지만 연결되지 않은 대기 상태에서는 절전모드를 유지하는 기술.",
    "answer": "Answer 1 : 저전력 블루투스 기술\nAnswer 2 : BLE\nAnswer 3 : Bluetooth Low Energy"
  },
  {
    "question": "Question 968.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n스마트 시티, 스마트 스테이션 등 4차 산업혁명 시대를 맞아 새로운 변화에 따라 급격하게 증가하는 데이터 트래픽을 효과적으로 수용하기 위해 시행되는 과학기술정보통신부 주관 사업임.",
    "answer": "Answer 1 : 지능형 초연결망"
  },
  {
    "question": "Question 969.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 광섬유를 이용한 통신기술의 하나로, 파장이 서로 다른 복수의 신호를 보냄으로써 여러 대의 단말기가 동시에 통신 회선을 사용할 수 있도록 하는 것.\n② 파장이 다른 광선끼리는 서로 간섭을 일으키지 않는 성질을 이용한 기술임.",
    "answer": "Answer 1 : 파장 분할 다중화\nAnswer 2 : WDM\nAnswer 3 : Wavelength Division Multiplexing"
  },
  {
    "question": "Question 970.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 데이터 센터의 모든 자원을 가상화하여 인력의 개입없이 소프트웨어 조작만으로 관리 및 제어되는 데이터 센터를 의미함.\n② 컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의함.\n③ 다양한 소프트웨어 정의 기술이 사용됨.",
    "answer": "Answer 1 : 소프트웨어 정의 데이터 센터\nAnswer 2 : SDDC\nAnswer 3 : Software Defined Data Center"
  },
  {
    "question": "Question 971.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① Linked Data와 Open Data의 합성어로, 누구나 사용할 수 있도록 웹상에 공개된 연계 데이터를 의미함.\n② 웹상에 존재하는 데이터를 개별 URI(인터넷 식별자)로 식별하고, 각 URI에 링크 정보를 부여함으로써 상호 연결된 웹을 지향하는 모형임.",
    "answer": "Answer 1 : 개방형 링크드 데이터\nAnswer 2 : LOD\nAnswer 3 : Linked Open Data"
  },
  {
    "question": "Question 972.\n다음은 네트워크 관련 신기술 중 하나에 대한 설명이다.\n① 한 번의 로그인으로 개인이 가입한 모든 사이트를 이용할 수 있게 해주는 시스템.\n② 개인정보를 각 사이트마다 일일이 기록해야 하던 불편함을 해소할 수 있음.\n③ 기업에서는 회원에 대한 통합관리가 가능해 마케팅을 극대화시킬 수 있음.",
    "answer": "Answer 1 : SSO\nAnswer 2 : Single Sign On"
  },
  {
    "question": "Question 973.\n두 대 이상의 컴퓨터를 전화선이나 케이블 등으로 연결하여 자원을 공유하는 것은?\n다른 컴퓨터의 데이터, 프로그램, 주변장치, 인터넷 등을 공유하기 위해 사용한다.\n○○○ 설치 구조는 장치들의 물리적 위치에 따라서 성형, 링형, 버스형, 계층형, 망형으로 나누어진다.\n사이트들이 분포되어 있는 지리적 범위에 따라 LAN과 WAN으로 분류된다.",
    "answer": "Answer 1 : 네트워크\nAnswer 2 : Network"
  },
  {
    "question": "Question 974.\n중앙에 중앙 컴퓨터가 있고, 이를 중심으로 단말장치들이 연결되는 중앙 집중식의 네트워크 구성 형태는?\n포인트 투 포인트(Point-to-Point) 방식으로 회선을 연결한다.\n단말장치의 추가와 제거가 쉽다.\n하나의 단말장치가 고장나더라도 다른 단말장치에는 영향을 주지 않지만, 중앙 커퓨터가 고장나면 전체 통신망의 기능이 정지된다.",
    "answer": "Answer 1 : 성형\nAnswer 2 : 중앙 집중형\nAnswer 3 : Star"
  },
  {
    "question": "Question 975.\n컴퓨터와 단말장치들을 서로 이웃하는 것끼리 연결시킨 포인트 투 포인트(Point-to-Point) 방식의 구성 형태는?\n단말장치의 추가/제거 및 기밀 보호가 어렵다.\n각 단말장치에서 전송 지연이 발생할 수 있다.\n중계기의 수가 많아진다.\n데이터는 단방향 또는 양방향으로 전송할 수 있다.",
    "answer": "Answer 1 : 링형\nAnswer 2 : 루프형\nAnswer 3 : Ring"
  },
  {
    "question": "Question 976.\n한 개의 통신 회선에 여러 대의 단말장치가 연결되어 있는 형태는?\n단말장치의 추가와 제거가 용이하다.\n단말장치가 고장나더라도 통신망 전체에 영향을 주지 않기 때문에 신뢰성을 높일 수 있다.\n기밀 보장이 어렵다.\n통신 회선의 길이에 제한이 있다.",
    "answer": "Answer 1 : 버스형\nAnswer 2 : Bus"
  },
  {
    "question": "Question 977.\n중앙 컴퓨터와 일정 지역의 단말장치까지는 하나의 통신 회선으로 연결시키고, 이웃하는 단말장치는 일정 지역 내에 설치된 중간 단말장치로부터 다시 연결시키는 형태는?\n분산 처리 시스템을 구성하는 방식이다.",
    "answer": "Answer 1 : 계층형\nAnswer 2 : 분산형\nAnswer 3 : Tree"
  },
  {
    "question": "Question 978.\n모든 지점의 컴퓨터와 단말장치를 서로 연결한 형태로, 노드의 연결성이 높은 것은?\n많은 단말장치로부터 많은 양의 통신을 필요로 하는 경우에 유리하다.\n통신 회선의 총 경로가 가장 길다.\n통신 회선 장애 시 다른 경로를 통하여 데이터를 전솔할 수 있다.\n모든 노드를 망형으로 연결하려면 노드의 수가 n개일 때, n(n-1)/2개의 회선이 필요하고 노드당 n-1개의 포트가 필요하다.",
    "answer": "Answer 1 : 망형\nAnswer 2 : Mesh"
  },
  {
    "question": "Question 979.\n다음은 네트워크의 분류 중 하나에 대한 설명이다.\n① 회사, 학교, 연구소 등에서 비교적 가까운 거리에 있는 컴퓨터, 프린터, 저장장치 등과 같은 자원을 연결하여 구성함.\n② 주로 자원 공유를 목적으로 사용함.\n③ 사이트 간의 거리가 짧아 데이터의 전송 속도가 빠르고, 에러 발생율이 낮음.\n④주로 버스형이나 링형 구조를 사용함.",
    "answer": "Answer 1 : 근거리 통신망\nAnswer 2 : LAN\nAnswer 3 : Local Area Network"
  },
  {
    "question": "Question 980.\n다음은 네트워크의 분류 중 하나에 대한 설명이다.\n① 국가와 국가 혹은 대륙과 대륙 등과 같이 멀리 떨어진 사이트들을 연결하여 구성함.\n② 사이트 간의 거리가 멀기 때문에 통신 속도가 느리고, 에러 발생률이 높음.\n③ 일정한 지역에 있는 사이트들을 근거리 통신망으로 연결한 후 각 근거리 통신망을 연결하는 방식을 사용함.",
    "answer": "Answer 1 : 광대역 통신망\nAnswer 2 : WAN\nAnswer 3 : Wide Area Network"
  },
  {
    "question": "Question 981.\n한 개의 정식 IP 주소에 대량의 가상 사설 IP 주소를 할당 및 연결하는 기능은?\n한 개의 IP 주소를 사용해서 외부에 접속할 수 있는 노드는 어느 시점에서 한 개로 제한되는 문제가 있지만 IP 마스커레이드(Maquerade)를 이용하여 해결할 수 있다.",
    "answer": "Answer 1 : NAT\nAnswer 2 : Network Address Translation\nAnswer 3 : 네트워크 주소 변환"
  },
  {
    "question": "Question 982.\n다음은 개인정보 보호 관련 법령 중 하나에 대한 설명이다.\n개인정보의 처리 및 보호에 관한 사항을 정함으로써 개인의 자유와 권리를 보호함.",
    "answer": "Answer 1 : 개인정보 보호법"
  },
  {
    "question": "Question 983.\n다음은 개인정보 보호 관련 법령 중 하나에 대한 설명이다.\n정보통신망의 이용 촉진 및 정보 통신 서비스를 이용하는 이용자들의 개인정보를 보호함.",
    "answer": "Answer 1 : 정보통신망 이용촉진 및 정보보호 등에 관한 법률"
  },
  {
    "question": "Question 984.\n다음은 개인정보 보호 관련 법령 중 하나에 대한 설명이다.\n개인 신용정보의 효율적 이용과 체계적인 관리를 통해 정보의 오남용을 방지함.",
    "answer": "Answer 1 : 신용정보의 이용 및 보호에 관한 법률"
  },
  {
    "question": "Question 985.\n다음은 개인정보 보호 관련 법령 중 하나에 대한 설명이다.\n개인 위치정보의 안전한 이용 환경을 조성하여 정보의 유출이나 오남용을 방지함.",
    "answer": "Answer 1 : 위치정보의 보호 및 이용 등에 관한 법률"
  },
  {
    "question": "Question 986.\n다음은 개인정보 보호 관련 법령 중 하나에 대한 설명이다.\n개인정보의 처리에 관한 기준, 개인정보 침해의 유형 및 예방조치 등에 관한 세부사항을 규정함.",
    "answer": "Answer 1 : 표준 개인정보 보호 지침"
  },
  {
    "question": "Question 987.\n다음은 개인정보 보호 관련 법령 중 하나에 대한 설명이다.\n개인정보 처리자가 개인정보를 처리하는데 있어 개인정보가 분실, 도난, 유출, 위조, 변조, 훼손되지 않도록 안전성 확보에 필요한 기술적, 관리적, 물리적 안전조치에 관한 최소한의 기준을 규정함.",
    "answer": "Answer 1 : 개인정보의 안전성 확보 조치 기준"
  },
  {
    "question": "Question 988.\n다음은 개인정보 보호 관련 법령 중 하나에 대한 설명이다.\n개인정보 영향평가를 위한 평가기관의 지정, 영향평가의 절차 등에 관한 세부기준을 규정함.",
    "answer": "Answer 1 : 개인정보 영향평가에 관한 고시"
  },
  {
    "question": "Question 989.\n다음은 IT 기술 관련 규정 중 하나에 대한 설명이다.\nRFID 시스템의 이용자들의 프라이버시를 보호하고 안전한 RFID 이용 환경을 조성하기 위한 가이드라인.",
    "answer": "Answer 1 : RFID 프라이버시 보호 가이드라인"
  },
  {
    "question": "Question 990.\n다음은 IT 기술 관련 규정 중 하나에 대한 설명이다.\n개인 위치정보의 유출 및 오남용을 방지하기 위한 법률.",
    "answer": "Answer 1 : 위치정보의 보호 및 이용 등에 관한 법률"
  },
  {
    "question": "Question 991.\n다음은 IT 기술 관련 규정 중 하나에 대한 설명이다.\n개인 위치정보의 누출, 변조, 훼손 등을 방지하기 위해 위치정보 사업자 및 위치기반 서비스 사업자가 준수해야 하는 관리적, 기술적 보호조치의 구체적인 기준.",
    "answer": "Answer 1 : 위치정보의 관리적, 기술적 보호조치 권고 해설서"
  },
  {
    "question": "Question 992.\n다음은 IT 기술 관련 규정 중 하나에 대한 설명이다.\n개인 바이오정보의 보호와 안전한 활용을 위한 원칙 및 조치사항.",
    "answer": "Answer 1 : 바이오정보 보호 가이드라인"
  },
  {
    "question": "Question 993.\n다음은 IT 기술 관련 규정 중 하나에 대한 설명이다.\n뉴미디어 서비스 이용 및 제공 시 개인 정보의 침해사고를 예방하기 위한 준수사항.",
    "answer": "Answer 1 : 뉴미디어 서비스 개인정보 보호 가이드라인"
  },
  {
    "question": "Question 994.\n다음은 IT 기술 관련 규정 중 하나에 대한 설명이다.\n① 정보 자산을 안전하게 보호하기 위한 보호 절차와 대책으로, 조직에 맞는 정보보호 정책을 수립하고, 위험에 상시 대응하는 여러 보안 대책을 통합하여 관리한다.\n② 한국인터넷진흥원(KISA)에서는 공공 기간과 민간 기업을 대상으로 정보 보호 관리 체계를 평가하고 인증하는 업무를 수행하고 있다.",
    "answer": "Answer 1 : 정보보호 관리 체계\nAnswer 2 : ISMS\nAnswer 3 : Information Security Management System"
  },
  {
    "question": "Question 995.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n긴 시간동안 안정적인 서비스 운영을 위해 장애 발생 시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메커니즘.",
    "answer": "Answer 1 : 고가용성\nAnswer 2 : HA\nAnswer 3 : High Availability"
  },
  {
    "question": "Question 996.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n① 대상을 평면에 출력하는 것이 아니라 손으로 만질 수 있는 실제 물체로 만들어내는 것.\n② 아주 얇은 두께로 한층한층 쌓아 하나의 형태를 만들어내는 기술을 이용함.",
    "answer": "Answer 1 : 3D Printing\nAnswer 2 : Three Dimension Printing"
  },
  {
    "question": "Question 997.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n특정 시간이나 환경 조건이 갖추어지면 스스로 형태를 변화시키거나 제조되는 자가 조립(Self-Assembly) 기술이 적용된 제품을 3D Printing 하는 기술.",
    "answer": "Answer 1 : 4D Printing\nAnswer 2 : Fourth Dimension Printing"
  },
  {
    "question": "Question 998.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n① 여러 개의 하드디스크로 디스크 배열을 구성하여 파일을 구성하고 있는 데이터 블록들을 서로 다른 디스크들에 분산 저장할 경우, 그 블록들을 여러 디스크에서 동시에 읽거나 쓸 수 있으므로 디스크의 속도가 매우 향상되는데, 이 기술을 ○○○라고 함.\n주요 ○○○ 레벨.\n- ○○○ 0 : 스트라이핑을 적용한 방식으로, 디스크의 개수만큼 읽기/쓰기 성능이 향상됨.\n- ○○○ 1 : 미러링을 적용한 방식으로, 디스크 손상을 대비할 수 있지만, 데이터를 동시에 기록하므로 쓰기 성능이 저하될 수 있음.\n- ○○○ 5 : 스트라이핑을 적용한 디스크에 오류 검출을 위한 패리티를 저장하는 방식으로, 스트라이핑으로 인한 읽기 성능은 향상되지만, 쓰기 성능은 패리티의 연산과 저장으로 인해 저하될 수 있음.\n- ○○○ 6 : 이중 패리티를 추가하여 안정성을 높인 방식으로, 금융업과 같이 데이터 손상이 치명적인 결과를 불러일으키는 산업에서 주로 사용함.",
    "answer": "Answer 1 : RAID\nAnswer 2 : Redundant Array of Inexpensive Disk\nAnswer 3 : Redundant Array of Independent Disk"
  },
  {
    "question": "Question 999.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n① 차세대 고화질 모니터의 해상도를 지칭하는 용어.\n② 가로 픽셀 수가 3840이고, 세로 픽셀 수가 2160인 영상의 해상도를 말하는데, 이는 Full HDTV(1920X1080)의 가로·세로 2배, 총 4배에 해당하는 초고화질의 영상임.",
    "answer": "Answer 1 : 4K 해상도"
  },
  {
    "question": "Question 1000.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\nN개의 서로 다른 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스.",
    "answer": "Answer 1 : 앤 스크린\nAnswer 2 : N-Screen"
  },
  {
    "question": "Question 1001.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n① TV 방송 시청 시 방송 내용을 공유하며 추가적인 기능을 수행할 수 있는 스마트폰, 태블릿PC 등을 의미함.\n② 앤 스크린(N Screen)의 한 종류로, 세컨드 스크린(Second Screen)이라고도 불림.",
    "answer": "Answer 1 : 컴패니언 스크린\nAnswer 2 : Companion Screen"
  },
  {
    "question": "Question 1002.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n① 하드디스크나 주변장치 없이 기본적인 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터.\n② 서버 기반 컴퓨팅과 관계가 깊음.",
    "answer": "Answer 1 : 신 클라이언트 PC\nAnswer 2 : Thin Client PC"
  },
  {
    "question": "Question 1003.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n폰(Phone)과 태블릿(Tablet)의 합성어로, 태블릿 기능을 포함한 5인치 이상의 대화면 스마트폰.",
    "answer": "Answer 1 : 패블릿\nAnswer 2 : Phablet"
  },
  {
    "question": "Question 1004.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n① 범용 인터페이스 규격인 USB(Universal Serial Bus)의 표준 중 하나임.\n② 기존 A형에 비하여 크기가 작고, 24핀으로 위아래의 구분이 없어 어느 방향으로든 연결이 가능함.",
    "answer": "Answer 1 : C형 유에스비\nAnswer 2 : Universal Serial Bus Type-C\nAnswer 3 : USB Type-C, USB-C"
  },
  {
    "question": "Question 1005.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n초정밀 반도체 제조 기술을 바탕으로 센서, 액추에이터(Actuator) 등 기계 구조를 다양한 기술로 미세 가공하여 전기기계적 동작을 할 수 있도록 한 초미세 장치.",
    "answer": "Answer 1 : 멤스\nAnswer 2 : MEMS\nAnswer 3 : Micro-Electro Mechanical Systems"
  },
  {
    "question": "Question 1006.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n하나의 프로세서(Processer) 내에 일반 애플리케이션을 처리하는 일반 구역(Narmal World)과 보안이 필요한 애플리케이션을 처리하는 보안 구역(Secure World)으로 분할하여 관리하는 하드웨어 기반의 보안 기술.",
    "answer": "Answer 1 : 트러스트존 기술\nAnswer 2 : TrustZone Technology"
  },
  {
    "question": "Question 1007.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n① 한 번의 기록만으로 자료를 영구 보관할 수 있는 광 저장장치.\n② 디스크 표면의 무기물층에 레이저를 이용해 자료를 조각해서 기록함.\n③ 시간이 지나도 변하지 않는 금속 활자처럼 빛, 열, 습기 등의 외부 요인에 영향을 받지 않음.",
    "answer": "Answer 1 : 엠디스크\nAnswer 2 : M-DISC\nAnswer 3 : Millennial DISC"
  },
  {
    "question": "Question 1008.\n다음은 HW 관련 신기술 중 하나에 대한 설명이다.\n① 메모리(Memory)와 레지스터(Resister)의 합성어로, 전류의 방향과 양 등 기존의 경험을 모두 기억하는 특별한 소자.\n② 레지스터(Resister), 커패시터(Capacitor), 인덕터(Inductor)에 이어 네 번째 전자회로 구성 요소라 불리고 있음.",
    "answer": "Answer 1 : 멤리스터\nAnswer 2 : Memristor"
  },
  {
    "question": "Question 1009.\n기존의 운영체제(OS)에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 이식하여 외부의 침입으로부터 시스템 자원을 보호하는 운영체제를 의미하는 것은?\n보안 커널은 보안 기능을 갖춘 커널을 의미하며, TCB를 기반으로 참조 모니터의 개념을 구현하고 집행한다.\n보호 방법을 구현하기 복잡한 것부터 차례로 분류하면 다음과 같다.\n- 암호적 분리(Cryptographic Separation) : 내부 정보를 암호화하는 방법.\n- 논리적 분리(Logical Separation) : 프로세스의 논리적 구역을 지정하여 구역을 벗어나는 행위를 제한하는 방법.\n- 시간적 분리(Temporal Separation) : 동일 시간에 하나의 프로세스만 수행되도록 하여 동시 실행으로 발생하는 보안 취약점을 제거하는 방법.\n- 물리적 분리(Physical Separation) : 사용자별로 특정 장비만 사용하도록 제한하는 방법.\n○○○의 보안 기능.\n- 식별 및 인증.\n- 임의적/강제적 접근통제.\n- 객체 재사용 보호.\n- 완전한 조정.\n- 신뢰 경로.\n- 감사 및 감사기록 축소 등.",
    "answer": "Answer 1 : Secure OS"
  },
  {
    "question": "Question 1010.\n보호 대상 객체에 대한 접근통제를 수행하는 추상머신은?\n이것을 실제로 구현한 것이 보안 커널이다.\n보안 커널 데이터베이스(SKDB; Security Kernel Database)를 참조하여 객체에 대한 접근 허가 여부를 결정한다.\n○○○와 보안 커널의 특징.\n- 격리성(Isolation) : 부정 조작이 불가능해야 함.\n- 검증가능성(Verifiability) : 적절히 구현되었다는 것을 확인할 수 있어야 함.\n- 완전성(Completeness) : 우회가 불가능해야 함.",
    "answer": "Answer 1 : 참조 모니터\nAnswer 2 : Reference Monitor"
  },
  {
    "question": "Question 1011.\n다음은 DB 관련 신기술 중 하나에 대한 설명이다.\n① 기존의 관리 방법이나 분석 체계로는 처리하기 어려운 막대한 양의 정형 또는 비정형 데이터 집합.\n② ○○○가 주목받고 있는 이유는 기업이나 정부, 포털 등이 ○○○를 효과적으로 분석함으로써 미래를 예측해 최적의 대응 방안을 찾고, 이를 수익으로 연결하여 새로운 가치를 창출하기 때문임.",
    "answer": "Answer 1 : 빅데이터\nAnswer 2 : Big Data"
  },
  {
    "question": "Question 1012.\n다음은 DB 관련 신기술 중 하나에 대한 설명이다.\n다양한 채널에서 소비자와 상호 작용을 통해 생성된 것으로, 기업 마케팅에 있어 효율적이고 다양한 데이터이며, 이전에 사용하지 않거나 알지 못했던 새로운 데이터나 기존 데이터에 새로운 가치가 더해진 데이터.",
    "answer": "Answer 1 : 브로드 데이터\nAnswer 2 : Broad Data"
  },
  {
    "question": "Question 1013.\n다음은 DB 관련 신기술 중 하나에 대한 설명이다.\n① 일련의 데이터를 정의하고 설명해 주는 데이터.\n② 컴퓨터에서는 데이터 가전의 내용, 스키마 등을 의미함.\n③ HTML 문서에서는 메타 태크 내의 내용이 ○○○임.",
    "answer": "Answer 1 : 메타 데이터\nAnswer 2 : Meta Data"
  },
  {
    "question": "Question 1014.\n다음은 DB 관련 신기술 중 하나에 대한 설명이다.\n① 디지털 정보 자원을 장기적으로 보존하기 위한 작업.\n② 아날로그 콘텐츠는 디지털로 변환한 후 압축해서 저장하고, 디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화하는 작업임.",
    "answer": "Answer 1 : 디지털 아카이빙\nAnswer 2 : Digital Archiving"
  },
  {
    "question": "Question 1015.\n다음은 DB 관련 신기술 중 하나에 대한 설명이다.\n① 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼.\n② 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크.\n③ 구글, 야후 등에 적용되고 있음.",
    "answer": "Answer 1 : 하둡\nAnswer 2 : Hadoop"
  },
  {
    "question": "Question 1016.\n다음은 DB 관련 신기술 중 하나에 대한 설명이다.\n① 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델.\n② 흩어져 있는 데이터를 연관성 있는 데이터 분류로 묶는 Map 작업을 수행한 후 중복 데이터를 제거하고 원하는 데이터를 추출하는 Reduce 작업을 수행함.\n③ Google에 의해 고안되었으며, 대표적인 대용량 데이터 처리를 위한 병렬 처리 기법으로 많이 사용되고 있음.",
    "answer": "Answer 1 : 맵리듀스\nAnswer 2 : MapReduce"
  },
  {
    "question": "Question 1017.\n다음은 DB 관련 신기술 중 하나에 대한 설명이다.\n오픈 소스 기반 분산 컴퓨팅 플랫폼인 아파치 하둡(Apache Hadoop) 기반의 분산 데이터 웨어하우스 프로젝트.",
    "answer": "Answer 1 : 타조\nAnswer 2 : Tajo"
  },
  {
    "question": "Question 1018.\n다음은 DB 관련 신기술 중 하나에 대한 설명이다.\n데이터를 삭제하는 것이 아니라 압축하고, 중복된 정보는 중복을 배제하고, 새로운 기준에 따라 나누어 저장하는 작업.",
    "answer": "Answer 1 : 데이터 다이어트\nAnswer 2 : Data Diet"
  },
  {
    "question": "Question 1019.\n다음은 DB 관련 신기술 중 하나에 대한 설명이다.\n대량의 데이터를 분석하여 데이터에 내재된 변수 사이의 상호 관계를 규명하여 일정한 패턴을 찾아내는 기법.",
    "answer": "Answer 1 : 데이터 마이닝\nAnswer 2 : Data Mining"
  },
  {
    "question": "Question 1020.\n다음은 DB 관련 신기술 중 하나에 대한 설명이다.\n① 다차원으로 이루어진 데이터로부터 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식.\n② ○○○ 연산 : Roll-up, Drill-down, Drill-through, Drill-across, Pivoting, Slicing, Dicing.",
    "answer": "Answer 1 : OLAP\nAnswer 2 : Online Analytical Processing"
  },
  {
    "question": "Question 1021.\n트랜잭션들을 수행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업은?",
    "answer": "Answer 1 : 회복\nAnswer 2 : Recovery"
  },
  {
    "question": "Question 1022.\n다음은 회복 기법의 네 가지 기법 중 하나에 대한 설명이다.\n① 트랜잭션이 성공적으로 완료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 방법.\n② 트랜잭션이 수행되는 동안 갱신된 내용은 일단 Log에 보관됨.\n③ 트랜잭션의 부분 완료 시점에 Log에 보관한 갱신 내용을 실제 데이터베이스에 기록함.\n④Redo 작업만 가능함.",
    "answer": "Answer 1 : 연기 갱신 기법\nAnswer 2 : Deferred Update"
  },
  {
    "question": "Question 1023.\n다음은 회복 기법의 네 가지 기법 중 하나에 대한 설명이다.\n① 트랜잭션이 데이터를 갱신하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 방법.\n② 장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들은 Log에 보관시킴.\n③ Redo와 Undo 모두 사용 가능함.",
    "answer": "Answer 1 : 즉각 갱신 기법\nAnswer 2 : Immediate Update"
  },
  {
    "question": "Question 1024.\n다음은 회복 기법의 네 가지 기법 중 하나에 대한 설명이다.\n갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본인 그림자 페이지를 별도 보관해 놓고, 실제 페이지를 대상으로 갱신 작업을 수행하다가 장애가 발생하여 트랜잭션 작업을 Rollback 시킬 때는 갱신 이후의 실제 페이지 부분을 그림자 페이지로 대체하여 회복시키는 기법.",
    "answer": "Answer 1 : 그림자 페이지 대체 기법\nAnswer 2 : Shadow Paging"
  },
  {
    "question": "Question 1025.\n다음은 회복 기법의 네 가지 기법 중 하나에 대한 설명이다.\n트랜잭션 실행 중 특정 단계에서 재실행할 수 있도록 갱신 내용이나 시스템에 대한 상황 등에 관한 정보와 함께 검사점을 로그에 보관해 두고, 장애 발생 시 트랜잭션 전체를 철회하지 않고 검사점부터 회복 작업을 수행하여 회복시간을 절약하도록 하는 기법.",
    "answer": "Answer 1 : 검사점 기법\nAnswer 2 : Check Point"
  },
  {
    "question": "Question 1026.\n다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 것은?\n○○○ 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 갱신 분실, 비완료 의존성, 모순성, 연쇄 복귀 등의 문제가 발생한다.",
    "answer": "Answer 1 : 병행제어\nAnswer 2 : Concurrency Control"
  },
  {
    "question": "Question 1027.\n다음은 병행제어 기법의 네 가지 기법 중 하나에 대한 설명이다.\n① 트랜잭션들이 어떤 ○○○ 단위를 액세서하기 전에 Lock(잠금)을 요청해서 Lock이 허락되어야만 그 ○○○ 단위를 액세스할 수 있도록 하는 기법.\n② 주요 데이터의 액세스를 상호 배타적으로 함.",
    "answer": "Answer 1 : 로킹\nAnswer 2 : Locking"
  },
  {
    "question": "Question 1028.\n다음은 병행제어 기법의 네 가지 기법 중 하나에 대한 설명이다.\n① 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기전에 시간표(Time Stamp)를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법.\n② 직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 미리 선택하는 기법들 중에서 가장 보편적인 방법임.",
    "answer": "Answer 1 : 타임 스탬프 순서\nAnswer 2 : Time Stamp Ordering"
  },
  {
    "question": "Question 1029.\n다음은 병행제어 기법의 네 가지 기법 중 하나에 대한 설명이다.\n병행수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read Only) 트랜잭션일 경우, 트랜잭션 간의 충돌률이 매우 낮아서 병행제어 기법을 사용하지 않고 실행되어도 이 중의 많은 트랜잭션은 시스템의 상태를 일관성 있게 유지한다는 점을 이용한 기법.",
    "answer": "Answer 1 : 최적 병행수행\nAnswer 2 : 검증 기법\nAnswer 3 : 확인 기법, 낙관적 기법"
  },
  {
    "question": "Question 1030.\n다음은 병행제어 기법의 네 가지 기법 중 하나에 대한 설명이다.\n① 타임 스탬프의 개념을 이용한 기법.\n② 다중 버전 타임 스탬프 기법이라고도 함.\n③ 타임 스패트 기법은 트랜잭션 및 데이터들이 이용될 떄의 시간을 시간표로 관리하지만, ○○○은 갱신될 때마다의 버전을 부여하여 관리함.",
    "answer": "Answer 1 : 다중 버전 기법"
  },
  {
    "question": "Question 1031.\n병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미하는 것은?\n데이터베이스, 파일, 레코드, 필드 등이 ○○○가 될 수 있다.\n○○○가 크면 로크 수가 작가 관리하기 쉽지만 병행성 수준이 낮아진다.\n○○○가 작으면 로크 수가 많아 관리하기 복잡해 오버헤드가 증가하지만 병행성 수준이 높아진다.",
    "answer": "Answer 1 : 로킹 단위\nAnswer 2 : Locking Granularity"
  },
  {
    "question": "Question 1032.\n상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 의미하는 것은?",
    "answer": "Answer 1 : 교착 상태\nAnswer 2 : Dead Lock"
  },
  {
    "question": "Question 1033.\n다음은 교착상태 발생의 필요 충분 조건의 네 가지 중 하나에 대한 설명이다.\n한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함.",
    "answer": "Answer 1 : 상호 배제\nAnswer 2 : Mutual Exclusion"
  },
  {
    "question": "Question 1034.\n다음은 교착상태 발생의 필요 충분 조건의 네 가지 중 하나에 대한 설명이다.\n최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함.",
    "answer": "Answer 1 : 점유와 대기\nAnswer 2 : Hold and Wait"
  },
  {
    "question": "Question 1035.\n다음은 교착상태 발생의 필요 충분 조건의 네 가지 중 하나에 대한 설명이다.\n다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 함.",
    "answer": "Answer 1 : 비선점\nAnswer 2 : Non-preemption"
  },
  {
    "question": "Question 1036.\n다음은 교착상태 발생의 필요 충분 조건의 네 가지 중 하나에 대한 설명이다.\n공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함.",
    "answer": "Answer 1 : 환형 대기\nAnswer 2 : Circular Wait"
  },
  {
    "question": "Question 1037.\n다음은 교착상태의 해결 방법의 네 가지 중 하나에 대한 설명이다.\n① 교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법.\n② 교착상태 발생의 네 가지 조건 중에서 어느 하나를 제거함으로써 수행됨.\n③ 자원의 낭비가 가장 심한 기법임.",
    "answer": "Answer 1 : 예방 기법\nAnswer 2 : Prevention"
  },
  {
    "question": "Question 1038.\n다음은 교착상태의 해결 방법의 네 가지 중 하나에 대한 설명이다.\n① 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법.\n② 주로 은행원 알고리즘(Banker's Algorithm)이 사용됨.\n③ 은행원 알고리즘(Banker's Algorithm) : E。 J。 Dijkstra가 제안한 것으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법.",
    "answer": "Answer 1 : 회피 기법\nAnswer 2 : Avoidance"
  },
  {
    "question": "Question 1039.\n다음은 교착상태의 해결 방법의 네 가지 중 하나에 대한 설명이다.\n① 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것.\n② 교착상태 발견 알고리즘과 자원 할당 그래프 등을 사용할 수 있음.",
    "answer": "Answer 1 : 발견 기법\nAnswer 2 : Detection"
  },
  {
    "question": "Question 1040.\n다음은 교착상태의 해결 방법의 네 가지 중 하나에 대한 설명이다.\n교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것.",
    "answer": "Answer 1 : 회복 기법\nAnswer 2 : Recovery"
  },
  {
    "question": "Question 1041.\n모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것은?\n개발자가 아니라 사용자를 중심으로 진행한다.\n소스 코드는 향후 관리를 고려하여 모듈화하여 패키징한다.",
    "answer": "Answer 1 : 소프트웨어 패키징"
  },
  {
    "question": "Question 1042.\n소프트웨어 개발 과정에서 정리된 릴리즈 정보를 최종 사용자인 고객과 공유하기 위한 문서는?\n○○○를 통해 테스트 진행 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부를 확인할 수 있다.\n소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유할 수 있다.",
    "answer": "Answer 1 : 릴리즈 노트\nAnswer 2 : Release Note"
  },
  {
    "question": "Question 1043.\n소설, 시, 논문, 강연, 연술, 음악, 연극, 무용, 회화, 서예, 건추물, 사진, 영상, 지도, 도표, 컴퓨터 프로그램 저작물 등에 대하여 창작자가 가지는 배타적 독점적 권리로, 타인의 침해를 받지 않을 고유한 권한은?\n컴퓨터 프로그램들과 같이 복제하기 쉬운 저작물에 대해 불법 복제 및 배포 등을 막기 위한 기술적인 방법을 통칭해 ○○○ 보호 기술이라고 한다.",
    "answer": "Answer 1 : 저작권"
  },
  {
    "question": "Question 1044.\n저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술은?\n원본 콘텐츠가 아날로그인 경우에는 디지털로 변환한 후 패키저(Packager)로 DRM 패키징을 수행한다.\n패키징을 수행하면 콘텐츠에는 암호화된 저작권자의 전자서명이 포함되고 저작권자가 설정한 라이선스 정보가 클리어링 하우스(Clearing House)에 등록된다.",
    "answer": "Answer 1 : 디지털 저작권 관리\nAnswer 2 : DRM\nAnswer 3 : Digital Right Management"
  },
  {
    "question": "Question 1045.\n개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 피료한 내용을 기록한 설명서와 안내서는?\n사용자 기준으로 작성한다.\n설치 시작부터 완료할 때까지의 전 과정을 빠짐업싱 순서대로 설명한다.\n설치 과정에서 표시될 수 있는 오류 메시지 및 예외 상황에 관한 내용을 별도로 분류하여 설명한다.",
    "answer": "Answer 1 : 소프트웨어 설치 매뉴얼"
  },
  {
    "question": "Question 1046.\n사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 문서로 기록한 설명서와 안내서는?\n사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반사항이 모두 포함되도록 작성한다.\n소프트웨어 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 매뉴얼의 버전을 관리한다.\n개별적으로 동작이 가능한 컴포넌트 단위로 매뉴얼을 작성한다.\n컴포넌트 명세서와 컴포넌트 구현 설계서를 토대로 작성한다.",
    "answer": "Answer 1 : 소프트웨어 사용자 매뉴얼"
  },
  {
    "question": "Question 1047.\n개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동은?\n소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행된다.\n소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다.\n대표적인 ○○○ 도구에는 Git, SVN, CVS 등이 있다.",
    "answer": "Answer 1 : 형상 관리\nAnswer 2 : SCM\nAnswer 3 : Software Configuration Management"
  },
  {
    "question": "Question 1048.\n다음은 형상 관리 기능의 다섯 가지 기능 중 하나에 대한 설명이다.\n형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업.",
    "answer": "Answer 1 : 형상 식별"
  },
  {
    "question": "Question 1049.\n다음은 형상 관리 기능의 다섯 가지 기능 중 하나에 대한 설명이다.\n소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구(Tool)를 결합시키는 작업.",
    "answer": "Answer 1 : 버전 제어"
  },
  {
    "question": "Question 1050.\n다음은 형상 관리 기능의 다섯 가지 기능 중 하나에 대한 설명이다.\n식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정하는 작업.",
    "answer": "Answer 1 : 형상 통제"
  },
  {
    "question": "Question 1051.\n다음은 형상 관리 기능의 다섯 가지 기능 중 하나에 대한 설명이다.\n기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업.",
    "answer": "Answer 1 : 형상 감사"
  },
  {
    "question": "Question 1052.\n다음은 형상 관리 기능의 다섯 가지 기능 중 하나에 대한 설명이다.\n형상의 식별, 통제, 감사 작업의 결과를 기록·관리하고 보고서를 작성하는 작업.",
    "answer": "Answer 1 : 형상 기록"
  },
  {
    "question": "Question 1053.\n다음은 소프트웨어의 버전 등록 관련 주요 기능 중 하나에 대한 설명이다.\n최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳.",
    "answer": "Answer 1 : 저장소\nAnswer 2 : Repository"
  },
  {
    "question": "Question 1054.\n다음은 소프트웨어의 버전 등록 관련 주요 기능 중 하나에 대한 설명이다.\n버전 관리가 되고 있지 않은 아무것도 없는 저장소(Repository)에 처음으로 파일을 복사함.",
    "answer": "Answer 1 : 가져오기\nAnswer 2 : Import"
  },
  {
    "question": "Question 1055.\n다음은 소프트웨어의 버전 등록 관련 주요 기능 중 하나에 대한 설명이다.\n① 프로그램을 수정하기 위해 저장소(Repository)에서 파일을 받아옴.\n② 소스 파일과 함께 버전 관리를 위한 파일들도 받아옴.",
    "answer": "Answer 1 : 체크아웃\nAnswer 2 : Check-Out"
  },
  {
    "question": "Question 1056.\n다음은 소프트웨어의 버전 등록 관련 주요 기능 중 하나에 대한 설명이다.\n체크아웃한 파일의 수정을 완료한 후 저장소(Repository)의 파일을 새로운 버전으로 갱신함.",
    "answer": "Answer 1 : 체크인\nAnswer 2 : Check-In"
  },
  {
    "question": "Question 1057.\n다음은 소프트웨어의 버전 등록 관련 주요 기능 중 하나에 대한 설명이다.\n체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌(Conflict)을 알리고 diff도구를 이용해 수정한 후 갱신을 완료함.",
    "answer": "Answer 1 : 커밋\nAnswer 2 : Commit"
  },
  {
    "question": "Question 1058.\n다음은 소프트웨어의 버전 등록 관련 주요 기능 중 하나에 대한 설명이다.\n저장소에 있는 최신 버전으로 자신의 작업 공간을 ○○○함.",
    "answer": "Answer 1 : 동기화\nAnswer 2 : Update"
  },
  {
    "question": "Question 1059.\n버전 관리 자료가 지역 컴퓨터의 공유 폴더에 저장되어 관리되는 방식은?\n파일을 잘못 복사하거나 다른 위치로 복사하는 것에 대비하기 위한 파일의 변경 사항을 데이터베이스레 기록한다.\n종류 : SCCS, RCS, PVCS, QVCS 등.",
    "answer": "Answer 1 : 공유 폴더 방식"
  },
  {
    "question": "Question 1060.\n버전 관리 자료가 서버에 저장되어 관리되는 방식은?\n모든 버전 관리는 서버에서 수행된다.\n서버에 문제가 생기면 서버가 복구되기 전까지 다른 개발자와의 협업 및 버전 관리 작업은 중단된다.\n종류 : CVS, SVN(subversion), CVSNT, Clear Case, CMVC, Perforce 등.",
    "answer": "Answer 1 : 클라이언트/서버 방식"
  },
  {
    "question": "Question 1061.\n버전 관리 자료가 하나의 원격 저장소와 분산된 개발자 PC의 지역 저장소에 함께 저장되어 관리되는 방식은?\n지역 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 지역 저장소의 자료를 이용하여 작업할 수 있다.\n종류 : Git, GNU arch, DCVS, Bazaar, Mercurial, TeamWare, Bitkeeper, Plastic SCM 등.",
    "answer": "Answer 1 : 분산 저장소 방식"
  },
  {
    "question": "Question 1062.\nCVS를 개선한 것으로, 아파치 소프트웨어 재단에서 2000년에 발표하였다.\n클라이언트/서버 구조로, 서버(저장소, Repository)에는 최신 버전의 파일들과 변경 사항이 관리된다.\n소스가 오픈되어 있어 무료로 사용할 수 있다.\nCVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능하다.",
    "answer": "Answer 1 : Subversion\nAnswer 2 : 서브버전\nAnswer 3 : SVN"
  },
  {
    "question": "Question 1063.\n리누스 토발즈(Linus Torvalds)가 2005년 리눅스 커널 개발에 사용할 관리 도구로 개발한 이후 주니오 하마노(Junio Hamano)에 의해 유지 보수되고 있는 것은?\n분산 버전 관리 시스템으로 2개의 저장소, 즉 지역 저장소와 원격 저장소가 존재한다.\n버전 관리가 지역 저장소에서 진행되므로 버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업이 가능하다.",
    "answer": "Answer 1 : Git\nAnswer 2 : 깃"
  },
  {
    "question": "Question 1064.\n빌드를 포함하여 테스트 및 배포를 자동화하는 도구는?\n애자일(Agile)과 가은 지속적인 통합(COntinuous Integration) 개발 환경에서 유용하게 활용된다.\n빌드 자동화 도구에는 Ant, Make, Maven, Gradle, Jenkins 등이 있으며, 이중 Jenkins와 Gradle이 가장 대표적이다.",
    "answer": "Answer 1 : 빌드 자동화 도구"
  },
  {
    "question": "Question 1065.\nJAVA 기반의 오픈 소수 형태로, 서블릿 컨테이너에서 실행되는 서버 기반 도구는?\n가장 많이 사용되는 빌드 자동화 도구이다.\nSVN, Git 등 대부분의 형상 관리 도구와 연동이 가능하다.\n친숙한 Web GUI 제공으로 사용이 쉽다.",
    "answer": "Answer 1 : Jenkins"
  },
  {
    "question": "Question 1066.\nGroovy를 기반으로 한 오픈 소스 형태의 자동화 도구는?\n안드로이드 앱 개발 환경에서 사용된다.\n안드로이드뿐만 아니라 플러그인을 설정하면, JAVA, C/C++, Python 등의 언어도 빌드할 수 있다.\nGroovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용한다.",
    "answer": "Answer 1 : Gradle"
  }
]
